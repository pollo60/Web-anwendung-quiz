<!DOCTYPE html>
<html lang="de">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Web-basierte Anwendungssysteme - Quiz</title>
    <link rel="stylesheet" href="style.css">
</head>
<body>
    <div class="level-up-overlay" id="levelUpOverlay">
        <div class="level-up-content">
            <h2 id="levelUpMessage"></h2>
            <p id="levelUpDescription"></p>
            <button class="btn btn-primary" id="levelUpContinue">Weiter</button>
        </div>
    </div>

    <div class="container">
        <div class="header">
            <div class="xp-container">
                <span>XP: <strong id="xpDisplay">0</strong></span>
            </div>
            <div class="level-badge-wrap">
                <div class="level-badge" id="levelBadge">Level 1</div>
                <div class="title-plaque" id="titlePlaque">Bauernkind</div>
            </div>
            <div id="timerDisplay" class="timer-display" style="display: none;">
                Zeit: <span id="timer">00:00</span>
            </div>
            <h1>üìö Web-basierte Anwendungssysteme</h1>
            <p>Interaktiver Wissenstest</p>
            <div class="progress-container">
                <div class="progress-bar" id="progressBar"></div>
            </div>
        </div>

        <div class="content">
            <!-- START SCREEN -->
            <div id="startScreen" class="start-screen">
                <div class="session-leaderboard wooden-board" style="position: relative;">
                    <h3 class="leaderboard-title">üèÜ Bestenliste</h3>
                    <button id="clearAllLeaderboardBtn" class="clear-all-btn" title="Alle Eintr√§ge l√∂schen">√ó</button>
                    <div class="leaderboard-tabs">
                        <button class="tab-btn start-tab-btn active" data-mode="timetrials">‚ö° Timetrials</button>
                        <button class="tab-btn start-tab-btn" data-mode="normal">üéØ Normal</button>
                    </div>
                    <div id="startLeaderboardContent" class="leaderboard-content">
                        <div class="empty-leaderboard">Noch keine Eintr√§ge vorhanden.<br>Spiele eine Runde ‚Äì mit oder ohne Timer.</div>
                    </div>
                </div>

                <div class="player-name-wrapper">
                    <label class="player-name-label" for="playerName">Name (optional)</label>
                    <input id="playerName" class="name-input" type="text" placeholder="z.B. Luca, Marie">
                    
                    <div id="nameDisclaimer" style="margin-top: 10px; padding: 10px; background: rgba(52, 152, 219, 0.2); border-radius: 8px; font-size: 11px; color: #fff; text-align: left; display: none;">
                        <strong>üíæ Name speichern?</strong><br>
                        Dein Name wird lokal im Browser gespeichert und beim n√§chsten Besuch automatisch geladen.
                        <div style="margin-top: 8px; text-align: center;">
                            <label style="display: inline-flex; align-items: center; cursor: pointer;">
                                <input type="checkbox" id="saveNameCheckbox" style="margin-right: 5px;">
                                <span style="font-size: 11px;">Name f√ºr n√§chstes Mal speichern</span>
                            </label>
                        </div>
                    </div>
                    
                    <div id="resetProgressContainer" style="margin-top: 10px; text-align: center; display: none;">
                        <button id="resetProgressBtn" class="btn btn-secondary" style="font-size: 10px; padding: 8px 16px;">
                            üîÑ Fortschritt zur√ºcksetzen
                        </button>
                    </div>
                </div>

                <div class="modifier-selection" style="margin-bottom: 30px;">
                    <label style="display: block; margin-bottom: 15px; color: #fff; font-weight: 600; font-size: 1.1em; text-shadow: 1px 1px 2px rgba(0,0,0,0.8);">W√§hle deine Modifikatoren (mehrere m√∂glich):</label>
                    <div style="display: flex; gap: 15px; justify-content: center; flex-wrap: wrap;">
                        <button class="modifier-btn active" data-modifier="normal">
                            <div style="font-size: 24px; margin-bottom: 8px;">üéØ</div>
                            <div style="font-weight: 600;">Normal</div>
                            <div style="font-size: 0.8em; opacity: 0.8;">Klassisches Quiz</div>
                        </button>
                        <button class="modifier-btn" data-modifier="speedrun">
                            <div style="font-size: 24px; margin-bottom: 8px;">‚ö°</div>
                            <div style="font-weight: 600;">Timer</div>
                            <div style="font-size: 0.8em; opacity: 0.8;">Gegen die Zeit</div>
                        </button>
                        <button class="modifier-btn" data-modifier="practice">
                            <div style="font-size: 24px; margin-bottom: 8px;">üìö</div>
                            <div style="font-weight: 600;">√úbung</div>
                            <div style="font-size: 0.8em; opacity: 0.8;">falsche Fragen wiederholen</div>
                        </button>
                        <button class="modifier-btn" data-modifier="woche2">
                            <div style="font-size: 24px; margin-bottom: 8px;">üóìÔ∏è</div>
                            <div style="font-weight: 600;">Nur 2. Woche</div>
                            <div style="font-size: 0.8em; opacity: 0.8;">Einleitung, Blatt 1</div>
                        </button>
                        <button class="modifier-btn" data-modifier="woche3">
                            <div style="font-size: 24px; margin-bottom: 8px;">üóìÔ∏è</div>
                            <div style="font-weight: 600;">Nur 3. Woche</div>
                            <div style="font-size: 0.8em; opacity: 0.8;">Kernkonzepte, Blatt 2</div>
                        </button>
                        <button class="modifier-btn" data-modifier="woche4">
                            <div style="font-size: 24px; margin-bottom: 8px;">üóìÔ∏è</div>
                            <div style="font-weight: 600;">Nur 4. Woche</div>
                            <div style="font-size: 0.8em; opacity: 0.8;">MVC, Blatt 3</div>
                        </button>
                        <button class="modifier-btn" data-modifier="woche5">
                            <div style="font-size: 24px; margin-bottom: 8px;">üóìÔ∏è</div>
                            <div style="font-weight: 600;">Nur 5. Woche</div>
                            <div style="font-size: 0.8em; opacity: 0.8;">RESTful Service API, Blatt 4</div>
                        </button>
                        <button class="modifier-btn" data-modifier="woche6">
                            <div style="font-size: 24px; margin-bottom: 8px;">üóìÔ∏è</div>
                            <div style="font-weight: 600;">Nur 6. Woche</div>
                            <div style="font-size: 0.8em; opacity: 0.8;">GraphQL-API, Blatt 5</div>
                        </button>
                    </div>
                </div>

                <div class="difficulty-selection" style="margin-bottom: 30px;">
                    <label style="display: block; margin-bottom: 15px; color: #fff; font-weight: 600; font-size: 1.1em; text-shadow: 1px 1px 2px rgba(0,0,0,0.8);">W√§hle den Schwierigkeitsgrad:</label>
                    <div style="display: flex; gap: 15px; justify-content: center; flex-wrap: wrap;">
                        <button class="difficulty-btn selected" data-difficulty="all">
                            <div style="font-size: 24px; margin-bottom: 8px;">üåü</div>
                            <div style="font-weight: 600;">Alle Fragen</div>
                            <div style="font-size: 0.8em; opacity: 0.8;">Keine Einschr√§nkung</div>
                        </button>
                        <button class="difficulty-btn" data-difficulty="easy">
                            <div style="font-size: 24px; margin-bottom: 8px;">üå±</div>
                            <div style="font-weight: 600;">Einfach</div>
                            <div style="font-size: 0.8em; opacity: 0.8;">Grundlagen</div>
                        </button>
                        <button class="difficulty-btn" data-difficulty="medium">
                            <div style="font-size: 24px; margin-bottom: 8px;">‚ö°</div>
                            <div style="font-weight: 600;">Mittel</div>
                            <div style="font-size: 0.8em; opacity: 0.8;">Fortgeschritten</div>
                        </button>
                        <button class="difficulty-btn" data-difficulty="hard">
                            <div style="font-size: 24px; margin-bottom: 8px;">üî•</div>
                            <div style="font-weight: 600;">Schwer</div>
                            <div style="font-size: 0.8em; opacity: 0.8;">Komplex</div>
                        </button>
                        <button class="difficulty-btn" data-difficulty="expert">
                            <div style="font-size: 24px; margin-bottom: 8px;">üíé</div>
                            <div style="font-weight: 600;">Experte</div>
                            <div style="font-size: 0.8em; opacity: 0.8;">Master-Level</div>
                        </button>
                    </div>
                </div>

                <label style="display: block; margin-bottom: 15px; margin-top: 20px; color: #fff; font-weight: 600; font-size: 1.1em; text-shadow: 1px 1px 2px rgba(0,0,0,0.8); text-align: center;">W√§hle dein Level:</label>
                
                <div class="level-selection">
                    <div class="level-card selected" data-level="gemischt">
                        <div class="level-icon">‚öñÔ∏è</div>
                        <div class="level-name">Gemischt</div>
                        <div class="level-description">Alle Fragen</div>
                    </div>
                    <div class="level-card" data-level="uebung">
                        <div class="level-icon">üìù</div>
                        <div class="level-name">Fragen zur √úbung</div>
                        <div class="level-description">aus den aufgabenbl√§ttern</div>
                    </div>
                    <div class="level-card" data-level="vorlesung-offiziell">
                        <div class="level-icon">üéì</div>
                        <div class="level-name">VL Offiziell</div>
                        <div class="level-description">Vom Fragen-Blatt</div>
                    </div>
                    <div class="level-card" data-level="offiziell">
                        <div class="level-icon">üìã</div>
                        <div class="level-name">Offizielle Fragen</div>
                        <div class="level-description">Neue offizielle Testfragen</div>
                    </div>
                </div>

                <button class="btn btn-primary" id="startBtn" disabled>Lade Fragen...</button>
            </div>

            <!-- QUESTIONS -->
            <div id="questionsContainer"></div>

            <!-- RESULT SCREEN -->
            <div id="resultScreen" class="result-container">
                <div class="score-circle">
                    <div class="score-text" id="scoreText"></div>
                </div>
                <div class="result-message" id="resultMessage"></div>
                <div class="result-details" id="resultDetails"></div>

                <div class="stats-grid">
                    <div class="stat-card">
                        <div class="stat-value" id="statCorrect">0</div>
                        <div class="stat-label">Richtig</div>
                    </div>
                    <div class="stat-card">
                        <div class="stat-value" id="statWrong">0</div>
                        <div class="stat-label">Falsch</div>
                    </div>
                    <!-- Time taken (only shown for Timer/Speedrun mode) -->
                    <div class="stat-card" id="statTimeCard" style="display:none;">
                        <div class="stat-value" id="statTime">00:00</div>
                        <div class="stat-label">Zeit gebraucht</div>
                    </div>
                    <div class="stat-card">
                        <div class="stat-value" id="statXP">0</div>
                        <div class="stat-label">XP Gewonnen</div>
                    </div>
                    <div class="stat-card">
                        <div class="stat-value" id="statLevel">1</div>
                        <div class="stat-label">Level Erreicht</div>
                    </div>
                    <div class="stat-card" style="grid-column: 1 / -1; background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);">
                        <div class="stat-value" id="statLifetimeXP">0</div>
                        <div class="stat-label" style="color: white;">üèÜ Gesamt-XP (Lifetime)</div>
                    </div>
                </div>

                <div class="share-box">
                    <div style="font-weight:600; margin-bottom:10px;">‚ú® Mit anderen teilen</div>
                    <a id="whatsappShareBtn" class="btn btn-whatsapp" href="#" target="_blank" rel="noopener noreferrer" style="text-decoration:none; display:inline-block; margin-bottom:10px;">
                        üì± Per WhatsApp teilen
                    </a>
                </div>

                <div class="session-leaderboard wooden-board" style="margin-top: 30px;">
                    <h3 class="leaderboard-title">üèÜ Session-Bestenliste</h3>
                    <div class="leaderboard-tabs">
                        <button class="tab-btn active" data-mode="timetrials">‚ö° Timetrials</button>
                        <button class="tab-btn" data-mode="normal">üéØ Normal</button>
                    </div>
                    <div id="leaderboardContent" class="leaderboard-content">
                        <div class="empty-leaderboard">Noch keine Eintr√§ge in dieser Session.</div>
                    </div>
                </div>

                <button class="btn btn-primary" id="restartBtn">Neues Quiz starten</button>
            </div>
        </div>
    </div>

    <script>
        'use strict';

        // ============================================================================
        // GLOBAL STATE - Single source of truth
        // ============================================================================
        const STATE = {
            // Data
            questionDatabase: [],
            questionsLoaded: false,
            wrongAnsweredQuestions: [],
            
            // Quiz configuration
            selectedLevel: 'gemischt',
            selectedDifficulty: 'all',
            activeModifiers: ['normal'],
            
            // Quiz runtime
            currentQuestions: [],
            currentQuestionIndex: 0,
            userAnswers: [],
            score: 0,
            correctCount: 0,
            wrongCount: 0,
            questionAnswered: false,
            
            // Player
            playerName: '',
            xp: 0,
            level: 1,
            lifetimeXP: 0,  // Total XP earned across all sessions (never reset)
            
            // Timer
            timerInterval: null,
            startTime: 0,
            currentTime: 0,
            
            // Leaderboard
            leaderboard: {
                uebung: [],
                'vorlesung-offiziell': [],
                gemischt: [],
                offiziell: []
            }
        };

        // ============================================================================
        // UTILITY FUNCTIONS
        // ============================================================================
        
        function shuffleArray(array) {
            const arr = [...array];
            for (let i = arr.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [arr[i], arr[j]] = [arr[j], arr[i]];
            }
            return arr;
        }

        // Small helpers to reduce duplication
        function renderDifficultyDots(diff = 1) {
            const d = Math.max(1, Math.min(4, diff));
            return Array(4).fill(0)
                .map((_, i) => `<div class="difficulty-dot ${i < d ? 'active' : ''}"></div>`)
                .join('');
        }

        function setsEqual(a, b) {
            if (a.size !== b.size) return false;
            for (const v of a) if (!b.has(v)) return false;
            return true;
        }
        // ----------------------------------------------------------------------------
        // Leaderboard helpers (DRY)
        // ----------------------------------------------------------------------------
        function getFilteredSortedLeaderboardEntries(mode) {
            const allEntries = Object.values(STATE.leaderboard).flat();
            const filtered = mode === 'timetrials'
                ? allEntries.filter(e => e.time != null)
                : allEntries.filter(e => e.time == null);
            filtered.sort((a, b) => {
                if (a.time != null && b.time != null) return a.time - b.time;
                return b.score - a.score;
            });
            return filtered;
        }

        function leaderboardEntryHTML(e, i) {
            const gi = getGameLevelInfo(e.gameLevel);
            return `
                <div class="leaderboard-entry">
                    <span class="entry-rank">${i + 1}.</span>
                    <span class="entry-name">${e.name}</span>
                    <span class="entry-level">
                        <span class="entry-level-mobile" title="${gi.label}">${gi.emoji}</span>
                        <span class="entry-level-desktop">${gi.emoji} ${gi.label}</span>
                    </span>
                    <span class="entry-details">
                        ${e.time ? formatTime(e.time) : `${e.score}/${e.questionCount}`}
                        <br><small>${e.percentage}% ‚Ä¢ ${e.xp} XP</small>
                    </span>
                </div>`;
        }

        function renderLeaderboardTo(containerId, mode, emptyText) {
            const content = document.getElementById(containerId);
            if (!content) return;
            const entries = getFilteredSortedLeaderboardEntries(mode);
            if (entries.length === 0) {
                content.innerHTML = `<div class="empty-leaderboard">${emptyText}</div>`;
                return;
            }
            content.innerHTML = entries.slice(0, 10).map(leaderboardEntryHTML).join('');
        }
        // Mapping for Spiel-Level (Modus) ‚Üí Emoji/Label (used by both leaderboards)
        function getGameLevelInfo(levelKey) {
            const map = {
                'gemischt': { emoji: '‚öñÔ∏è', label: 'Gemischt' },
                'uebung': { emoji: 'üìù', label: '√úbung' },
                'vorlesung-offiziell': { emoji: 'üéì', label: 'VL Offiziell' },
                'offiziell': { emoji: 'üìã', label: 'Offiziell' }
            };
            return map[levelKey] || { emoji: '‚ùì', label: 'Unbekannt' };
        }

        function formatTime(ms) {
            const seconds = Math.floor(ms / 1000);
            const minutes = Math.floor(seconds / 60);
            const remainingSeconds = seconds % 60;
            return `${String(minutes).padStart(2, '0')}:${String(remainingSeconds).padStart(2, '0')}`;
        }

        // ============================================================================
        // LOCAL STORAGE
        // ============================================================================
        
        function saveToLocalStorage(key, value) {
            try {
                localStorage.setItem(key, JSON.stringify(value));
            } catch (e) {
                console.warn('LocalStorage save failed:', e);
            }
        }

        function loadFromLocalStorage(key, defaultValue = null) {
            try {
                const item = localStorage.getItem(key);
                return item ? JSON.parse(item) : defaultValue;
            } catch (e) {
                console.warn('LocalStorage load failed:', e);
                return defaultValue;
            }
        }

        function savePlayerName(name) {
            saveToLocalStorage('playerName', name);
        }

        // Normalize player names to avoid duplicate profiles by case/whitespace
        function normalizePlayerKey(name) {
            const key = (name || '').trim().toLowerCase();
            return key || 'anonymous';
        }

        function loadPlayerName() {
            return loadFromLocalStorage('playerName', '');
        }

        function saveProgress() {
            const key = `progress_${normalizePlayerKey(STATE.playerName)}`;
            const payload = {
                xp: STATE.xp,
                level: STATE.level,
                lifetimeXP: STATE.lifetimeXP,
                dataVersion: 1
            };
            saveToLocalStorage(key, payload);
        }

        function findLegacyProgressForName(playerName, normalizedKey) {
            // Search localStorage for old progress keys that used the raw name (case-sensitive) before normalization
            try {
                const norm = normalizePlayerKey(playerName);
                // Pass 1: exact old pattern progress_<RawName>
                for (let i = 0; i < localStorage.length; i++) {
                    const k = localStorage.key(i);
                    if (!k || k === normalizedKey) continue;
                    if (!k.startsWith('progress_')) continue;
                    const suffix = k.substring('progress_'.length);
                    if (normalizePlayerKey(suffix) === norm) {
                        const val = JSON.parse(localStorage.getItem(k));
                        return { key: k, value: val };
                    }
                }
                // Pass 2: tolerant search ‚Äì any key containing both 'progress' and the player's name (case-insensitive)
                for (let i = 0; i < localStorage.length; i++) {
                    const k = localStorage.key(i);
                    if (!k || k === normalizedKey) continue;
                    const lower = k.toLowerCase();
                    if (!lower.includes('progress')) continue;
                    if (!lower.includes(norm)) continue;
                    // Avoid picking unrelated non-JSON values
                    const raw = localStorage.getItem(k);
                    try {
                        const val = JSON.parse(raw);
                        if (val && (typeof val === 'object') && ('xp' in val || 'level' in val || 'lifetimeXP' in val)) {
                            return { key: k, value: val };
                        }
                    } catch (_) {
                        // not JSON, skip
                    }
                }
            } catch (e) {
                console.warn('Legacy progress scan failed:', e);
            }
            return null;
        }

        function loadProgress() {
            const key = `progress_${normalizePlayerKey(STATE.playerName)}`;
            // Try exact (normalized) key first
            let progress = loadFromLocalStorage(key, null);
            const hasName = (STATE.playerName || '').trim().length > 0;
            // If not found OR looks like a fresh/empty record, attempt legacy migration
            const looksEmpty = !progress || (
                (Number(progress.level) || 1) <= 1 &&
                (Number(progress.xp) || 0) === 0 &&
                (Number(progress.lifetimeXP) || 0) === 0
            );
            if (hasName && looksEmpty) {
                const legacy = findLegacyProgressForName(STATE.playerName, key);
                if (legacy && legacy.value) {
                    progress = legacy.value;
                    // Save under normalized key and remove old key to avoid duplicates
                    saveToLocalStorage(key, progress);
                    try { localStorage.removeItem(legacy.key); } catch (e) {}
                }
            }
            // Default fresh profile if still missing
            if (!progress) {
                progress = { xp: 0, level: 1, lifetimeXP: 0, dataVersion: 1 };
            }

            STATE.xp = progress.xp || 0;
            STATE.level = progress.level || 1;
            STATE.lifetimeXP = progress.lifetimeXP || 0;
            
            // CRITICAL FIX: Reconstruct lifetimeXP if missing or incorrect
            // This ensures title calculation works properly based on total XP earned
            const minLifetimeForLevel = calculateMinimumLifetimeXP(STATE.level, STATE.xp);
            const needsReconstruction = STATE.lifetimeXP < minLifetimeForLevel;
            
            if (needsReconstruction) {
                STATE.lifetimeXP = minLifetimeForLevel;
                console.log(`üîÑ Reconstructed lifetimeXP: ${STATE.lifetimeXP} for Level ${STATE.level} (${STATE.xp} XP into level)`);
                // Persist corrected value immediately
                saveProgress();
            } else {
                console.log(`‚úì Loaded lifetimeXP: ${STATE.lifetimeXP} for Level ${STATE.level} (${STATE.xp} XP into level)`);
            }
        }
        
        // Calculate minimum lifetime XP needed to reach a given level with current XP
        function calculateMinimumLifetimeXP(currentLevel, currentXP) {
            let total = 0;
            // Sum XP requirements for all completed levels (1 to currentLevel-1)
            for (let lvl = 1; lvl < currentLevel; lvl++) {
                total += getXPForLevel(lvl);
            }
            // Add progress into current level
            total += currentXP;
            return total;
        }

        function saveLeaderboard() {
            saveToLocalStorage('leaderboard', STATE.leaderboard);
        }

        function loadLeaderboard() {
            STATE.leaderboard = loadFromLocalStorage('leaderboard', {
                uebung: [],
                'vorlesung-offiziell': [],
                gemischt: [],
                offiziell: []
            });
        }

        // ============================================================================
        // QUESTION LOADING
        // ============================================================================
        
        async function loadQuestions() {
            try {
                const response = await fetch('questions.json');
                if (!response.ok) {
                    throw new Error(`HTTP ${response.status}`);
                }
                STATE.questionDatabase = await response.json();
                STATE.questionsLoaded = true;
                console.log(`‚úÖ Loaded ${STATE.questionDatabase.length} questions`);
                return true;
            } catch (error) {
                console.error('‚ùå Failed to load questions:', error);
                alert('Fehler beim Laden der Fragen. Bitte Seite neu laden.');
                return false;
            }
        }

        function getQuestionsByLevel(levelKey) {
            const tagMapping = {
                'uebung': ['uebung'],
                'vorlesung-offiziell': ['vl-offiziell'],
                // Gemischt soll auch Fragen mit dem Tag "gemischt" enthalten
                'gemischt': ['gemischt', 'uebung', 'neue-vorlesung', 'vl-offiziell', 'offiziell'],
                'offiziell': ['offiziell']
            };
            
            const tags = tagMapping[levelKey] || [];
            return STATE.questionDatabase.filter(q => 
                tags.some(tag => q.tags && q.tags.includes(tag))
            );
        }

        function selectQuestions(level, difficulty, modifiers, count = 15) {
            let questions = getQuestionsByLevel(level);
            
            // Filter by difficulty
            if (difficulty !== 'all') {
                const diffMap = { easy: 1, medium: 2, hard: 3, expert: 4 };
                const targetDiff = diffMap[difficulty];
                questions = questions.filter(q => q.difficulty === targetDiff);
            }
            
            // Filter by week tags
            const weekFilters = modifiers.filter(m => m.startsWith('woche'));
            if (weekFilters.length > 0) {
                questions = questions.filter(q => 
                    weekFilters.some(week => q.tags && q.tags.includes(week))
                );
            }
            
            // Practice mode: only wrong answers
            if (modifiers.includes('practice')) {
                const wrongQuestions = STATE.wrongAnsweredQuestions.map(w => w.question);
                questions = questions.filter(q =>
                    wrongQuestions.some(wq => wq.question === q.question)
                );
            }
            
            // Shuffle and take count
            return shuffleArray(questions).slice(0, Math.min(count, questions.length));
        }

        // ============================================================================
        // XP & LEVEL SYSTEM
        // ============================================================================
        
        function getXPForLevel(level) {
            // Optimized progressive formula with smooth, gradual increases
            // Level 153 reachable in 88 days with 3 perfect quizzes/day (290 XP each)
            // Early levels: Faster progression (80-150 XP)
            // Late levels: Gentle exponential growth (2-8% increase per level)
            if (level <= 10) {
                return 80 + level * 7;
            }
            // Combines linear and exponential growth for balanced progression
            return Math.floor(100 + level * 3.5 + Math.pow(level - 10, 1.15));
        }

        function getTitleForLevel(level) {
            const titles = [
                'Bauernkind',      // Level 1-9
                'Dorfbewohner',    // Level 10-19
                'H√§ndler',         // Level 20-29
                'Stadtbewohner',   // Level 30-39
                'Lehrling',        // Level 40-49
                'Gelehrter',       // Level 50-59
                'Professor',       // Level 60-69
                'Adel',            // Level 70-79
                'Weise',           // Level 80-89
                'Magier',          // Level 90-99
                'Schwertmagier',   // Level 100-109
                'Paladin',         // Level 110-119
                'Legende',         // Level 120-129
                'Champion',        // Level 130-139
                'Hochadel',        // Level 140-149
                'Erzmagus',        // Level 150-159
                'Weltenadel',      // Level 160-169
                'Aethertyrann',    // Level 170-179
                'G√∂tterschl√§chter', // Level 180-189
                'Todesgottheit'    // Level 190+
            ];
            
            // Berechne Titel-Index: Bei Level 10, 20, 30 etc. neuer Titel
            const titleIndex = Math.floor(level / 10);
            return titles[Math.min(titleIndex, titles.length - 1)] || 'Todesgottheit';
        }

        // Calculate level purely based on lifetime XP (monotonic progression)
        function getLevelFromLifetimeXP(lifetimeXP) {
            let lvl = 1;
            let remaining = lifetimeXP || 0;
            while (true) {
                const req = getXPForLevel(lvl);
                if (remaining < req) break;
                remaining -= req;
                lvl++;
                if (lvl > 10000) break; // safety
            }
            return { level: lvl, xpIntoLevel: remaining };
        }

        function updateXPDisplay() {
            document.getElementById('xpDisplay').textContent = STATE.xp;
            document.getElementById('levelBadge').textContent = `Level ${STATE.level}`;
            // Title reflects lifetime progression exclusively
            const lifetimeDerived = getLevelFromLifetimeXP(STATE.lifetimeXP || 0);
            const titleText = getTitleForLevel(lifetimeDerived.level);
            const titleIndex = Math.floor(lifetimeDerived.level / 10);
            console.log(`üìä Title calculation: lifetimeXP=${STATE.lifetimeXP} ‚Üí derived level=${lifetimeDerived.level} ‚Üí titleIndex=${titleIndex} ‚Üí title="${titleText}"`);
            document.getElementById('titlePlaque').textContent = titleText;
            saveProgress();
        }

        function checkLevelUp() {
            const requiredXP = getXPForLevel(STATE.level);
            if (STATE.xp >= requiredXP) {
                STATE.level++;
                STATE.xp -= requiredXP;
                showLevelUp();
                updateXPDisplay();
            }
        }

        function showLevelUp() {
            const overlay = document.getElementById('levelUpOverlay');
            const message = document.getElementById('levelUpMessage');
            const description = document.getElementById('levelUpDescription');
            
            message.textContent = `Level ${STATE.level} erreicht! üéâ`;
            
            // Only show title message when unlocking a new title tier (every 10 levels)
            if (STATE.level % 10 === 0) {
                description.textContent = `Du bist jetzt ${getTitleForLevel(STATE.level)}!`;
            } else {
                description.textContent = '';
            }
            
            overlay.classList.add('show');
        }

        // ============================================================================
        // UI UPDATES
        // ============================================================================
        
        function updateProgress() {
            const percentage = STATE.currentQuestions.length > 0
                ? ((STATE.currentQuestionIndex + 1) / STATE.currentQuestions.length) * 100
                : 0;
            document.getElementById('progressBar').style.width = `${percentage}%`;
        }

        function showScreen(screenId) {
            ['startScreen', 'questionsContainer', 'resultScreen'].forEach(id => {
                const el = document.getElementById(id);
                if (el) {
                    if (id === screenId) {
                        el.style.display = 'block';
                        if (id === 'resultScreen') el.classList.add('show');
                    } else {
                        el.style.display = 'none';
                        if (id === 'resultScreen') el.classList.remove('show');
                    }
                }
            });
            
            // Update body class for background
            document.body.className = screenId === 'questionsContainer' ? 'in-quiz' : '';

            // Show progress bar only during quiz view
            const progress = document.querySelector('.progress-container');
            if (progress) {
                progress.style.display = (screenId === 'questionsContainer') ? 'block' : 'none';
            }
        }

        // ============================================================================
        // QUESTION RENDERING
        // ============================================================================
        
        function renderQuestion() {
            const container = document.getElementById('questionsContainer');
            const question = STATE.currentQuestions[STATE.currentQuestionIndex];
            
            if (!question) {
                console.error('No question to render');
                return;
            }

            STATE.questionAnswered = false;
            
            let optionsHTML = renderQuestionOptions(question);
            
            const difficultyDots = renderDifficultyDots(question.difficulty || 1);

            container.innerHTML = `
                <div class="question-container active">
                    <div class="question-toolbar" style="display:flex; justify-content:flex-start; margin-bottom:10px;">
                        <button class="btn btn-abort" id="abortBtn">Quiz abbrechen</button>
                    </div>
                    <div class="question-header">
                        <span class="question-number">Frage ${STATE.currentQuestionIndex + 1}/${STATE.currentQuestions.length}</span>
                        <div class="difficulty-indicator">${difficultyDots}</div>
                    </div>
                    <div class="question-text">${question.question || 'Frage'}</div>
                    <div class="options" id="optionsContainer">
                        ${optionsHTML}
                    </div>
                    <div class="feedback" id="feedback"></div>
                    <div class="buttons">
                        ${STATE.currentQuestionIndex > 0 ? '<button class="btn btn-secondary" id="prevBtn">‚Üê Zur√ºck</button>' : ''}
                        <button class="btn btn-primary" id="checkBtn" disabled>Pr√ºfen</button>
                    </div>
                </div>
            `;

            updateProgress();
            attachQuestionListeners(question);
        }

        function renderQuestionOptions(question) {
            const letters = ['A', 'B', 'C', 'D', 'E', 'F'];
            
            if (question.type === 'multiple') {
                const shuffled = question.options.map((opt, idx) => ({ text: opt, originalIdx: idx }));
                shuffleArray(shuffled);
                question._shuffledOptions = shuffled;
                
                return shuffled.map((opt, idx) => `
                    <div class="option" data-index="${idx}">
                        <span>${opt.text}</span>
                    </div>
                `).join('');
                
            } else if (question.type === 'checkbox') {
                return question.options.map((opt, idx) => `
                    <div class="option" data-index="${idx}">
                        <input type="checkbox" id="opt${idx}" data-index="${idx}">
                        <label for="opt${idx}" style="cursor:pointer; flex:1;">${opt}</label>
                    </div>
                `).join('');
                
            } else if (question.type === 'text') {
                return `<input type="text" class="text-input" id="textAnswer" placeholder="Deine Antwort...">`;
                
            } else if (question.type === 'fillblank') {
                let text = question.question;
                (question.blanks || []).forEach((_, i) => {
                    text = text.replace('_____', `<input type="text" class="blank-input" id="blank${i}" placeholder="...">`);
                });
                return `<div style="font-size:18px; line-height:2;">${text}</div>`;
                
            } else if (question.type === 'sort') {
                const items = shuffleArray([...(question.items || [])]);
                return `
                    <div class="sortable-container" id="sortableContainer">
                        ${items.map(item => `
                            <div class="sortable-item" draggable="true" data-item="${item}">
                                <span class="drag-handle">‚ò∞</span>
                                <span>${item}</span>
                            </div>
                        `).join('')}
                    </div>
                `;
                
            } else if (question.type === 'matching') {
                const left = question.left || (question.pairs || []).map(p => p.left);
                const right = question.right || (question.pairs || []).map(p => p.right);
                const shuffledLeft = shuffleArray([...left]);
                const shuffledRight = shuffleArray([...right]);
                
                return `
                    <div class="matching-container">
                        <div class="matching-column" id="leftColumn">
                            ${shuffledLeft.map(item => `
                                <div class="matching-item" data-value="${item}" data-side="left">${item}</div>
                            `).join('')}
                        </div>
                        <div class="matching-column" id="rightColumn">
                            ${shuffledRight.map(item => `
                                <div class="matching-item" data-value="${item}" data-side="right">${item}</div>
                            `).join('')}
                        </div>
                    </div>
                    <div id="matchingPairs" style="margin-top:20px; display:none;"></div>
                `;
            }
            
            return '<p>Unbekannter Fragetyp</p>';
        }

        function getShuffledCorrectIndex(question) {
            if (!question || !question._shuffledOptions) return null;
            const correctOriginalIdx = question.correct;
            return question._shuffledOptions.findIndex(opt => opt.originalIdx === correctOriginalIdx);
        }

        // ============================================================================
        // QUESTION LISTENER HELPERS (modularized per type)
        // ============================================================================
        function setupMultipleListeners(checkBtn) {
            document.querySelectorAll('.option').forEach(opt => {
                opt.addEventListener('click', function() {
                    if (STATE.questionAnswered) return;
                    document.querySelectorAll('.option').forEach(o => o.classList.remove('selected'));
                    this.classList.add('selected');
                    if (checkBtn) checkBtn.disabled = false;
                });
            });
        }

        function setupCheckboxListeners(checkBtn) {
            const optionsContainer = document.getElementById('optionsContainer');
            const checkboxes = optionsContainer ? optionsContainer.querySelectorAll('input[type="checkbox"]') : document.querySelectorAll('#optionsContainer input[type="checkbox"]');
            const updateBtn = () => {
                const anyChecked = Array.from(checkboxes).some(cb => cb.checked);
                if (checkBtn) checkBtn.disabled = !anyChecked || STATE.questionAnswered;
            };
            checkboxes.forEach(cb => cb.addEventListener('change', updateBtn));
            // initialize state
            updateBtn();
        }

        function setupTextListeners(checkBtn) {
            const input = document.getElementById('textAnswer');
            if (input) {
                const update = () => {
                    if (checkBtn) checkBtn.disabled = !input.value.trim() || STATE.questionAnswered;
                };
                input.addEventListener('input', update);
                // initialize state
                update();
            }
        }

        function setupFillblankListeners(checkBtn, question) {
            const blanks = (question.blanks || []).map((_, i) => document.getElementById(`blank${i}`));
            const updateBtn = () => {
                const allFilled = blanks.every(b => b && b.value.trim());
                if (checkBtn) checkBtn.disabled = !allFilled || STATE.questionAnswered;
            };
            blanks.forEach(b => b && b.addEventListener('input', updateBtn));
            // initialize state
            updateBtn();
        }

        function setupSortListeners(checkBtn) {
            attachSortListeners();
            if (checkBtn) checkBtn.disabled = false;
        }

        function setupMatchingListeners(_checkBtn, question) {
            // Button will be enabled once all pairs are matched inside attachMatchingListeners
            attachMatchingListeners(question);
        }

        // ============================================================================
        // EVENT LISTENERS FOR QUESTIONS
        // ============================================================================
        
        function attachQuestionListeners(question) {
            const checkBtn = document.getElementById('checkBtn');
            const prevBtn = document.getElementById('prevBtn');
            const abortBtn = document.getElementById('abortBtn');
            
            if (question.type === 'multiple') {
                setupMultipleListeners(checkBtn);
            } else if (question.type === 'checkbox') {
                setupCheckboxListeners(checkBtn);
            } else if (question.type === 'text') {
                setupTextListeners(checkBtn);
            } else if (question.type === 'fillblank') {
                setupFillblankListeners(checkBtn, question);
            } else if (question.type === 'sort') {
                setupSortListeners(checkBtn);
            } else if (question.type === 'matching') {
                setupMatchingListeners(checkBtn, question);
            }
            
            if (checkBtn) {
                checkBtn.addEventListener('click', () => {
                    if (!STATE.questionAnswered) {
                        checkAnswer();
                    } else {
                        nextQuestion();
                    }
                });
            }
            
            if (prevBtn) {
                prevBtn.addEventListener('click', previousQuestion);
            }
            
            if (abortBtn) {
                abortBtn.addEventListener('click', () => {
                    if (confirm('Quiz abbrechen und zum Hauptmen√º?')) {
                        stopTimer();
                        showScreen('startScreen');
                    }
                });
            }
        }

        function attachSortListeners() {
            const items = document.querySelectorAll('.sortable-item');
            let draggedItem = null;
            
            items.forEach(item => {
                item.addEventListener('dragstart', function() {
                    draggedItem = this;
                    this.classList.add('dragging');
                });
                
                item.addEventListener('dragover', function(e) {
                    e.preventDefault();
                });
                
                item.addEventListener('drop', function(e) {
                    e.preventDefault();
                    if (this !== draggedItem && draggedItem) {
                        const container = document.getElementById('sortableContainer');
                        const items = Array.from(container.children);
                        const draggedIdx = items.indexOf(draggedItem);
                        const targetIdx = items.indexOf(this);
                        
                        if (draggedIdx < targetIdx) {
                            this.parentNode.insertBefore(draggedItem, this.nextSibling);
                        } else {
                            this.parentNode.insertBefore(draggedItem, this);
                        }
                    }
                });
                
                item.addEventListener('dragend', function() {
                    this.classList.remove('dragging');
                });
            });
        }

        function attachMatchingListeners(question) {
            let selectedLeft = null;
            let selectedRight = null;
            const pairs = [];
            
            document.querySelectorAll('.matching-item').forEach(item => {
                item.addEventListener('click', function() {
                    if (STATE.questionAnswered) return;
                    
                    if (this.dataset.side === 'left') {
                        document.querySelectorAll('[data-side="left"]').forEach(i => i.classList.remove('selected'));
                        this.classList.add('selected');
                        selectedLeft = this.dataset.value;
                    } else {
                        document.querySelectorAll('[data-side="right"]').forEach(i => i.classList.remove('selected'));
                        this.classList.add('selected');
                        selectedRight = this.dataset.value;
                    }
                    
                    if (selectedLeft && selectedRight) {
                        pairs.push({ left: selectedLeft, right: selectedRight });
                        document.querySelectorAll('.matching-item.selected').forEach(i => {
                            i.style.opacity = '0.3';
                            i.style.pointerEvents = 'none';
                        });
                        selectedLeft = null;
                        selectedRight = null;
                        
                        question._userPairs = pairs;
                        
                        const checkBtn = document.getElementById('checkBtn');
                        if (checkBtn && pairs.length === (question.pairs || []).length) {
                            checkBtn.disabled = false;
                        }
                    }
                });
            });
        }

        // ============================================================================
        // ANSWER CHECKING
        // ============================================================================
        
        function checkAnswer() {
            const question = STATE.currentQuestions[STATE.currentQuestionIndex];
            const feedback = document.getElementById('feedback');
            let isCorrect = false;
            
            if (question.type === 'multiple') {
                const selected = document.querySelector('.option.selected');
                if (!selected) {
                    showWarning('Bitte w√§hle eine Antwort!');
                    return;
                }
                
                const selectedIdx = parseInt(selected.dataset.index);
                const correctShuffledIdx = getShuffledCorrectIndex(question);
                isCorrect = selectedIdx === correctShuffledIdx;
                
                document.querySelectorAll('.option').forEach((opt, idx) => {
                    if (idx === correctShuffledIdx) {
                        opt.classList.add('correct');
                    } else if (idx === selectedIdx && !isCorrect) {
                        opt.classList.add('wrong');
                    }
                    opt.style.pointerEvents = 'none';
                });
                
            } else if (question.type === 'checkbox') {
                const optionsContainer = document.getElementById('optionsContainer');
                const checkboxes = optionsContainer ? optionsContainer.querySelectorAll('input[type="checkbox"]') : document.querySelectorAll('#optionsContainer input[type="checkbox"]');
                const selected = Array.from(checkboxes)
                    .map((cb, idx) => cb.checked ? idx : -1)
                    .filter(idx => idx >= 0);
                
                if (selected.length === 0) {
                    showWarning('W√§hle mindestens eine Antwort!');
                    return;
                }
                
                const correct = Array.isArray(question.correct) 
                    ? question.correct 
                    : [question.correct];
                
                const selectedSet = new Set(selected);
                const correctSet = new Set(correct);
                isCorrect = setsEqual(selectedSet, correctSet);
                
                const optionDivs = optionsContainer ? optionsContainer.querySelectorAll('.option') : document.querySelectorAll('#optionsContainer .option');
                optionDivs.forEach((opt, idx) => {
                    if (correctSet.has(idx)) {
                        opt.classList.add('correct');
                    } else if (selectedSet.has(idx)) {
                        opt.classList.add('wrong');
                    }
                });
                
                checkboxes.forEach(cb => cb.disabled = true);
                
            } else if (question.type === 'text') {
                const answer = document.getElementById('textAnswer').value.trim().toLowerCase();
                if (!answer) {
                    showWarning('Bitte gib eine Antwort ein!');
                    return;
                }
                
                const correctAnswers = Array.isArray(question.correct) ? question.correct : [question.correct];
                isCorrect = correctAnswers.some(c => answer.includes(c.toLowerCase()));
                
                const input = document.getElementById('textAnswer');
                input.style.borderColor = isCorrect ? '#48bb78' : '#f56565';
                input.disabled = true;
                
            } else if (question.type === 'fillblank') {
                const blanks = question.blanks || [];
                const answers = blanks.map((_, i) => {
                    const input = document.getElementById(`blank${i}`);
                    return input ? input.value.trim() : '';
                });
                
                if (answers.some(a => !a)) {
                    showWarning('F√ºlle alle L√ºcken aus!');
                    return;
                }
                
                isCorrect = answers.every((ans, i) => ans.toLowerCase() === blanks[i].toLowerCase());
                
                answers.forEach((_, i) => {
                    const input = document.getElementById(`blank${i}`);
                    if (input) {
                        const correct = input.value.trim().toLowerCase() === blanks[i].toLowerCase();
                        input.style.borderColor = correct ? '#48bb78' : '#f56565';
                        input.disabled = true;
                    }
                });
                
            } else if (question.type === 'sort') {
                const container = document.getElementById('sortableContainer');
                const items = Array.from(container.children);
                const userOrder = items.map(item => item.dataset.item);
                
                isCorrect = JSON.stringify(userOrder) === JSON.stringify(question.correct);
                
                items.forEach((item, i) => {
                    item.draggable = false;
                    if (item.dataset.item === question.correct[i]) {
                        item.classList.add('correct');
                    } else {
                        item.classList.add('wrong');
                    }
                });
                
            } else if (question.type === 'matching') {
                const userPairs = question._userPairs || [];
                
                if (userPairs.length !== (question.pairs || []).length) {
                    showWarning('Ordne alle Paare zu!');
                    return;
                }
                
                isCorrect = userPairs.every(up =>
                    question.pairs.some(cp => cp.left === up.left && cp.right === up.right)
                );
                
                document.querySelectorAll('.matching-item').forEach(item => {
                    item.style.pointerEvents = 'none';
                });
            }
            
            // Update stats
            STATE.questionAnswered = true;
            STATE.userAnswers[STATE.currentQuestionIndex] = isCorrect;
            
            if (isCorrect) {
                STATE.score++;
                STATE.correctCount++;
                let xpGain = question.xp || 10;
                if (STATE.activeModifiers.includes('speedrun')) {
                    xpGain = Math.floor(xpGain * 1.5);
                }
                STATE.xp += xpGain;
                STATE.lifetimeXP += xpGain;  // Track total XP earned
                updateXPDisplay();
                checkLevelUp();
                
                feedback.className = 'feedback correct show';
                feedback.innerHTML = `<strong>‚úì Richtig!</strong> <span class="xp-gain">+${xpGain} XP</span><br>${question.explanation || ''}`;
            } else {
                STATE.wrongCount++;
                
                if (!STATE.activeModifiers.includes('practice')) {
                    STATE.wrongAnsweredQuestions.push({
                        question: question,
                        timestamp: Date.now()
                    });
                    if (STATE.wrongAnsweredQuestions.length > 50) {
                        STATE.wrongAnsweredQuestions.shift();
                    }
                }
                
                let xpLoss = 0;
                if (question.difficulty >= 2 || STATE.activeModifiers.includes('speedrun')) {
                    xpLoss = Math.floor((question.xp || 10) * 0.5);
                    STATE.xp = Math.max(0, STATE.xp - xpLoss);
                    updateXPDisplay();
                }
                
                feedback.className = 'feedback wrong show';
                feedback.innerHTML = `<strong>‚úó Leider falsch.</strong>${xpLoss > 0 ? ` <span class="xp-gain" style="background:#f56565">-${xpLoss} XP</span>` : ''}<br>${question.explanation || ''}`;
            }
            
            // Update button
            const checkBtn = document.getElementById('checkBtn');
            if (checkBtn) {
                checkBtn.disabled = false;
                checkBtn.textContent = STATE.currentQuestionIndex === STATE.currentQuestions.length - 1 
                    ? 'Ergebnis anzeigen' 
                    : 'Weiter ‚Üí';
            }
        }

        function showWarning(msg) {
            const feedback = document.getElementById('feedback');
            feedback.className = 'feedback warning show';
            feedback.innerHTML = `<strong>‚ö† Hinweis:</strong> ${msg}`;
        }

        // ============================================================================
        // NAVIGATION
        // ============================================================================
        
        function nextQuestion() {
            STATE.currentQuestionIndex++;
            
            if (STATE.currentQuestionIndex >= STATE.currentQuestions.length) {
                showResults();
            } else {
                renderQuestion();
            }
        }

        function previousQuestion() {
            if (STATE.currentQuestionIndex > 0) {
                STATE.currentQuestionIndex--;
                renderQuestion();
            }
        }

        // ============================================================================
        // TIMER
        // ============================================================================
        
        function startTimer() {
            STATE.startTime = Date.now();
            STATE.timerInterval = setInterval(() => {
                const elapsed = Date.now() - STATE.startTime;
                document.getElementById('timer').textContent = formatTime(elapsed);
            }, 100);
            document.getElementById('timerDisplay').style.display = 'block';
        }

        function stopTimer() {
            if (STATE.timerInterval) {
                clearInterval(STATE.timerInterval);
                STATE.timerInterval = null;
            }
            STATE.currentTime = Date.now();
        }

        // ============================================================================
        // RESULTS
        // ============================================================================
        
        function showResults() {
            stopTimer();
            
            // Hide timer display
            const timerDisplay = document.getElementById('timerDisplay');
            if (timerDisplay) {
                timerDisplay.style.display = 'none';
            }
            
            const percentage = Math.round((STATE.score / STATE.currentQuestions.length) * 100);
            
            document.getElementById('scoreText').textContent = `${percentage}%`;
            document.getElementById('resultMessage').textContent = `${STATE.playerName || 'Spieler/in'}: ${getResultMessage(percentage)}`;
            document.getElementById('resultDetails').textContent = `Du hast ${STATE.score} von ${STATE.currentQuestions.length} Fragen richtig beantwortet.`;
            
            document.getElementById('statCorrect').textContent = STATE.correctCount;
            document.getElementById('statWrong').textContent = STATE.wrongCount;
            document.getElementById('statXP').textContent = STATE.xp;
            document.getElementById('statLevel').textContent = STATE.level;
            document.getElementById('statLifetimeXP').textContent = STATE.lifetimeXP.toLocaleString();
            // Show time if speedrun active
            const timeCard = document.getElementById('statTimeCard');
            if (STATE.activeModifiers.includes('speedrun')) {
                const elapsed = (STATE.currentTime - STATE.startTime);
                const formatted = formatTime(elapsed);
                const statTime = document.getElementById('statTime');
                if (statTime) statTime.textContent = formatted;
                if (timeCard) timeCard.style.display = 'block';
            } else if (timeCard) {
                timeCard.style.display = 'none';
            }
            
            // Update leaderboard
            updateLeaderboard();
            
            // WhatsApp share
            let shareText = `Ich habe ${percentage}% im Web-Quiz erreicht! üéâ ${STATE.score}/${STATE.currentQuestions.length} Fragen richtig.`;
            if (STATE.activeModifiers.includes('speedrun')) {
                const elapsed = (STATE.currentTime - STATE.startTime);
                shareText += ` Zeit: ${formatTime(elapsed)}`;
            }
            document.getElementById('whatsappShareBtn').href = `https://wa.me/?text=${encodeURIComponent(shareText)}`;
            
            showScreen('resultScreen');
            displayLeaderboard();
        }

        function getResultMessage(percentage) {
            if (percentage >= 90) return 'üéâ Hervorragend!';
            if (percentage >= 75) return 'üëç Sehr gut!';
            if (percentage >= 60) return '‚úì Gut gemacht!';
            if (percentage >= 50) return 'üìö Weiter √ºben!';
            return 'üí™ Nicht aufgeben!';
        }

        function updateLeaderboard() {
            const level = STATE.selectedLevel;
            const isSpeedrun = STATE.activeModifiers.includes('speedrun');
            const time = isSpeedrun ? (STATE.currentTime - STATE.startTime) : null;
            
            const entry = {
                name: STATE.playerName || 'Spieler/in',
                score: STATE.score,
                percentage: Math.round((STATE.score / STATE.currentQuestions.length) * 100),
                difficulty: STATE.selectedDifficulty,
                xp: STATE.xp,
                level: STATE.level,
                gameLevel: STATE.selectedLevel,
                questionCount: STATE.currentQuestions.length,
                timestamp: Date.now()
            };
            
            if (isSpeedrun && time) {
                entry.time = time;
            }
            
            STATE.leaderboard[level].push(entry);
            STATE.leaderboard[level].sort((a, b) => {
                if (a.time != null && b.time != null) {
                    return a.time - b.time;
                }
                return b.score - a.score;
            });
            STATE.leaderboard[level] = STATE.leaderboard[level].slice(0, 20);
            
            saveLeaderboard();
        }

        function displayLeaderboard() {
            const mode = document.querySelector('#resultScreen .tab-btn.active')?.dataset.mode || 'normal';
            renderLeaderboardTo('leaderboardContent', mode, 'Noch keine Eintr√§ge vorhanden.');
        }

        function displayStartLeaderboard() {
            const mode = document.querySelector('.start-tab-btn.active')?.dataset.mode || 'normal';
            renderLeaderboardTo('startLeaderboardContent', mode, 'Noch keine Eintr√§ge vorhanden.<br>Spiele eine Runde ‚Äì mit oder ohne Timer.');
        }

        // ============================================================================
        // QUIZ START
        // ============================================================================
        
        async function startQuiz() {
            if (!STATE.questionsLoaded) {
                alert('Fragen werden noch geladen. Bitte warte einen Moment.');
                return;
            }
            
            // Get player name
            const nameInput = document.getElementById('playerName');
            STATE.playerName = (nameInput?.value || 'Spieler/in').trim();
            
            // Save name if checkbox is checked
            const saveCheckbox = document.getElementById('saveNameCheckbox');
            if (saveCheckbox?.checked && STATE.playerName) {
                savePlayerName(STATE.playerName);
            }
            
            // Select questions
            STATE.currentQuestions = selectQuestions(
                STATE.selectedLevel,
                STATE.selectedDifficulty,
                STATE.activeModifiers,
                15
            );
            
            if (STATE.currentQuestions.length === 0) {
                alert('Keine Fragen f√ºr diese Auswahl verf√ºgbar. Versuche andere Einstellungen.');
                return;
            }
            
            // Reset quiz state
            STATE.currentQuestionIndex = 0;
            STATE.userAnswers = [];
            STATE.score = 0;
            STATE.correctCount = 0;
            STATE.wrongCount = 0;
            
            // Start timer if speedrun
            if (STATE.activeModifiers.includes('speedrun')) {
                startTimer();
            }
            
            // Show quiz
            showScreen('questionsContainer');
            renderQuestion();
        }

        function restartQuiz() {
            showScreen('startScreen');
            displayStartLeaderboard();
        }

        // ============================================================================
        // INITIALIZATION
        // ============================================================================
        
        async function init() {
            console.log('üöÄ Initializing quiz app...');
            
            // Adjust mobile placeholder
            adjustNamePlaceholder();
            window.addEventListener('resize', adjustNamePlaceholder);
            
            // Load saved data
            loadLeaderboard();
            const savedName = loadPlayerName();
            if (savedName) {
                const nameInput = document.getElementById('playerName');
                if (nameInput) nameInput.value = savedName;
                STATE.playerName = savedName;
            }
            loadProgress();
            updateXPDisplay();
            displayStartLeaderboard();

            // Ensure progress bar is hidden on the start screen initially
            const progress = document.querySelector('.progress-container');
            if (progress) progress.style.display = 'none';
            
            // Setup event listeners
            setupStartScreenListeners();
            setupLevelUpListener();
            setupResultListeners();
            
            // Load questions
            const startBtn = document.getElementById('startBtn');
            const success = await loadQuestions();
            
            if (success && startBtn) {
                startBtn.disabled = false;
                startBtn.textContent = 'Quiz starten';
            } else if (startBtn) {
                startBtn.textContent = 'Fehler beim Laden';
            }
            
            console.log('‚úÖ Initialization complete');
        }

        function setupStartScreenListeners() {
            // Level cards
            document.querySelectorAll('.level-card').forEach(card => {
                card.addEventListener('click', function() {
                    document.querySelectorAll('.level-card').forEach(c => c.classList.remove('selected'));
                    this.classList.add('selected');
                    STATE.selectedLevel = this.dataset.level;
                });
            });
            
            // Modifiers
            document.querySelectorAll('.modifier-btn').forEach(btn => {
                btn.addEventListener('click', function() {
                    const mod = this.dataset.modifier;
                    
                    if (mod === 'normal') {
                        STATE.activeModifiers = ['normal'];
                        document.querySelectorAll('.modifier-btn').forEach(b => b.classList.remove('active'));
                        this.classList.add('active');
                    } else {
                        const normalIdx = STATE.activeModifiers.indexOf('normal');
                        if (normalIdx > -1) {
                            STATE.activeModifiers.splice(normalIdx, 1);
                            document.querySelector('.modifier-btn[data-modifier="normal"]')?.classList.remove('active');
                        }
                        
                        const idx = STATE.activeModifiers.indexOf(mod);
                        if (idx > -1) {
                            STATE.activeModifiers.splice(idx, 1);
                            this.classList.remove('active');
                        } else {
                            STATE.activeModifiers.push(mod);
                            this.classList.add('active');
                        }
                        
                        if (STATE.activeModifiers.length === 0) {
                            STATE.activeModifiers = ['normal'];
                            document.querySelector('.modifier-btn[data-modifier="normal"]')?.classList.add('active');
                        }
                    }
                });
            });
            
            // Difficulty
            document.querySelectorAll('.difficulty-btn').forEach(btn => {
                btn.addEventListener('click', function() {
                    document.querySelectorAll('.difficulty-btn').forEach(b => b.classList.remove('selected'));
                    this.classList.add('selected');
                    STATE.selectedDifficulty = this.dataset.difficulty;
                });
            });
            
            // Start button
            const startBtn = document.getElementById('startBtn');
            if (startBtn) {
                startBtn.addEventListener('click', startQuiz);
            }
            
            // Name input
            const nameInput = document.getElementById('playerName');
            if (nameInput) {
                nameInput.addEventListener('input', function() {
                    STATE.playerName = this.value.trim();
                    // Reload progress for this name so XP/Level/Title reflect correct profile immediately
                    loadProgress();
                    updateXPDisplay();
                    updateNameUI();
                });
            }
            
            // Save name checkbox
            const saveCheckbox = document.getElementById('saveNameCheckbox');
            if (saveCheckbox) {
                saveCheckbox.addEventListener('change', function() {
                    if (this.checked && STATE.playerName) {
                        savePlayerName(STATE.playerName);
                    } else {
                        localStorage.removeItem('playerName');
                    }
                    updateNameUI();
                });
            }
            
            // Reset progress
            const resetBtn = document.getElementById('resetProgressBtn');
            if (resetBtn) {
                resetBtn.addEventListener('click', function() {
                    if (confirm('Fortschritt zur√ºcksetzen?\n\nHinweis: Dein Gesamt-XP (Lifetime Stats) bleibt erhalten.')) {
                        // Keep lifetimeXP, only reset current progress
                        const currentLifetimeXP = STATE.lifetimeXP;
                        STATE.xp = 0;
                        STATE.level = 1;
                        STATE.lifetimeXP = currentLifetimeXP;  // Preserve lifetime stats
                        updateXPDisplay();
                        saveProgress();  // Save the reset state
                        localStorage.removeItem('playerName');
                        const nameInput = document.getElementById('playerName');
                        if (nameInput) nameInput.value = '';
                        STATE.playerName = '';
                        updateNameUI();
                        alert('Fortschritt zur√ºckgesetzt!\n\nGesamt-XP beibehalten: ' + currentLifetimeXP + ' XP');
                    }
                });
            }
            
            // Clear leaderboard
            const clearBtn = document.getElementById('clearAllLeaderboardBtn');
            if (clearBtn) {
                clearBtn.addEventListener('click', function() {
                    if (confirm('Bestenliste l√∂schen?')) {
                        STATE.leaderboard = {
                            uebung: [],
                            'vorlesung-offiziell': [],
                            gemischt: [],
                            offiziell: []
                        };
                        saveLeaderboard();
                        displayStartLeaderboard();
                        displayLeaderboard();
                    }
                });
            }
            
            // Leaderboard tabs (start screen)
            document.querySelectorAll('.start-tab-btn').forEach(btn => {
                btn.addEventListener('click', function() {
                    document.querySelectorAll('.start-tab-btn').forEach(b => b.classList.remove('active'));
                    this.classList.add('active');
                    displayStartLeaderboard();
                });
            });
        }

        function setupLevelUpListener() {
            const continueBtn = document.getElementById('levelUpContinue');
            const overlay = document.getElementById('levelUpOverlay');
            
            if (continueBtn && overlay) {
                // Remove any existing listeners to avoid duplicates
                const newBtn = continueBtn.cloneNode(true);
                continueBtn.parentNode.replaceChild(newBtn, continueBtn);
                
                // Add click listener with event delegation
                newBtn.addEventListener('click', function(e) {
                    e.preventDefault();
                    e.stopPropagation();
                    overlay.classList.remove('show');
                });
                
                // Also allow closing with overlay click (outside content)
                overlay.addEventListener('click', function(e) {
                    if (e.target === overlay) {
                        overlay.classList.remove('show');
                    }
                });
            }
        }

        function setupResultListeners() {
            const restartBtn = document.getElementById('restartBtn');
            if (restartBtn) {
                restartBtn.addEventListener('click', restartQuiz);
            }
            
            // Result leaderboard tabs
            document.querySelectorAll('#resultScreen .tab-btn').forEach(btn => {
                btn.addEventListener('click', function() {
                    document.querySelectorAll('#resultScreen .tab-btn').forEach(b => b.classList.remove('active'));
                    this.classList.add('active');
                    displayLeaderboard();
                });
            });
        }

        function updateNameUI() {
            const disclaimer = document.getElementById('nameDisclaimer');
            const resetContainer = document.getElementById('resetProgressContainer');
            const savedName = loadPlayerName();
            
            if (savedName) {
                if (disclaimer) disclaimer.style.display = 'none';
                if (resetContainer) resetContainer.style.display = 'block';
            } else {
                if (disclaimer) disclaimer.style.display = STATE.playerName ? 'block' : 'none';
                if (resetContainer) resetContainer.style.display = 'none';
            }
        }

        function adjustNamePlaceholder() {
            const nameInput = document.getElementById('playerName');
            if (nameInput && window.innerWidth < 600) {
                nameInput.placeholder = 'z.B. Luca';
            } else if (nameInput) {
                nameInput.placeholder = 'z.B. Luca, Marie';
            }
        }

        // Start the app
        document.addEventListener('DOMContentLoaded', init);
    </script>
</body>
</html>
