[
  {
    "difficulty": 1,
    "type": "multiple",
    "question": "Eine Spring-Boot-Anwendung kann eigenständig und ohne externe Laufzeitabhängigkeiten ausgeführt werden",
    "options": [
      "Wahr",
      "Falsch"
    ],
    "correct": 0,
    "explanation": "Spring Boot-Anwendungen sind als Fat JARs/Executable JARs lauffähig und benötigen keine externen Laufzeitabhängigkeiten.",
    "xp": 10,
    "tags": [
      "uebung",
      "neue-vorlesung",
      "offiziell"
    ]
  },
  {
    "difficulty": 1,
    "type": "multiple",
    "question": "Im Beispiel wird bei einer fehlenden URL-Parameterangabe (MissingServletRequestParameterException) automatisch support.html als View zurückgegeben.",
    "options": ["Falsch", "Wahr"],
    "correct": 1,
    "explanation": "Beispiel-Handler gibt bei MissingServletRequestParameterException die View support.html zurück (ModelAndView mit View-Namen).",
    "xp": 10,
    "tags": ["offiziell", "woche4"]
  },
  {
    "difficulty": 1,
    "type": "multiple",
    "question": "Der Controller leitet Model-Daten an die View weiter, um eine dynamische Anzeige zu generieren.",
    "options": ["Falsch", "Wahr"],
    "correct": 1,
    "explanation": "Controller füllt Model → View rendert dynamisch daraus.",
    "xp": 10,
    "tags": ["offiziell", "woche4"]
  },
  {
    "difficulty": 1,
    "type": "multiple",
    "question": "Fehlende Parameter in HTTP-Anfragen führen immer zu einem Server-Absturz.",
    "options": ["Falsch", "Wahr"],
    "correct": 0,
    "explanation": "Fehlende Pflicht-Parameter erzeugen Exceptions (z.B. MissingServletRequestParameterException), kein Absturz – Handler möglich.",
    "xp": 10,
    "tags": ["offiziell", "woche4"]
  },
  {
    "difficulty": 1,
    "type": "multiple",
    "question": "Was ist das Hauptziel des MVC-Entwurfsmusters?",
    "options": [
      "Die Beschleunigung der Web-Entwicklung",
      "Die Integration von Datenbanken",
      "Die Trennung von Präsentation, Logik und Daten",
      "Die Verbesserung der Sicherheit"
    ],
    "correct": 2,
    "explanation": "MVC sorgt für klare Trennung: Model (Daten/Logik), View (Darstellung), Controller (Steuerung).",
    "xp": 15,
    "tags": ["offiziell", "woche4"]
  },
  {
    "difficulty": 1,
    "type": "multiple",
    "question": "Das DispatcherServlet leitet Anfragen an den passenden Controller weiter.",
    "options": ["Falsch", "Wahr"],
    "correct": 1,
    "explanation": "DispatcherServlet = Front Controller: empfängt Request, delegiert an passenden Handler.",
    "xp": 10,
    "tags": ["offiziell", "woche4"]
  },
  {
    "difficulty": 1,
    "type": "multiple",
    "question": "Thymeleaf benötigt zwingend die Annotation @ThymeleafEnabled.",
    "options": ["Falsch", "Wahr"],
    "correct": 0,
    "explanation": "Es existiert keine Annotation @ThymeleafEnabled; Spring Boot autokonfiguriert Thymeleaf über Starter.",
    "xp": 10,
    "tags": ["offiziell", "woche4"]
  },
  {
    "difficulty": 1,
    "type": "multiple",
    "question": "Der Query String beginnt immer nach dem ersten Gleichheitszeichen in der URL.",
    "options": ["Falsch", "Wahr"],
    "correct": 0,
    "explanation": "Der Query-String beginnt nach '?' und enthält key=value Paare; '=' trennt Schlüssel und Wert.",
    "xp": 10,
    "tags": ["offiziell", "woche4"]
  },
  {
    "difficulty": 1,
    "type": "multiple",
    "question": "Eine MissingServletRequestParameterException tritt nur dann auf, wenn alle URL-Parameter fehlen.",
    "options": ["Falsch", "Wahr"],
    "correct": 0,
    "explanation": "Sie tritt auf, wenn EIN erforderlicher Parameter fehlt – nicht alle müssen fehlen.",
    "xp": 10,
    "tags": ["offiziell", "woche4"]
  },
  {
    "difficulty": 1,
    "type": "multiple",
    "question": "Im MVC-Pattern speichert der Controller die Anwendungsdaten.",
    "options": ["Falsch", "Wahr"],
    "correct": 0,
    "explanation": "Kontroller steuert Fluss; Daten & Logik liegen im Model.",
    "xp": 10,
    "tags": ["offiziell", "woche4"]
  },
  {
    "difficulty": 1,
    "type": "multiple",
    "question": "Welcher Ordner enthält statische Ressourcen wie CSS- und JavaScript-Dateien in Spring Boot?",
    "options": [
      "/static/resources",
      "/src/main/resources/static",
      "/resources/views",
      "/src/main/resources/templates"
    ],
    "correct": 1,
    "explanation": "Statische Dateien liegen unter src/main/resources/static (nicht templates).",
    "xp": 10,
    "tags": ["offiziell", "woche4"]
  },
  {
    "difficulty": 1,
    "type": "multiple",
    "question": "@ControllerAdvice kann mehrere unterschiedliche Exceptions behandeln, nicht nur eine einzige.",
    "options": ["Falsch", "Wahr"],
    "correct": 1,
    "explanation": "@ControllerAdvice + mehrere @ExceptionHandler Methoden für verschiedene Exception-Typen.",
    "xp": 10,
    "tags": ["offiziell", "woche4"]
  },
  {
    "difficulty": 2,
    "type": "multiple",
    "question": "Was ist die Funktion der Annotation @Autowired?",
    "options": [
      "Sie gibt an, dass eine Methode als Spring Bean registriert werden soll",
      "Sie markiert die Main-Methode des Programms",
      "Sie erstellt eine neue Bean im Spring Container",
      "Sie injiziert eine Bean in eine andere Klasse und stellt diese zur Verfügung"
    ],
    "correct": 3,
    "explanation": "@Autowired injiziert eine Bean in eine andere Klasse und stellt sie dort zur Verfügung.",
    "xp": 20,
    "tags": [
      "uebung",
      "neue-vorlesung",
      "offiziell"
    ]
  },
  {
    "difficulty": 2,
    "type": "multiple",
    "question": "In welcher Datei werden die Abhängigkeiten bei einem Spring Boot-Projekt verwaltet (Gradle)?",
    "options": [
      "pom.xml",
      "settings.gradle",
      "build.gradle",
      "application.properties"
    ],
    "correct": 2,
    "explanation": "Bei Gradle werden Dependencies in der build.gradle gepflegt. Die pom.xml ist für Maven-Projekte.",
    "xp": 15,
    "tags": [
      "uebung",
      "neue-vorlesung",
      "offiziell"
    ]
  },
  {
    "difficulty": 1,
    "type": "multiple",
    "question": "Welche Log-Level sind standardmäßig in Spring Boot aktiviert?",
    "options": [
      "TRACE, WARN, DEBUG",
      "DEBUG, INFO, ERROR",
      "ERROR, WARN, INFO",
      "ERROR, TRACE, INFO"
    ],
    "correct": 2,
    "explanation": "Standardmäßig sind ERROR, WARN und INFO in Spring Boot aktiviert. DEBUG und TRACE müssen explizit aktiviert werden.",
    "xp": 10,
    "tags": [
      "uebung",
      "neue-vorlesung",
      "offiziell"
    ]
  },
  {
    "difficulty": 1,
    "type": "multiple",
    "question": "Was macht die Methode setMessage() in der Klasse MessageService?",
    "options": [
      "Sie gibt den Wert der Variablen message zurück",
      "Sie initialisiert die Bean message",
      "Sie setzt den Wert der Variablen message",
      "Sie speichert eine Nachricht in einer Datenbank"
    ],
    "correct": 2,
    "explanation": "Die Methode setMessage() setzt den Wert der Variablen message in der Klasse MessageService.",
    "xp": 10,
    "tags": [
      "uebung",
      "neue-vorlesung",
      "offiziell"
    ]
  },
  {
    "difficulty": 3,
    "type": "multiple",
    "question": "Die Methode assertThat() wird nicht von JUnit nativ bereitgestellt.",
    "options": [
      "Wahr",
      "Falsch"
    ],
    "correct": 0,
    "explanation": "assertThat() stammt aus Bibliotheken wie AssertJ oder Hamcrest, nicht aus JUnit selbst.",
    "xp": 30,
    "tags": [
      "uebung",
      "neue-vorlesung",
      "offiziell"
    ]
  },
  {
    "difficulty": 4,
    "type": "multiple",
    "question": "Mit Maven können Abhängigkeiten eines Projekts automatisch aufgelöst werden.",
    "options": [
      "Wahr",
      "Falsch"
    ],
    "correct": 0,
    "explanation": "Maven löst Abhängigkeiten automatisch über die pom.xml auf und lädt sie aus Repositories herunter.",
    "xp": 40,
    "tags": [
      "uebung",
      "neue-vorlesung",
      "offiziell"
    ]
  },
  {
    "difficulty": 1,
    "type": "multiple",
    "question": "Wohin schreibt Spring Boot Logs standardmäßig ohne zusätzliche Konfiguration?",
    "options": [
      "In die Konsole (Standard Output)",
      "In eine Datei namens 'application.log'",
      "In eine Datenbank",
      "In das Windows Event Log"
    ],
    "correct": 0,
    "explanation": "Standardmäßig schreibt Spring Boot alle Logs in die Konsole (Standard Output). Für andere Ziele ist zusätzliche Konfiguration nötig.",
    "xp": 10,
    "tags": [
      "uebung"
    ]
  },
  {
    "difficulty": 1,
    "type": "checkbox",
    "question": "Welche Log-Level sind in Spring Boot standardmäßig verfügbar? (Mehrfachauswahl)",
    "options": [
      "ERROR",
      "WARN",
      "INFO",
      "DEBUG",
      "TRACE"
    ],
    "correct": [
      0,
      1,
      2,
      3,
      4
    ],
    "explanation": "Spring Boot unterstützt die Standard-Log-Level: ERROR (kritisch), WARN (Warnungen), INFO (Information), DEBUG (Entwicklung) und TRACE (detailliert).",
    "xp": 15,
    "tags": [
      "uebung"
    ]
  },
  {
    "difficulty": 1,
    "type": "multiple",
    "question": "Was ist das grundlegende Schema für User Stories?",
    "options": [
      "Als <Rolle> möchte ich <Ziel>, damit <Nutzen>",
      "Wenn <Bedingung> dann <Aktion>",
      "Gegeben <Zustand> wenn <Ereignis> dann <Ergebnis>",
      "Falls <Problem> soll <Lösung> implementiert werden"
    ],
    "correct": 0,
    "explanation": "User Stories folgen dem Schema: 'Als <Rolle> möchte ich <Ziel>, damit <Nutzen>'. Dies macht Anforderungen verständlich und nutzerorientiert.",
    "xp": 10,
    "tags": [
      "uebung"
    ]
  },
  {
    "difficulty": 2,
    "type": "matching",
    "question": "Ordne die Logging-Properties ihren Effekten zu:",
    "pairs": [
      {
        "left": "logging.file",
        "right": "Definiert eine spezifische Log-Datei"
      },
      {
        "left": "logging.path",
        "right": "Setzt das Verzeichnis für Log-Dateien"
      },
      {
        "left": "logging.level.*",
        "right": "Konfiguriert Log-Level für Packages"
      },
      {
        "left": "logging.pattern.console",
        "right": "Bestimmt das Format der Konsolenausgabe"
      }
    ],
    "explanation": "Die verschiedenen Logging-Properties steuern unterschiedliche Aspekte: Dateien, Pfade, Level und Ausgabeformat.",
    "xp": 25,
    "tags": [
      "uebung"
    ]
  },
  {
    "difficulty": 2,
    "type": "multiple",
    "question": "Was bewirkt logging.level.edu.fra.uas=debug in der Konfiguration?",
    "options": [
      "Setzt DEBUG-Level für das spezifische Package und Unterpackages",
      "Aktiviert Debugging für die gesamte Anwendung",
      "Loggt nur Fehler aus dem edu.fra.uas Package",
      "Deaktiviert Logging für andere Packages"
    ],
    "correct": 0,
    "explanation": "Diese Einstellung setzt das Log-Level DEBUG für das Package edu.fra.uas und alle seine Unterpackages. Andere Packages bleiben unberührt.",
    "xp": 20,
    "tags": [
      "uebung"
    ]
  },
  {
    "difficulty": 3,
    "type": "checkbox",
    "question": "Welche Vorteile bietet strukturiertes Logging (SLF4J/Logback) gegenüber System.out.println in Spring Boot? (Mehrfachauswahl)",
    "options": [
      "Konfigurierbare Log-Level und Filter",
      "Performance durch asynchrones Logging",
      "Standardisierte Formatierung",
      "Integration mit Spring Boot Actuator",
      "Automatische Dateirotation"
    ],
    "correct": [
      0,
      1,
      2,
      3,
      4
    ],
    "explanation": "Strukturiertes Logging bietet viele Vorteile: konfigurierbare Level, bessere Performance, einheitliche Formate, Monitoring-Integration und Dateiverwaltung.",
    "xp": 30,
    "tags": [
      "uebung"
    ]
  },
  {
    "difficulty": 3,
    "type": "multiple",
    "question": "Was passiert, wenn @Autowired an einer Feldstelle entfernt wird?",
    "options": [
      "Das Feld bleibt null und führt zu NullPointerException bei Verwendung",
      "Spring erstellt automatisch eine neue Instanz",
      "Die Anwendung startet nicht",
      "Es wird eine Warnung ausgegeben"
    ],
    "correct": 0,
    "explanation": "Ohne @Autowired erfolgt keine Dependency Injection. Das Feld bleibt null, was bei Verwendung zu einer NullPointerException führt.",
    "xp": 30,
    "tags": [
      "uebung"
    ]
  },
  {
    "difficulty": 4,
    "type": "matching",
    "question": "Ordne die Test-Konzepte ihren Haupteigenschaften zu:",
    "pairs": [
      {
        "left": "@SpringBootTest",
        "right": "Lädt den vollständigen Application Context"
      },
      {
        "left": "AssertJ",
        "right": "Bietet fluent assertions und bessere Fehlermeldungen"
      },
      {
        "left": "Slice Tests",
        "right": "Testet nur spezifische Schichten der Anwendung"
      },
      {
        "left": "Unit Tests",
        "right": "Testet isolierte Komponenten ohne Spring Context"
      }
    ],
    "explanation": "@SpringBootTest ist für Integrationstests mit vollem Context, AssertJ verbessert die Testlesbarkeit, Slice Tests fokussieren einzelne Schichten, Unit Tests sind am schnellsten.",
    "xp": 40,
    "tags": [
      "uebung"
    ]
  },
  {
    "difficulty": 4,
    "type": "multiple",
    "question": "Welche Funktion hat der <parent>-Eintrag in der pom.xml bei Spring Boot?",
    "options": [
      "Definiert Versionen, Dependencies und Plugins durch Vererbung",
      "Ist nur für Multi-Modul-Projekte erforderlich",
      "Dient ausschließlich der Dokumentation",
      "Wird nur für Test-Konfigurationen verwendet"
    ],
    "correct": 0,
    "explanation": "Der <parent>-Eintrag ermöglicht die Vererbung von Versionen, Dependencies und Plugin-Konfigurationen vom Spring Boot Parent POM, was die Projektkonfiguration vereinfacht.",
    "xp": 40,
    "tags": [
      "uebung"
    ]
  },
  {
    "difficulty": 4,
    "type": "checkbox",
    "question": "Was sind die Besonderheiten eines CommandLineRunner als @Bean? (Mehrfachauswahl)",
    "options": [
      "Wird nach Kontext-Initialisierung ausgeführt",
      "Kann mehrfach im Projekt definiert werden",
      "Hat Zugriff auf andere Beans",
      "Ermöglicht Start-up Logik",
      "Unterstützt Ordering mit @Order"
    ],
    "correct": [
      0,
      1,
      2,
      3,
      4
    ],
    "explanation": "CommandLineRunner als @Bean: läuft nach Kontext-Start, mehrfache Definition möglich, hat Bean-Zugriff, ideal für Start-up Logik, unterstützt Reihenfolge via @Order.",
    "xp": 45,
    "tags": [
      "uebung"
    ]
  },
  {
    "difficulty": 1,
    "type": "multiple",
    "question": "Was ist eine Bean im Spring-Container?",
    "options": [
      "Ein Java-Objekt, das von Spring verwaltet wird",
      "Eine Datenbankverbindung",
      "Ein UI-Element",
      "Eine Konfigurationsdatei"
    ],
    "correct": 0,
    "explanation": "Eine Bean ist ein Java-Objekt, das vom Spring Container verwaltet wird - inklusive Erstellung, Konfiguration und Lebenszyklus-Management.",
    "xp": 10,
    "tags": [
      "uebung"
    ]
  },
  {
    "difficulty": 1,
    "type": "multiple",
    "question": "Welches Log-Level zeigt die wichtigsten Fehler an?",
    "options": [
      "DEBUG",
      "INFO",
      "ERROR",
      "TRACE"
    ],
    "correct": 2,
    "explanation": "ERROR ist das Log-Level für die kritischsten Fehlermeldungen. Es zeigt schwerwiegende Probleme an, die sofortige Aufmerksamkeit erfordern.",
    "xp": 10,
    "tags": [
      "uebung"
    ]
  },
  {
    "difficulty": 1,
    "type": "multiple",
    "question": "Was ist ein Fork in GitHub?",
    "options": [
      "Eine Kopie eines Repositories unter deinem eigenen Account",
      "Ein Branch in einem Repository",
      "Ein Pull Request",
      "Ein Commit in der Historie"
    ],
    "correct": 0,
    "explanation": "Ein Fork ist eine persönliche Kopie eines fremden Repositories unter deinem GitHub-Account. Dies ermöglicht es dir, Änderungen vorzunehmen, ohne das Original zu beeinflussen.",
    "xp": 10,
    "tags": [
      "uebung",
      "neue-vorlesung",
      "offiziell"
    ]
  },
  {
    "difficulty": 2,
    "type": "matching",
    "question": "Ordne die Log-Level ihrer typischen Verwendung zu:",
    "pairs": [
      {
        "left": "ERROR",
        "right": "Kritische Fehler, die sofortige Aktion erfordern"
      },
      {
        "left": "WARN",
        "right": "Potenziell schädliche Situationen"
      },
      {
        "left": "INFO",
        "right": "Wichtige Geschäftsereignisse"
      },
      {
        "left": "DEBUG",
        "right": "Detaillierte Entwicklerinformationen"
      }
    ],
    "explanation": "Die Log-Level haben unterschiedliche Prioritäten und Verwendungszwecke: ERROR für kritische Fehler, WARN für Warnungen, INFO für wichtige Events, DEBUG für Entwicklerdetails.",
    "xp": 25,
    "tags": [
      "uebung"
    ]
  },
  {
    "difficulty": 2,
    "type": "checkbox",
    "question": "Welche Vorteile bietet strukturiertes Logging gegenüber System.out.println? (Mehrfachauswahl)",
    "options": [
      "Konfigurierbare Log-Level",
      "Bessere Filterbarkeit",
      "Mehrere Ausgabekanäle möglich",
      "Formatierte Zeitstempel",
      "Schnellere Ausführung"
    ],
    "correct": [
      0,
      1,
      2,
      3
    ],
    "explanation": "Strukturiertes Logging bietet viele Vorteile: konfigurierbare Level, Filterbarkeit, multiple Ausgabekanäle und automatische Zeitstempel. Die Ausführungsgeschwindigkeit ist nicht primär relevant.",
    "xp": 20,
    "tags": [
      "uebung"
    ]
  },
  {
    "difficulty": 2,
    "type": "multiple",
    "question": "Was ist die Hauptaufgabe des CommandLineRunner in Spring Boot?",
    "options": [
      "Datenbankverbindungen aufbauen",
      "Code beim Anwendungsstart ausführen",
      "REST-Endpunkte definieren",
      "Logging konfigurieren"
    ],
    "correct": 1,
    "explanation": "CommandLineRunner ist ein Interface, dessen run()-Methode nach der Initialisierung der Spring Boot App ausgeführt wird. Es eignet sich für Initialisierungscode beim Start.",
    "xp": 20,
    "tags": [
      "uebung"
    ]
  },
  {
    "difficulty": 3,
    "type": "multiple",
    "question": "Was bedeutet 'Inversion of Control' im Spring-Kontext?",
    "options": [
      "Die Umkehrung der Programmflusssteuerung",
      "Das manuelle Erstellen von Objekten",
      "Die direkte Objektreferenzierung",
      "Die Verwendung von statischen Methoden"
    ],
    "correct": 0,
    "explanation": "Inversion of Control bedeutet, dass die Kontrolle über Objekterstellung und -verwaltung an den Spring Container übertragen wird, statt sie selbst zu implementieren.",
    "xp": 30,
    "tags": [
      "uebung"
    ]
  },
  {
    "difficulty": 3,
    "type": "checkbox",
    "question": "Welche Aussagen über Konstruktor-Injektion sind korrekt? (Mehrfachauswahl)",
    "options": [
      "Garantiert vollständige Initialisierung",
      "Unterstützt Immutability",
      "Macht Abhängigkeiten explizit",
      "Ist flexibler als Setter-Injektion",
      "Erfordert weniger Code als Feld-Injektion"
    ],
    "correct": [
      0,
      1,
      2
    ],
    "explanation": "Konstruktor-Injektion wird bevorzugt, weil sie vollständige Initialisierung garantiert, Immutability ermöglicht und Abhängigkeiten explizit macht. Sie ist nicht flexibler und erfordert mehr Code.",
    "xp": 30,
    "tags": [
      "uebung"
    ]
  },
  {
    "difficulty": 3,
    "type": "matching",
    "question": "Ordne die Spring-Annotationen ihrer Hauptfunktion zu:",
    "pairs": [
      {
        "left": "@SpringBootApplication",
        "right": "Kombiniert mehrere Basis-Annotationen"
      },
      {
        "left": "@Component",
        "right": "Markiert Klasse als Spring-verwaltete Komponente"
      },
      {
        "left": "@Bean",
        "right": "Definiert Methode zur Bean-Erstellung"
      },
      {
        "left": "@Autowired",
        "right": "Injiziert Abhängigkeiten"
      }
    ],
    "explanation": "Die Annotationen haben unterschiedliche Zwecke: @SpringBootApplication für App-Konfiguration, @Component für Komponenten-Scanning, @Bean für explizite Bean-Definition, @Autowired für Dependency Injection.",
    "xp": 35,
    "tags": [
      "uebung"
    ]
  },
  {
    "difficulty": 4,
    "type": "checkbox",
    "question": "Welche Konzepte sind Teil der Spring Boot Auto-Konfiguration? (Mehrfachauswahl)",
    "options": [
      "Konvention vor Konfiguration",
      "Bedingte Bean-Registrierung",
      "Externe Konfigurationsdateien",
      "Starter Dependencies",
      "Metriken und Health-Checks"
    ],
    "correct": [
      0,
      1,
      3
    ],
    "explanation": "Spring Boot's Auto-Konfiguration basiert auf mehreren Konzepten: Konventionen, bedingter Bean-Registrierung und Starter Dependencies. Externe Konfigurationsdateien und Metriken sind separate Features.",
    "xp": 40,
    "tags": [
      "uebung"
    ]
  },
  {
    "difficulty": 4,
    "type": "matching",
    "question": "Ordne die Maven-Konzepte ihrer Bedeutung zu:",
    "pairs": [
      {
        "left": "groupId",
        "right": "Organisationsweiter, eindeutiger Identifier"
      },
      {
        "left": "artifactId",
        "right": "Name des Projekts/der Bibliothek"
      },
      {
        "left": "version",
        "right": "Spezifische Release-Kennung"
      },
      {
        "left": "parent",
        "right": "Vererbungshierarchie und gemeinsame Konfiguration"
      }
    ],
    "explanation": "Maven POM-Elemente haben spezifische Rollen: groupId für Organisation, artifactId für Projektname, version für Release-Identifikation, parent für Vererbung.",
    "xp": 40,
    "tags": [
      "uebung"
    ]
  },
  {
    "difficulty": 4,
    "type": "checkbox",
    "question": "Welche Aspekte unterscheiden Integration-Tests von Unit-Tests in Spring Boot? (Mehrfachauswahl)",
    "options": [
      "Vollständiger Spring Kontext wird geladen",
      "Testen mehrerer Komponenten zusammen",
      "Verwendung von @SpringBootTest",
      "Längere Ausführungszeit",
      "Externe Ressourcen können eingebunden sein"
    ],
    "correct": [
      0,
      1,
      2,
      3,
      4
    ],
    "explanation": "Integration-Tests unterscheiden sich durch: Laden des Spring Kontexts, Testing mehrerer Komponenten, @SpringBootTest Annotation, längere Laufzeit und mögliche externe Ressourcen.",
    "xp": 45,
    "tags": [
      "uebung"
    ]
  },
  {
    "difficulty": 1,
    "type": "multiple",
    "question": "Was ist GitHub?",
    "options": [
      "Ein Texteditor",
      "Eine Codehosting-Plattform für Versionskontrolle",
      "Eine Programmiersprache",
      "Ein Betriebssystem"
    ],
    "correct": 1,
    "explanation": "GitHub ist eine Codehosting-Plattform für die Versionskontrolle und Zusammenarbeit in Projekten.",
    "xp": 10,
    "tags": [
      "uebung",
      "offiziell"
    ]
  },
  {
    "difficulty": 2,
    "type": "multiple",
    "question": "Was ist eine Bean in Spring?",
    "options": [
      "Eine JavaScript-Bibliothek",
      "Eine Datenbank-Tabelle",
      "Ein verwaltetes Java-Objekt innerhalb des Spring Containers",
      "Ein Konfigurationsfile"
    ],
    "correct": 2,
    "explanation": "Eine Bean ist ein verwaltetes Java-Objekt innerhalb des Spring Containers. Die Bean wird erstellt, überwacht und gelöscht.",
    "xp": 20,
    "tags": [
      "uebung"
    ]
  },
  {
    "difficulty": 2,
    "type": "matching",
    "question": "Ordne die Spring-Annotationen ihrer Funktion zu:",
    "pairs": [
      {
        "left": "@SpringBootApplication",
        "right": "Kennzeichnet die Main-Klasse"
      },
      {
        "left": "@Component",
        "right": "Macht die Klasse zu einer Bean"
      },
      {
        "left": "@Autowired",
        "right": "Injiziert ein Bean-Objekt"
      },
      {
        "left": "@Bean",
        "right": "Definiert eine Bean-Methode"
      }
    ],
    "explanation": "@SpringBootApplication markiert die Main-Klasse, @Component macht Klassen zu Beans, @Autowired injiziert Dependencies, @Bean definiert Bean-Methoden.",
    "xp": 25,
    "tags": [
      "uebung"
    ]
  },
  {
    "difficulty": 2,
    "type": "fillblank",
    "question": "In Spring Boot wird die Konfiguration in der Datei _____ im Ordner _____ gespeichert.",
    "blanks": [
      "application.properties",
      "resources"
    ],
    "explanation": "Die Datei application.properties im Ordner resources enthält die Konfiguration für Spring Boot Anwendungen.",
    "xp": 20,
    "tags": [
      "uebung"
    ]
  },
  {
    "difficulty": 2,
    "type": "sort",
    "question": "Sortiere die Log-Level von niedrigster zu höchster Priorität:",
    "items": [
      "ERROR",
      "WARN",
      "INFO",
      "DEBUG",
      "TRACE"
    ],
    "correct": [
      "TRACE",
      "DEBUG",
      "INFO",
      "WARN",
      "ERROR"
    ],
  "explanation": "Die Log-Level von niedrigster zu höchster Priorität: TRACE (am detailliertesten) → DEBUG → INFO → WARN → ERROR (kritischste Fehler).\n✅ TRACE → DEBUG → INFO → WARN → ERROR",
    "xp": 25,
    "tags": [
      "uebung"
    ]
  },
  {
    "difficulty": 2,
    "type": "multiple",
    "question": "Was ist Maven?",
    "options": [
      "Ein Web-Framework",
      "Eine Datenbank",
      "Eine Programmiersprache",
      "Ein Build-Management-Tool für Java-Projekte"
    ],
    "correct": 3,
    "explanation": "Maven ist ein Build-Management-Tool, das den Software-Erstellungszyklus verwaltet. Konfiguration erfolgt in pom.xml.",
    "xp": 20,
    "tags": [
      "uebung"
    ]
  },
  {
    "difficulty": 2,
    "type": "fillblank",
    "question": "Um den Log-Level für ein Package auf DEBUG zu setzen, verwendet man in application.properties: logging.level.<Packagename>=_____",
    "blanks": [
      "DEBUG"
    ],
    "explanation": "Mit logging.level.<packagename>=DEBUG wird der Log-Level für ein Package auf DEBUG gesetzt.",
    "xp": 20,
    "tags": [
      "uebung"
    ]
  },
  {
    "difficulty": 3,
    "type": "sort",
    "question": "Sortiere die Schichten der 3-Tier-Architektur von oben nach unten:",
    "items": [
      "Datenhaltungsschicht",
      "Anwendungslogik-Schicht",
      "Präsentationsschicht"
    ],
    "correct": [
      "Präsentationsschicht",
      "Anwendungslogik-Schicht",
      "Datenhaltungsschicht"
    ],
  "explanation": "3-Tier-Architektur von oben: Präsentationsschicht (UI) → Anwendungslogik (Business Logic) → Datenhaltung (Datenbank).\n✅ Präsentationsschicht → Anwendungslogik-Schicht → Datenhaltungsschicht",
    "xp": 30,
    "tags": [
      "uebung"
    ]
  },
  {
    "difficulty": 3,
    "type": "matching",
    "question": "Ordne die REST-Prinzipien ihrer Beschreibung zu:",
    "pairs": [
      {
        "left": "Stateless",
        "right": "Zustandslosigkeit der Anfragen"
      },
      {
        "left": "Cacheability",
        "right": "Responses können gecacht werden"
      },
      {
        "left": "Uniform Interface",
        "right": "Einheitliche Schnittstelle"
      },
      {
        "left": "HATEOAS",
        "right": "Links zu verwandten Ressourcen"
      }
    ],
    "explanation": "REST-Prinzipien: Stateless (zustandslos), Cacheability (cachebar), Uniform Interface (einheitlich), HATEOAS (Hypermedia as Engine of Application State).",
    "xp": 35,
    "tags": [
      "uebung"
    ]
  },
  {
    "difficulty": 3,
    "type": "checkbox",
    "question": "Welche HTTP-Methoden sind 'safe' (sicher)? (Mehrfachauswahl)",
    "options": [
      "POST",
      "GET",
      "PUT",
      "HEAD",
      "DELETE"
    ],
    "correct": [
      1,
      3
    ],
    "explanation": "Safe (sicher) sind nur GET und HEAD - sie ändern keine Daten auf dem Server. POST, PUT und DELETE ändern Daten.",
    "xp": 30,
    "tags": [
      "uebung"
    ]
  },
  {
    "difficulty": 3,
    "type": "fillblank",
    "question": "Die Annotation _____ kennzeichnet Test-Methoden in JUnit, während _____ die Test-Klasse für Spring Boot markiert.",
    "blanks": [
      "@Test",
      "@SpringBootTest"
    ],
    "explanation": "@Test markiert einzelne Test-Methoden, @SpringBootTest kennzeichnet die Test-Klasse für Spring Boot.",
    "xp": 30,
    "tags": [
      "uebung"
    ]
  },
  {
    "difficulty": 3,
    "type": "multiple",
    "question": "Was passiert, wenn die @Autowired Annotation entfernt wird?",
    "options": [
      "Das Programm läuft schneller",
      "Die Bean wird nicht injiziert und es gibt eine NullPointerException",
      "Die Bean wird automatisch erstellt",
      "Das Programm kompiliert nicht"
    ],
    "correct": 1,
    "explanation": "Ohne @Autowired wird das Bean-Objekt nicht injiziert und bleibt null, was zu einer NullPointerException führt, wenn darauf zugegriffen wird.",
    "xp": 30,
    "tags": [
      "uebung"
    ]
  },
  {
    "difficulty": 3,
    "type": "multiple",
    "question": "Welche Operationen unterstützt GraphQL?",
    "options": [
      "SELECT, INSERT, UPDATE, DELETE",
      "GET, POST, PUT, DELETE",
      "Query, Mutation, Subscription",
      "READ, WRITE, UPDATE"
    ],
    "correct": 2,
    "explanation": "GraphQL unterstützt: Query (Abfragen), Mutation (Änderungen), Subscription (Echtzeit-Updates).",
    "xp": 30,
    "tags": [
      "uebung"
    ]
  },
  {
    "difficulty": 4,
    "type": "matching",
    "question": "Ordne die Komponenten des MVC-Patterns ihrer Rolle zu:",
    "pairs": [
      {
        "left": "Model",
        "right": "Datenmodell und Geschäftslogik"
      },
      {
        "left": "View",
        "right": "Darstellung der Benutzeroberfläche"
      },
      {
        "left": "Controller",
        "right": "Steuerung und Vermittlung"
      },
      {
        "left": "@RequestMapping",
        "right": "Verknüpfung von URLs mit Methoden"
      }
    ],
    "explanation": "MVC: Model (Daten/Logik), View (UI), Controller (Steuerung). @RequestMapping verbindet HTTP-Requests mit Handler-Methoden.",
    "xp": 40,
    "tags": [
      "uebung"
    ]
  },
  {
    "difficulty": 4,
    "type": "sort",
    "question": "Sortiere den Maven Build-Zyklus in der richtigen Reihenfolge:",
    "items": [
      "Installation",
      "Validierung",
      "Verifizierung",
      "Kompilierung",
      "Testen",
      "Paketieren"
    ],
    "correct": [
      "Validierung",
      "Kompilierung",
      "Testen",
      "Paketieren",
      "Verifizierung",
      "Installation"
    ],
  "explanation": "Maven Build-Zyklus: Validierung → Kompilierung → Testen → Paketieren → Verifizierung → Installation (Items-Reihenfolge; Integrationstests & Verteilung sind optionale weitere Phasen).\n✅ Validierung → Kompilierung → Testen → Paketieren → Verifizierung → Installation",
    "xp": 40,
    "tags": [
      "uebung"
    ]
  },
  {
    "difficulty": 2,
    "type": "multiple",
    "question": "Wo wird in einer Maven-basierten Spring-Boot-Anwendung die Spring Boot Version üblicherweise festgelegt?",
    "options": [
      "Im <dependencies>-Block der pom.xml",
      "Im <parent>-Tag der pom.xml mit artifactId 'spring-boot-starter-parent'",
      "In der application.properties",
      "In der Klasse mit @SpringBootApplication"
    ],
    "correct": 1,
    "explanation": "In Maven-Projekten wird die Spring Boot Version über den <parent>-Eintrag mit artifactId 'spring-boot-starter-parent' definiert. Die Version vererbt sich dann auf die Starter-Abhängigkeiten.",
    "xp": 20,
    "tags": [
      "uebung"
    ]
  },
  {
    "difficulty": 4,
    "type": "checkbox",
    "question": "Welche Eigenschaften hat Spring Boot? (Mehrfachauswahl)",
    "options": [
      "Benötigt externe War-Dateien",
      "Eingebettete Container (Tomcat, Jetty)",
      "Automatische Konfiguration soweit möglich",
      "Generierung von Code und Konfiguration",
      "Keine externen Laufzeitabhängigkeiten"
    ],
    "correct": [
      1,
      2,
      4
    ],
    "explanation": "Spring Boot: eingebettete Container, automatische Konfiguration, keine externen Laufzeitabhängigkeiten, KEINE War-Dateien nötig, KEINE Code-Generierung.",
    "xp": 40,
    "tags": [
      "uebung"
    ]
  },
  {
    "difficulty": 4,
    "type": "multiple",
    "question": "Welches Protokoll nutzt gRPC als Transportprotokoll und zu welcher OSI-Schicht gehört es?",
    "options": [
      "WebSocket, Schicht 6",
      "TCP, Schicht 4",
      "HTTP/2, Schicht 7",
      "HTTP/1.1, Schicht 7"
    ],
    "correct": 2,
    "explanation": "gRPC nutzt HTTP/2 als Transportprotokoll, welches zur OSI-Schicht 7 (Anwendungsschicht) gehört.",
    "xp": 40,
    "tags": [
      "uebung"
    ]
  },
  {
    "difficulty": 4,
    "type": "text",
    "question": "Was ist das besondere Feature von gRPC im Vergleich zu REST und GraphQL?",
    "correct": [
      "bidirektionales streaming",
      "bidirectional streaming",
      "streaming"
    ],
    "explanation": "gRPC unterstützt bidirektionales Streaming in verschiedenen Formen: Unary, Server-Streaming, Client-Streaming, Bidirectional-Streaming.",
    "xp": 40,
    "tags": [
      "uebung"
    ]
  },
  {
    "difficulty": 4,
    "type": "fillblank",
    "question": "Eine SPA (Single Page Application) lädt Inhalte dynamisch per _____ nach, ohne die Seite neu zu _____.",
    "blanks": [
      "ajax",
      "laden"
    ],
    "explanation": "Bei einer SPA läuft die Anwendung auf einer HTML-Seite. Inhalte werden dynamisch per AJAX nachgeladen, ohne Seitenneuladung.",
    "xp": 40,
    "tags": [
      "uebung"
    ]
  },
  {
    "difficulty": 4,
    "type": "checkbox",
    "question": "Welche sind serverseitige Technologien? (Mehrfachauswahl)",
    "options": [
      "JavaScript (Client)",
      "PHP",
      "Java Servlets",
      "CSS",
      "Node.js"
    ],
    "correct": [
      1,
      2,
      4
    ],
    "explanation": "Serverseitige Technologien: PHP, Java Servlets, Node.js, Python (Django), Ruby on Rails. JavaScript und CSS laufen primär clientseitig.",
    "xp": 40,
    "tags": [
      "uebung"
    ]
  },
  {
    "difficulty": 4,
    "type": "matching",
    "question": "Ordne die URL-Bestandteile dem Beispiel zu: http://fb2.fra-uas.de:8080/ebis/urls.html?prof=lehmann",
    "pairs": [
      {
        "left": "Scheme",
        "right": "http://"
      },
      {
        "left": "Hostname",
        "right": "fb2.fra-uas.de"
      },
      {
        "left": "Port",
        "right": ":8080"
      },
      {
        "left": "Query",
        "right": "?prof=lehmann"
      }
    ],
    "explanation": "URL-Struktur: Scheme (Protokoll) → Hostname (Domain) → Port → Path (Pfad) → Query (Parameter).",
    "xp": 45,
    "tags": [
      "uebung"
    ]
  },
  {
    "difficulty": 4,
    "type": "multiple",
    "question": "Wofür steht die Abkürzung PHP (rekursives Akronym)?",
    "options": [
      "Personal Home Page",
      "Private Hypertext Processor",
      "PHP: Hypertext Preprocessor",
      "Public HTML Protocol"
    ],
    "correct": 2,
    "explanation": "PHP steht für 'PHP: Hypertext Preprocessor' - ein rekursives Akronym. PHP ist eine serverseitige Skriptsprache.",
    "xp": 40,
    "tags": [
      "uebung"
    ]
  },
  {
    "difficulty": 3,
    "type": "multiple",
    "question": "Die Methode assertThat() wird nicht von JUnit nativ bereitgestellt.",
    "options": [
      "Wahr",
      "Falsch"
    ],
    "correct": 0,
    "explanation": "assertThat() stammt aus Bibliotheken wie AssertJ oder Hamcrest, nicht aus JUnit selbst.",
    "xp": 30,
    "tags": [
      "uebung",
      "neue-vorlesung",
      "offiziell"
    ]
  },
  {
    "difficulty": 4,
    "type": "multiple",
    "question": "Mit Maven können Abhängigkeiten eines Projekts automatisch aufgelöst werden.",
    "options": [
      "Wahr",
      "Falsch"
    ],
    "correct": 0,
    "explanation": "Maven löst Abhängigkeiten automatisch über die pom.xml auf und lädt sie aus Repositories herunter.",
    "xp": 40,
    "tags": [
      "uebung",
      "neue-vorlesung",
      "offiziell"
    ]
  },
  {
    "difficulty": 1,
    "type": "multiple",
    "question": "Wohin schreibt Spring Boot Logs standardmäßig ohne zusätzliche Konfiguration?",
    "options": [
      "In die Konsole (Standard Output)",
      "In eine Datei namens 'application.log'",
      "In eine Datenbank",
      "In das Windows Event Log"
    ],
    "correct": 0,
    "explanation": "Standardmäßig schreibt Spring Boot alle Logs in die Konsole (Standard Output). Für andere Ziele ist zusätzliche Konfiguration nötig.",
    "xp": 10,
    "tags": [
      "uebung"
    ]
  },
  {
    "difficulty": 1,
    "type": "checkbox",
    "question": "Welche Log-Level sind in Spring Boot standardmäßig verfügbar? (Mehrfachauswahl)",
    "options": [
      "ERROR",
      "WARN",
      "INFO",
      "DEBUG",
      "TRACE"
    ],
    "correct": [
      0,
      1,
      2,
      3,
      4
    ],
    "explanation": "Spring Boot unterstützt die Standard-Log-Level: ERROR (kritisch), WARN (Warnungen), INFO (Information), DEBUG (Entwicklung) und TRACE (detailliert).",
    "xp": 15,
    "tags": [
      "uebung"
    ]
  },
  {
    "difficulty": 1,
    "type": "multiple",
    "question": "Was ist das grundlegende Schema für User Stories?",
    "options": [
      "Als <Rolle> möchte ich <Ziel>, damit <Nutzen>",
      "Wenn <Bedingung> dann <Aktion>",
      "Gegeben <Zustand> wenn <Ereignis> dann <Ergebnis>",
      "Falls <Problem> soll <Lösung> implementiert werden"
    ],
    "correct": 0,
    "explanation": "User Stories folgen dem Schema: 'Als <Rolle> möchte ich <Ziel>, damit <Nutzen>'. Dies macht Anforderungen verständlich und nutzerorientiert.",
    "xp": 10,
    "tags": [
      "uebung"
    ]
  },
  {
    "difficulty": 2,
    "type": "matching",
    "question": "Ordne die Logging-Properties ihren Effekten zu:",
    "pairs": [
      {
        "left": "logging.file",
        "right": "Definiert eine spezifische Log-Datei"
      },
      {
        "left": "logging.path",
        "right": "Setzt das Verzeichnis für Log-Dateien"
      },
      {
        "left": "logging.level.*",
        "right": "Konfiguriert Log-Level für Packages"
      },
      {
        "left": "logging.pattern.console",
        "right": "Bestimmt das Format der Konsolenausgabe"
      }
    ],
    "explanation": "Die verschiedenen Logging-Properties steuern unterschiedliche Aspekte: Dateien, Pfade, Level und Ausgabeformat.",
    "xp": 25,
    "tags": [
      "uebung"
    ]
  },
  {
    "difficulty": 2,
    "type": "multiple",
    "question": "Was bewirkt logging.level.edu.fra.uas=debug in der Konfiguration?",
    "options": [
      "Setzt DEBUG-Level für das spezifische Package und Unterpackages",
      "Aktiviert Debugging für die gesamte Anwendung",
      "Loggt nur Fehler aus dem edu.fra.uas Package",
      "Deaktiviert Logging für andere Packages"
    ],
    "correct": 0,
    "explanation": "Diese Einstellung setzt das Log-Level DEBUG für das Package edu.fra.uas und alle seine Unterpackages. Andere Packages bleiben unberührt.",
    "xp": 20,
    "tags": [
      "uebung"
    ]
  },
  {
    "difficulty": 3,
    "type": "checkbox",
    "question": "Welche Vorteile bietet strukturiertes Logging (SLF4J/Logback) gegenüber System.out.println in Spring Boot? (Mehrfachauswahl)",
    "options": [
      "Konfigurierbare Log-Level und Filter",
      "Performance durch asynchrones Logging",
      "Standardisierte Formatierung",
      "Integration mit Spring Boot Actuator",
      "Automatische Dateirotation"
    ],
    "correct": [
      0,
      1,
      2,
      3,
      4
    ],
    "explanation": "Strukturiertes Logging bietet viele Vorteile: konfigurierbare Level, bessere Performance, einheitliche Formate, Monitoring-Integration und Dateiverwaltung.",
    "xp": 30,
    "tags": [
      "uebung"
    ]
  },
  {
    "difficulty": 3,
    "type": "multiple",
    "question": "Was passiert, wenn @Autowired an einer Feldstelle entfernt wird?",
    "options": [
      "Das Feld bleibt null und führt zu NullPointerException bei Verwendung",
      "Spring erstellt automatisch eine neue Instanz",
      "Die Anwendung startet nicht",
      "Es wird eine Warnung ausgegeben"
    ],
    "correct": 0,
    "explanation": "Ohne @Autowired erfolgt keine Dependency Injection. Das Feld bleibt null, was bei Verwendung zu einer NullPointerException führt.",
    "xp": 30,
    "tags": [
      "uebung"
    ]
  },
  {
    "difficulty": 4,
    "type": "matching",
    "question": "Ordne die Test-Konzepte ihren Haupteigenschaften zu:",
    "pairs": [
      {
        "left": "@SpringBootTest",
        "right": "Lädt den vollständigen Application Context"
      },
      {
        "left": "AssertJ",
        "right": "Bietet fluent assertions und bessere Fehlermeldungen"
      },
      {
        "left": "Slice Tests",
        "right": "Testet nur spezifische Schichten der Anwendung"
      },
      {
        "left": "Unit Tests",
        "right": "Testet isolierte Komponenten ohne Spring Context"
      }
    ],
    "explanation": "@SpringBootTest ist für Integrationstests mit vollem Context, AssertJ verbessert die Testlesbarkeit, Slice Tests fokussieren einzelne Schichten, Unit Tests sind am schnellsten.",
    "xp": 40,
    "tags": [
      "uebung"
    ]
  },
  {
    "difficulty": 4,
    "type": "multiple",
    "question": "Welche Funktion hat der <parent>-Eintrag in der pom.xml bei Spring Boot?",
    "options": [
      "Definiert Versionen, Dependencies und Plugins durch Vererbung",
      "Ist nur für Multi-Modul-Projekte erforderlich",
      "Dient ausschließlich der Dokumentation",
      "Wird nur für Test-Konfigurationen verwendet"
    ],
    "correct": 0,
    "explanation": "Der <parent>-Eintrag ermöglicht die Vererbung von Versionen, Dependencies und Plugin-Konfigurationen vom Spring Boot Parent POM, was die Projektkonfiguration vereinfacht.",
    "xp": 40,
    "tags": [
      "uebung"
    ]
  },
  {
    "difficulty": 4,
    "type": "checkbox",
    "question": "Was sind die Besonderheiten eines CommandLineRunner als @Bean? (Mehrfachauswahl)",
    "options": [
      "Wird nach Kontext-Initialisierung ausgeführt",
      "Kann mehrfach im Projekt definiert werden",
      "Hat Zugriff auf andere Beans",
      "Ermöglicht Start-up Logik",
      "Unterstützt Ordering mit @Order"
    ],
    "correct": [
      0,
      1,
      2,
      3,
      4
    ],
    "explanation": "CommandLineRunner als @Bean: läuft nach Kontext-Start, mehrfache Definition möglich, hat Bean-Zugriff, ideal für Start-up Logik, unterstützt Reihenfolge via @Order.",
    "xp": 45,
    "tags": [
      "uebung"
    ]
  },
  {
    "difficulty": 1,
    "type": "multiple",
    "question": "Was ist eine Bean im Spring-Container?",
    "options": [
      "Ein Java-Objekt, das von Spring verwaltet wird",
      "Eine Datenbankverbindung",
      "Ein UI-Element",
      "Eine Konfigurationsdatei"
    ],
    "correct": 0,
    "explanation": "Eine Bean ist ein Java-Objekt, das vom Spring Container verwaltet wird - inklusive Erstellung, Konfiguration und Lebenszyklus-Management.",
    "xp": 10,
    "tags": [
      "uebung"
    ]
  },
  {
    "difficulty": 1,
    "type": "multiple",
    "question": "Welches Log-Level zeigt die wichtigsten Fehler an?",
    "options": [
      "DEBUG",
      "INFO",
      "ERROR",
      "TRACE"
    ],
    "correct": 2,
    "explanation": "ERROR ist das Log-Level für die kritischsten Fehlermeldungen. Es zeigt schwerwiegende Probleme an, die sofortige Aufmerksamkeit erfordern.",
    "xp": 10,
    "tags": [
      "uebung"
    ]
  },
  {
    "difficulty": 1,
    "type": "multiple",
    "question": "Was ist ein Fork in GitHub?",
    "options": [
      "Eine Kopie eines Repositories unter deinem eigenen Account",
      "Ein Branch in einem Repository",
      "Ein Pull Request",
      "Ein Commit in der Historie"
    ],
    "correct": 0,
    "explanation": "Ein Fork ist eine persönliche Kopie eines fremden Repositories unter deinem GitHub-Account. Dies ermöglicht es dir, Änderungen vorzunehmen, ohne das Original zu beeinflussen.",
    "xp": 10,
    "tags": [
      "uebung",
      "neue-vorlesung",
      "offiziell"
    ]
  },
  {
    "difficulty": 2,
    "type": "matching",
    "question": "Ordne die Log-Level ihrer typischen Verwendung zu:",
    "pairs": [
      {
        "left": "ERROR",
        "right": "Kritische Fehler, die sofortige Aktion erfordern"
      },
      {
        "left": "WARN",
        "right": "Potenziell schädliche Situationen"
      },
      {
        "left": "INFO",
        "right": "Wichtige Geschäftsereignisse"
      },
      {
        "left": "DEBUG",
        "right": "Detaillierte Entwicklerinformationen"
      }
    ],
    "explanation": "Die Log-Level haben unterschiedliche Prioritäten und Verwendungszwecke: ERROR für kritische Fehler, WARN für Warnungen, INFO für wichtige Events, DEBUG für Entwicklerdetails.",
    "xp": 25,
    "tags": [
      "uebung"
    ]
  },
  {
    "difficulty": 2,
    "type": "checkbox",
    "question": "Welche Vorteile bietet strukturiertes Logging gegenüber System.out.println? (Mehrfachauswahl)",
    "options": [
      "Konfigurierbare Log-Level",
      "Bessere Filterbarkeit",
      "Mehrere Ausgabekanäle möglich",
      "Formatierte Zeitstempel",
      "Schnellere Ausführung"
    ],
    "correct": [
      0,
      1,
      2,
      3
    ],
    "explanation": "Strukturiertes Logging bietet viele Vorteile: konfigurierbare Level, Filterbarkeit, multiple Ausgabekanäle und automatische Zeitstempel. Die Ausführungsgeschwindigkeit ist nicht primär relevant.",
    "xp": 20,
    "tags": [
      "uebung"
    ]
  },
  {
    "difficulty": 2,
    "type": "multiple",
    "question": "Was ist die Hauptaufgabe des CommandLineRunner in Spring Boot?",
    "options": [
      "Datenbankverbindungen aufbauen",
      "Code beim Anwendungsstart ausführen",
      "REST-Endpunkte definieren",
      "Logging konfigurieren"
    ],
    "correct": 1,
    "explanation": "CommandLineRunner ist ein Interface, dessen run()-Methode nach der Initialisierung der Spring Boot App ausgeführt wird. Es eignet sich für Initialisierungscode beim Start.",
    "xp": 20,
    "tags": [
      "uebung"
    ]
  },
  {
    "difficulty": 3,
    "type": "multiple",
    "question": "Was bedeutet 'Inversion of Control' im Spring-Kontext?",
    "options": [
      "Die Umkehrung der Programmflusssteuerung",
      "Das manuelle Erstellen von Objekten",
      "Die direkte Objektreferenzierung",
      "Die Verwendung von statischen Methoden"
    ],
    "correct": 0,
    "explanation": "Inversion of Control bedeutet, dass die Kontrolle über Objekterstellung und -verwaltung an den Spring Container übertragen wird, statt sie selbst zu implementieren.",
    "xp": 30,
    "tags": [
      "uebung"
    ]
  },
  {
    "difficulty": 3,
    "type": "checkbox",
    "question": "Welche Aussagen über Konstruktor-Injektion sind korrekt? (Mehrfachauswahl)",
    "options": [
      "Garantiert vollständige Initialisierung",
      "Unterstützt Immutability",
      "Macht Abhängigkeiten explizit",
      "Ist flexibler als Setter-Injektion",
      "Erfordert weniger Code als Feld-Injektion"
    ],
    "correct": [
      0,
      1,
      2
    ],
    "explanation": "Konstruktor-Injektion wird bevorzugt, weil sie vollständige Initialisierung garantiert, Immutability ermöglicht und Abhängigkeiten explizit macht. Sie ist nicht flexibler und erfordert mehr Code.",
    "xp": 30,
    "tags": [
      "uebung"
    ]
  },
  {
    "difficulty": 3,
    "type": "matching",
    "question": "Ordne die Spring-Annotationen ihrer Hauptfunktion zu:",
    "pairs": [
      {
        "left": "@SpringBootApplication",
        "right": "Kombiniert mehrere Basis-Annotationen"
      },
      {
        "left": "@Component",
        "right": "Markiert Klasse als Spring-verwaltete Komponente"
      },
      {
        "left": "@Bean",
        "right": "Definiert Methode zur Bean-Erstellung"
      },
      {
        "left": "@Autowired",
        "right": "Injiziert Abhängigkeiten"
      }
    ],
    "explanation": "Die Annotationen haben unterschiedliche Zwecke: @SpringBootApplication für App-Konfiguration, @Component für Komponenten-Scanning, @Bean für explizite Bean-Definition, @Autowired für Dependency Injection.",
    "xp": 35,
    "tags": [
      "uebung"
    ]
  },
  {
    "difficulty": 4,
    "type": "checkbox",
    "question": "Welche Konzepte sind Teil der Spring Boot Auto-Konfiguration? (Mehrfachauswahl)",
    "options": [
      "Konvention vor Konfiguration",
      "Bedingte Bean-Registrierung",
      "Externe Konfigurationsdateien",
      "Starter Dependencies",
      "Metriken und Health-Checks"
    ],
    "correct": [
      0,
      1,
      3
    ],
    "explanation": "Spring Boot's Auto-Konfiguration basiert auf mehreren Konzepten: Konventionen, bedingter Bean-Registrierung und Starter Dependencies. Externe Konfigurationsdateien und Metriken sind separate Features.",
    "xp": 40,
    "tags": [
      "uebung"
    ]
  },
  {
    "difficulty": 4,
    "type": "matching",
    "question": "Ordne die Maven-Konzepte ihrer Bedeutung zu:",
    "pairs": [
      {
        "left": "groupId",
        "right": "Organisationsweiter, eindeutiger Identifier"
      },
      {
        "left": "artifactId",
        "right": "Name des Projekts/der Bibliothek"
      },
      {
        "left": "version",
        "right": "Spezifische Release-Kennung"
      },
      {
        "left": "parent",
        "right": "Vererbungshierarchie und gemeinsame Konfiguration"
      }
    ],
    "explanation": "Maven POM-Elemente haben spezifische Rollen: groupId für Organisation, artifactId für Projektname, version für Release-Identifikation, parent für Vererbung.",
    "xp": 40,
    "tags": [
      "uebung"
    ]
  },
  {
    "difficulty": 4,
    "type": "checkbox",
    "question": "Welche Aspekte unterscheiden Integration-Tests von Unit-Tests in Spring Boot? (Mehrfachauswahl)",
    "options": [
      "Vollständiger Spring Kontext wird geladen",
      "Testen mehrerer Komponenten zusammen",
      "Verwendung von @SpringBootTest",
      "Längere Ausführungszeit",
      "Externe Ressourcen können eingebunden sein"
    ],
    "correct": [
      0,
      1,
      2,
      3,
      4
    ],
    "explanation": "Integration-Tests unterscheiden sich durch: Laden des Spring Kontexts, Testing mehrerer Komponenten, @SpringBootTest Annotation, längere Laufzeit und mögliche externe Ressourcen.",
    "xp": 45,
    "tags": [
      "uebung"
    ]
  },
  {
    "difficulty": 1,
    "type": "multiple",
    "question": "Was ist GitHub?",
    "options": [
      "Ein Texteditor",
      "Eine Codehosting-Plattform für Versionskontrolle",
      "Eine Programmiersprache",
      "Ein Betriebssystem"
    ],
    "correct": 1,
    "explanation": "GitHub ist eine Codehosting-Plattform für die Versionskontrolle und Zusammenarbeit in Projekten.",
    "xp": 10,
    "tags": [
      "uebung",
      "offiziell"
    ]
  },
  {
    "difficulty": 2,
    "type": "multiple",
    "question": "Was ist eine Bean in Spring?",
    "options": [
      "Eine JavaScript-Bibliothek",
      "Eine Datenbank-Tabelle",
      "Ein verwaltetes Java-Objekt innerhalb des Spring Containers",
      "Ein Konfigurationsfile"
    ],
    "correct": 2,
    "explanation": "Eine Bean ist ein verwaltetes Java-Objekt innerhalb des Spring Containers. Die Bean wird erstellt, überwacht und gelöscht.",
    "xp": 20,
    "tags": [
      "uebung"
    ]
  },
  {
    "difficulty": 2,
    "type": "matching",
    "question": "Ordne die Spring-Annotationen ihrer Funktion zu:",
    "pairs": [
      {
        "left": "@SpringBootApplication",
        "right": "Kennzeichnet die Main-Klasse"
      },
      {
        "left": "@Component",
        "right": "Macht die Klasse zu einer Bean"
      },
      {
        "left": "@Autowired",
        "right": "Injiziert ein Bean-Objekt"
      },
      {
        "left": "@Bean",
        "right": "Definiert eine Bean-Methode"
      }
    ],
    "explanation": "@SpringBootApplication markiert die Main-Klasse, @Component macht Klassen zu Beans, @Autowired injiziert Dependencies, @Bean definiert Bean-Methoden.",
    "xp": 25,
    "tags": [
      "uebung"
    ]
  },
  {
    "difficulty": 2,
    "type": "fillblank",
    "question": "In Spring Boot wird die Konfiguration in der Datei _____ im Ordner _____ gespeichert.",
    "blanks": [
      "application.properties",
      "resources"
    ],
    "explanation": "Die Datei application.properties im Ordner resources enthält die Konfiguration für Spring Boot Anwendungen.",
    "xp": 20,
    "tags": [
      "uebung"
    ]
  },
  {
    "difficulty": 2,
    "type": "sort",
    "question": "Sortiere die Log-Level von niedrigster zu höchster Priorität:",
    "items": [
      "ERROR",
      "WARN",
      "INFO",
      "DEBUG",
      "TRACE"
    ],
    "correct": [
      "TRACE",
      "DEBUG",
      "INFO",
      "WARN",
      "ERROR"
    ],
  "explanation": "Die Log-Level von niedrigster zu höchster Priorität: TRACE (am detailliertesten) → DEBUG → INFO → WARN → ERROR (kritischste Fehler).\n✅ TRACE → DEBUG → INFO → WARN → ERROR",
    "xp": 25,
    "tags": [
      "uebung"
    ]
  },
  {
    "difficulty": 2,
    "type": "multiple",
    "question": "Was ist Maven?",
    "options": [
      "Ein Web-Framework",
      "Eine Datenbank",
      "Eine Programmiersprache",
      "Ein Build-Management-Tool für Java-Projekte"
    ],
    "correct": 3,
    "explanation": "Maven ist ein Build-Management-Tool, das den Software-Erstellungszyklus verwaltet. Konfiguration erfolgt in pom.xml.",
    "xp": 20,
    "tags": [
      "uebung"
    ]
  },
  {
    "difficulty": 2,
    "type": "fillblank",
    "question": "Um den Log-Level für ein Package auf DEBUG zu setzen, verwendet man in application.properties: logging.level.<Packagename>=_____",
    "blanks": [
      "DEBUG"
    ],
    "explanation": "Mit logging.level.<packagename>=DEBUG wird der Log-Level für ein Package auf DEBUG gesetzt.",
    "xp": 20,
    "tags": [
      "uebung"
    ]
  },
  {
    "difficulty": 3,
    "type": "sort",
    "question": "Sortiere die Schichten der 3-Tier-Architektur von oben nach unten:",
    "items": [
      "Datenhaltungsschicht",
      "Anwendungslogik-Schicht",
      "Präsentationsschicht"
    ],
    "correct": [
      "Präsentationsschicht",
      "Anwendungslogik-Schicht",
      "Datenhaltungsschicht"
    ],
  "explanation": "3-Tier-Architektur von oben: Präsentationsschicht (UI) → Anwendungslogik (Business Logic) → Datenhaltung (Datenbank).\n✅ Präsentationsschicht → Anwendungslogik-Schicht → Datenhaltungsschicht",
    "xp": 30,
    "tags": [
      "uebung"
    ]
  },
  {
    "difficulty": 3,
    "type": "matching",
    "question": "Ordne die REST-Prinzipien ihrer Beschreibung zu:",
    "pairs": [
      {
        "left": "Stateless",
        "right": "Zustandslosigkeit der Anfragen"
      },
      {
        "left": "Cacheability",
        "right": "Responses können gecacht werden"
      },
      {
        "left": "Uniform Interface",
        "right": "Einheitliche Schnittstelle"
      },
      {
        "left": "HATEOAS",
        "right": "Links zu verwandten Ressourcen"
      }
    ],
    "explanation": "REST-Prinzipien: Stateless (zustandslos), Cacheability (cachebar), Uniform Interface (einheitlich), HATEOAS (Hypermedia as Engine of Application State).",
    "xp": 35,
    "tags": [
      "uebung"
    ]
  },
  {
    "difficulty": 3,
    "type": "checkbox",
    "question": "Welche HTTP-Methoden sind 'safe' (sicher)? (Mehrfachauswahl)",
    "options": [
      "POST",
      "GET",
      "PUT",
      "HEAD",
      "DELETE"
    ],
    "correct": [
      1,
      3
    ],
    "explanation": "Safe (sicher) sind nur GET und HEAD - sie ändern keine Daten auf dem Server. POST, PUT und DELETE ändern Daten.",
    "xp": 30,
    "tags": [
      "uebung"
    ]
  },
  {
    "difficulty": 3,
    "type": "fillblank",
    "question": "Die Annotation _____ kennzeichnet Test-Methoden in JUnit, während _____ die Test-Klasse für Spring Boot markiert.",
    "blanks": [
      "@Test",
      "@SpringBootTest"
    ],
    "explanation": "@Test markiert einzelne Test-Methoden, @SpringBootTest kennzeichnet die Test-Klasse für Spring Boot.",
    "xp": 30,
    "tags": [
      "uebung"
    ]
  },
  {
    "difficulty": 3,
    "type": "multiple",
    "question": "Was passiert, wenn die @Autowired Annotation entfernt wird?",
    "options": [
      "Das Programm läuft schneller",
      "Die Bean wird nicht injiziert und es gibt eine NullPointerException",
      "Die Bean wird automatisch erstellt",
      "Das Programm kompiliert nicht"
    ],
    "correct": 1,
    "explanation": "Ohne @Autowired wird das Bean-Objekt nicht injiziert und bleibt null, was zu einer NullPointerException führt, wenn darauf zugegriffen wird.",
    "xp": 30,
    "tags": [
      "uebung"
    ]
  },
  {
    "difficulty": 3,
    "type": "multiple",
    "question": "Welche Operationen unterstützt GraphQL?",
    "options": [
      "SELECT, INSERT, UPDATE, DELETE",
      "GET, POST, PUT, DELETE",
      "Query, Mutation, Subscription",
      "READ, WRITE, UPDATE"
    ],
    "correct": 2,
    "explanation": "GraphQL unterstützt: Query (Abfragen), Mutation (Änderungen), Subscription (Echtzeit-Updates).",
    "xp": 30,
    "tags": [
      "uebung"
    ]
  },
  {
    "difficulty": 4,
    "type": "matching",
    "question": "Ordne die Komponenten des MVC-Patterns ihrer Rolle zu:",
    "pairs": [
      {
        "left": "Model",
        "right": "Datenmodell und Geschäftslogik"
      },
      {
        "left": "View",
        "right": "Darstellung der Benutzeroberfläche"
      },
      {
        "left": "Controller",
        "right": "Steuerung und Vermittlung"
      },
      {
        "left": "@RequestMapping",
        "right": "Verknüpfung von URLs mit Methoden"
      }
    ],
    "explanation": "MVC: Model (Daten/Logik), View (UI), Controller (Steuerung). @RequestMapping verbindet HTTP-Requests mit Handler-Methoden.",
    "xp": 40,
    "tags": [
      "uebung"
    ]
  },
  {
    "difficulty": 4,
    "type": "sort",
    "question": "Sortiere den Maven Build-Zyklus in der richtigen Reihenfolge:",
    "items": [
      "Installation",
      "Validierung",
      "Verifizierung",
      "Kompilierung",
      "Testen",
      "Paketieren"
    ],
    "correct": [
      "Validierung",
      "Kompilierung",
      "Testen",
      "Paketieren",
      "Verifizierung",
      "Installation"
    ],
  "explanation": "Maven Build-Zyklus: Validierung → Kompilierung → Testen → Paketieren → Verifizierung → Installation (Items-Reihenfolge; Integrationstests & Verteilung sind optionale weitere Phasen).\n✅ Validierung → Kompilierung → Testen → Paketieren → Verifizierung → Installation",
    "xp": 40,
    "tags": [
      "uebung"
    ]
  },
  {
    "difficulty": 2,
    "type": "multiple",
    "question": "Wo wird in einer Maven-basierten Spring-Boot-Anwendung die Spring Boot Version üblicherweise festgelegt?",
    "options": [
      "Im <dependencies>-Block der pom.xml",
      "Im <parent>-Tag der pom.xml mit artifactId 'spring-boot-starter-parent'",
      "In der application.properties",
      "In der Klasse mit @SpringBootApplication"
    ],
    "correct": 1,
    "explanation": "In Maven-Projekten wird die Spring Boot Version über den <parent>-Eintrag mit artifactId 'spring-boot-starter-parent' definiert. Die Version vererbt sich dann auf die Starter-Abhängigkeiten.",
    "xp": 20,
    "tags": [
      "uebung"
    ]
  },
  {
    "difficulty": 4,
    "type": "checkbox",
    "question": "Welche Eigenschaften hat Spring Boot? (Mehrfachauswahl)",
    "options": [
      "Benötigt externe War-Dateien",
      "Eingebettete Container (Tomcat, Jetty)",
      "Automatische Konfiguration soweit möglich",
      "Generierung von Code und Konfiguration",
      "Keine externen Laufzeitabhängigkeiten"
    ],
    "correct": [
      1,
      2,
      4
    ],
    "explanation": "Spring Boot: eingebettete Container, automatische Konfiguration, keine externen Laufzeitabhängigkeiten, KEINE War-Dateien nötig, KEINE Code-Generierung.",
    "xp": 40,
    "tags": [
      "uebung"
    ]
  },
  {
    "difficulty": 4,
    "type": "multiple",
    "question": "Welches Protokoll nutzt gRPC als Transportprotokoll und zu welcher OSI-Schicht gehört es?",
    "options": [
      "WebSocket, Schicht 6",
      "TCP, Schicht 4",
      "HTTP/2, Schicht 7",
      "HTTP/1.1, Schicht 7"
    ],
    "correct": 2,
    "explanation": "gRPC nutzt HTTP/2 als Transportprotokoll, welches zur OSI-Schicht 7 (Anwendungsschicht) gehört.",
    "xp": 40,
    "tags": [
      "uebung"
    ]
  },
  {
    "difficulty": 4,
    "type": "text",
    "question": "Was ist das besondere Feature von gRPC im Vergleich zu REST und GraphQL?",
    "correct": [
      "bidirektionales streaming",
      "bidirectional streaming",
      "streaming"
    ],
    "explanation": "gRPC unterstützt bidirektionales Streaming in verschiedenen Formen: Unary, Server-Streaming, Client-Streaming, Bidirectional-Streaming.",
    "xp": 40,
    "tags": [
      "uebung"
    ]
  },
  {
    "difficulty": 4,
    "type": "fillblank",
    "question": "Eine SPA (Single Page Application) lädt Inhalte dynamisch per _____ nach, ohne die Seite neu zu _____.",
    "blanks": [
      "ajax",
      "laden"
    ],
    "explanation": "Bei einer SPA läuft die Anwendung auf einer HTML-Seite. Inhalte werden dynamisch per AJAX nachgeladen, ohne Seitenneuladung.",
    "xp": 40,
    "tags": [
      "uebung"
    ]
  },
  {
    "difficulty": 4,
    "type": "checkbox",
    "question": "Welche sind serverseitige Technologien? (Mehrfachauswahl)",
    "options": [
      "JavaScript (Client)",
      "PHP",
      "Java Servlets",
      "CSS",
      "Node.js"
    ],
    "correct": [
      1,
      2,
      4
    ],
    "explanation": "Serverseitige Technologien: PHP, Java Servlets, Node.js, Python (Django), Ruby on Rails. JavaScript und CSS laufen primär clientseitig.",
    "xp": 40,
    "tags": [
      "uebung"
    ]
  },
  {
    "difficulty": 4,
    "type": "matching",
    "question": "Ordne die URL-Bestandteile dem Beispiel zu: http://fb2.fra-uas.de:8080/ebis/urls.html?prof=lehmann",
    "pairs": [
      {
        "left": "Scheme",
        "right": "http://"
      },
      {
        "left": "Hostname",
        "right": "fb2.fra-uas.de"
      },
      {
        "left": "Port",
        "right": ":8080"
      },
      {
        "left": "Query",
        "right": "?prof=lehmann"
      }
    ],
    "explanation": "URL-Struktur: Scheme (Protokoll) → Hostname (Domain) → Port → Path (Pfad) → Query (Parameter).",
    "xp": 45,
    "tags": [
      "uebung"
    ]
  },
  {
    "difficulty": 4,
    "type": "multiple",
    "question": "Wofür steht die Abkürzung PHP (rekursives Akronym)?",
    "options": [
      "Personal Home Page",
      "Private Hypertext Processor",
      "PHP: Hypertext Preprocessor",
      "Public HTML Protocol"
    ],
    "correct": 2,
    "explanation": "PHP steht für 'PHP: Hypertext Preprocessor' - ein rekursives Akronym. PHP ist eine serverseitige Skriptsprache.",
    "xp": 40,
    "tags": [
      "uebung"
    ]
  },
  {
    "difficulty": 3,
    "type": "multiple",
    "question": "Die Methode assertThat() wird nicht von JUnit nativ bereitgestellt.",
    "options": [
      "Wahr",
      "Falsch"
    ],
    "correct": 0,
    "explanation": "assertThat() stammt aus Bibliotheken wie AssertJ oder Hamcrest, nicht aus JUnit selbst.",
    "xp": 30,
    "tags": [
      "uebung",
      "neue-vorlesung",
      "offiziell"
    ]
  },
  {
    "difficulty": 4,
    "type": "multiple",
    "question": "Mit Maven können Abhängigkeiten eines Projekts automatisch aufgelöst werden.",
    "options": [
      "Wahr",
      "Falsch"
    ],
    "correct": 0,
    "explanation": "Maven löst Abhängigkeiten automatisch über die pom.xml auf und lädt sie aus Repositories herunter.",
    "xp": 40,
    "tags": [
      "uebung",
      "neue-vorlesung",
      "offiziell"
    ]
  },
  {
    "difficulty": 1,
    "type": "multiple",
    "question": "Wohin schreibt Spring Boot Logs standardmäßig ohne zusätzliche Konfiguration?",
    "options": [
      "In die Konsole (Standard Output)",
      "In eine Datei namens 'application.log'",
      "In eine Datenbank",
      "In das Windows Event Log"
    ],
    "correct": 0,
    "explanation": "Standardmäßig schreibt Spring Boot alle Logs in die Konsole (Standard Output). Für andere Ziele ist zusätzliche Konfiguration nötig.",
    "xp": 10,
    "tags": [
      "uebung"
    ]
  },
  {
    "difficulty": 1,
    "type": "checkbox",
    "question": "Welche Log-Level sind in Spring Boot standardmäßig verfügbar? (Mehrfachauswahl)",
    "options": [
      "ERROR",
      "WARN",
      "INFO",
      "DEBUG",
      "TRACE"
    ],
    "correct": [
      0,
      1,
      2,
      3,
      4
    ],
    "explanation": "Spring Boot unterstützt die Standard-Log-Level: ERROR (kritisch), WARN (Warnungen), INFO (Information), DEBUG (Entwicklung) und TRACE (detailliert).",
    "xp": 15,
    "tags": [
      "uebung"
    ]
  },
  {
    "difficulty": 1,
    "type": "multiple",
    "question": "Was ist das grundlegende Schema für User Stories?",
    "options": [
      "Als <Rolle> möchte ich <Ziel>, damit <Nutzen>",
      "Wenn <Bedingung> dann <Aktion>",
      "Gegeben <Zustand> wenn <Ereignis> dann <Ergebnis>",
      "Falls <Problem> soll <Lösung> implementiert werden"
    ],
    "correct": 0,
    "explanation": "User Stories folgen dem Schema: 'Als <Rolle> möchte ich <Ziel>, damit <Nutzen>'. Dies macht Anforderungen verständlich und nutzerorientiert.",
    "xp": 10,
    "tags": [
      "uebung"
    ]
  },
  {
    "difficulty": 2,
    "type": "matching",
    "question": "Ordne die Logging-Properties ihren Effekten zu:",
    "pairs": [
      {
        "left": "logging.file",
        "right": "Definiert eine spezifische Log-Datei"
      },
      {
        "left": "logging.path",
        "right": "Setzt das Verzeichnis für Log-Dateien"
      },
      {
        "left": "logging.level.*",
        "right": "Konfiguriert Log-Level für Packages"
      },
      {
        "left": "logging.pattern.console",
        "right": "Bestimmt das Format der Konsolenausgabe"
      }
    ],
    "explanation": "Die verschiedenen Logging-Properties steuern unterschiedliche Aspekte: Dateien, Pfade, Level und Ausgabeformat.",
    "xp": 25,
    "tags": [
      "uebung"
    ]
  },
  {
    "difficulty": 2,
    "type": "multiple",
    "question": "Was bewirkt logging.level.edu.fra.uas=debug in der Konfiguration?",
    "options": [
      "Setzt DEBUG-Level für das spezifische Package und Unterpackages",
      "Aktiviert Debugging für die gesamte Anwendung",
      "Loggt nur Fehler aus dem edu.fra.uas Package",
      "Deaktiviert Logging für andere Packages"
    ],
    "correct": 0,
    "explanation": "Diese Einstellung setzt das Log-Level DEBUG für das Package edu.fra.uas und alle seine Unterpackages. Andere Packages bleiben unberührt.",
    "xp": 20,
    "tags": [
      "uebung"
    ]
  },
  {
    "difficulty": 3,
    "type": "checkbox",
    "question": "Welche Vorteile bietet strukturiertes Logging (SLF4J/Logback) gegenüber System.out.println in Spring Boot? (Mehrfachauswahl)",
    "options": [
      "Konfigurierbare Log-Level und Filter",
      "Performance durch asynchrones Logging",
      "Standardisierte Formatierung",
      "Integration mit Spring Boot Actuator",
      "Automatische Dateirotation"
    ],
    "correct": [
      0,
      1,
      2,
      3,
      4
    ],
    "explanation": "Strukturiertes Logging bietet viele Vorteile: konfigurierbare Level, bessere Performance, einheitliche Formate, Monitoring-Integration und Dateiverwaltung.",
    "xp": 30,
    "tags": [
      "uebung"
    ]
  },
  {
    "difficulty": 3,
    "type": "multiple",
    "question": "Was passiert, wenn @Autowired an einer Feldstelle entfernt wird?",
    "options": [
      "Das Feld bleibt null und führt zu NullPointerException bei Verwendung",
      "Spring erstellt automatisch eine neue Instanz",
      "Die Anwendung startet nicht",
      "Es wird eine Warnung ausgegeben"
    ],
    "correct": 0,
    "explanation": "Ohne @Autowired erfolgt keine Dependency Injection. Das Feld bleibt null, was bei Verwendung zu einer NullPointerException führt.",
    "xp": 30,
    "tags": [
      "uebung"
    ]
  },
  {
    "difficulty": 4,
    "type": "matching",
    "question": "Ordne die Test-Konzepte ihren Haupteigenschaften zu:",
    "pairs": [
      {
        "left": "@SpringBootTest",
        "right": "Lädt den vollständigen Application Context"
      },
      {
        "left": "AssertJ",
        "right": "Bietet fluent assertions und bessere Fehlermeldungen"
      },
      {
        "left": "Slice Tests",
        "right": "Testet nur spezifische Schichten der Anwendung"
      },
      {
        "left": "Unit Tests",
        "right": "Testet isolierte Komponenten ohne Spring Context"
      }
    ],
    "explanation": "@SpringBootTest ist für Integrationstests mit vollem Context, AssertJ verbessert die Testlesbarkeit, Slice Tests fokussieren einzelne Schichten, Unit Tests sind am schnellsten.",
    "xp": 40,
    "tags": [
      "uebung"
    ]
  },
  {
    "difficulty": 4,
    "type": "multiple",
    "question": "Welche Funktion hat der <parent>-Eintrag in der pom.xml bei Spring Boot?",
    "options": [
      "Definiert Versionen, Dependencies und Plugins durch Vererbung",
      "Ist nur für Multi-Modul-Projekte erforderlich",
      "Dient ausschließlich der Dokumentation",
      "Wird nur für Test-Konfigurationen verwendet"
    ],
    "correct": 0,
    "explanation": "Der <parent>-Eintrag ermöglicht die Vererbung von Versionen, Dependencies und Plugin-Konfigurationen vom Spring Boot Parent POM, was die Projektkonfiguration vereinfacht.",
    "xp": 40,
    "tags": [
      "uebung"
    ]
  },
  {
    "difficulty": 4,
    "type": "checkbox",
    "question": "Was sind die Besonderheiten eines CommandLineRunner als @Bean? (Mehrfachauswahl)",
    "options": [
      "Wird nach Kontext-Initialisierung ausgeführt",
      "Kann mehrfach im Projekt definiert werden",
      "Hat Zugriff auf andere Beans",
      "Ermöglicht Start-up Logik",
      "Unterstützt Ordering mit @Order"
    ],
    "correct": [
      0,
      1,
      2,
      3,
      4
    ],
    "explanation": "CommandLineRunner als @Bean: läuft nach Kontext-Start, mehrfache Definition möglich, hat Bean-Zugriff, ideal für Start-up Logik, unterstützt Reihenfolge via @Order.",
    "xp": 45,
    "tags": [
      "uebung"
    ]
  },
  {
    "difficulty": 1,
    "type": "multiple",
    "question": "Was ist eine Bean im Spring-Container?",
    "options": [
      "Ein Java-Objekt, das von Spring verwaltet wird",
      "Eine Datenbankverbindung",
      "Ein UI-Element",
      "Eine Konfigurationsdatei"
    ],
    "correct": 0,
    "explanation": "Eine Bean ist ein Java-Objekt, das vom Spring Container verwaltet wird - inklusive Erstellung, Konfiguration und Lebenszyklus-Management.",
    "xp": 10,
    "tags": [
      "uebung"
    ]
  },
  {
    "difficulty": 1,
    "type": "multiple",
    "question": "Welches Log-Level zeigt die wichtigsten Fehler an?",
    "options": [
      "DEBUG",
      "INFO",
      "ERROR",
      "TRACE"
    ],
    "correct": 2,
    "explanation": "ERROR ist das Log-Level für die kritischsten Fehlermeldungen. Es zeigt schwerwiegende Probleme an, die sofortige Aufmerksamkeit erfordern.",
    "xp": 10,
    "tags": [
      "uebung"
    ]
  },
  {
    "difficulty": 1,
    "type": "multiple",
    "question": "Was ist ein Fork in GitHub?",
    "options": [
      "Eine Kopie eines Repositories unter deinem eigenen Account",
      "Ein Branch in einem Repository",
      "Ein Pull Request",
      "Ein Commit in der Historie"
    ],
    "correct": 0,
    "explanation": "Ein Fork ist eine persönliche Kopie eines fremden Repositories unter deinem GitHub-Account. Dies ermöglicht es dir, Änderungen vorzunehmen, ohne das Original zu beeinflussen.",
    "xp": 10,
    "tags": [
      "uebung",
      "neue-vorlesung",
      "offiziell"
    ]
  },
  {
    "difficulty": 2,
    "type": "matching",
    "question": "Ordne die Log-Level ihrer typischen Verwendung zu:",
    "pairs": [
      {
        "left": "ERROR",
        "right": "Kritische Fehler, die sofortige Aktion erfordern"
      },
      {
        "left": "WARN",
        "right": "Potenziell schädliche Situationen"
      },
      {
        "left": "INFO",
        "right": "Wichtige Geschäftsereignisse"
      },
      {
        "left": "DEBUG",
        "right": "Detaillierte Entwicklerinformationen"
      }
    ],
    "explanation": "Die Log-Level haben unterschiedliche Prioritäten und Verwendungszwecke: ERROR für kritische Fehler, WARN für Warnungen, INFO für wichtige Events, DEBUG für Entwicklerdetails.",
    "xp": 25,
    "tags": [
      "uebung"
    ]
  },
  {
    "difficulty": 2,
    "type": "checkbox",
    "question": "Welche Vorteile bietet strukturiertes Logging gegenüber System.out.println? (Mehrfachauswahl)",
    "options": [
      "Konfigurierbare Log-Level",
      "Bessere Filterbarkeit",
      "Mehrere Ausgabekanäle möglich",
      "Formatierte Zeitstempel",
      "Schnellere Ausführung"
    ],
    "correct": [
      0,
      1,
      2,
      3
    ],
    "explanation": "Strukturiertes Logging bietet viele Vorteile: konfigurierbare Level, Filterbarkeit, multiple Ausgabekanäle und automatische Zeitstempel. Die Ausführungsgeschwindigkeit ist nicht primär relevant.",
    "xp": 20,
    "tags": [
      "uebung"
    ]
  },
  {
    "difficulty": 2,
    "type": "multiple",
    "question": "Was ist die Hauptaufgabe des CommandLineRunner in Spring Boot?",
    "options": [
      "Datenbankverbindungen aufbauen",
      "Code beim Anwendungsstart ausführen",
      "REST-Endpunkte definieren",
      "Logging konfigurieren"
    ],
    "correct": 1,
    "explanation": "CommandLineRunner ist ein Interface, dessen run()-Methode nach der Initialisierung der Spring Boot App ausgeführt wird. Es eignet sich für Initialisierungscode beim Start.",
    "xp": 20,
    "tags": [
      "uebung"
    ]
  },
  {
    "difficulty": 3,
    "type": "multiple",
    "question": "Was bedeutet 'Inversion of Control' im Spring-Kontext?",
    "options": [
      "Die Umkehrung der Programmflusssteuerung",
      "Das manuelle Erstellen von Objekten",
      "Die direkte Objektreferenzierung",
      "Die Verwendung von statischen Methoden"
    ],
    "correct": 0,
    "explanation": "Inversion of Control bedeutet, dass die Kontrolle über Objekterstellung und -verwaltung an den Spring Container übertragen wird, statt sie selbst zu implementieren.",
    "xp": 30,
    "tags": [
      "uebung"
    ]
  },
  {
    "difficulty": 3,
    "type": "checkbox",
    "question": "Welche Aussagen über Konstruktor-Injektion sind korrekt? (Mehrfachauswahl)",
    "options": [
      "Garantiert vollständige Initialisierung",
      "Unterstützt Immutability",
      "Macht Abhängigkeiten explizit",
      "Ist flexibler als Setter-Injektion",
      "Erfordert weniger Code als Feld-Injektion"
    ],
    "correct": [
      0,
      1,
      2
    ],
    "explanation": "Konstruktor-Injektion wird bevorzugt, weil sie vollständige Initialisierung garantiert, Immutability ermöglicht und Abhängigkeiten explizit macht. Sie ist nicht flexibler und erfordert mehr Code.",
    "xp": 30,
    "tags": [
      "uebung"
    ]
  },
  {
    "difficulty": 3,
    "type": "matching",
    "question": "Ordne die Spring-Annotationen ihrer Hauptfunktion zu:",
    "pairs": [
      {
        "left": "@SpringBootApplication",
        "right": "Kombiniert mehrere Basis-Annotationen"
      },
      {
        "left": "@Component",
        "right": "Markiert Klasse als Spring-verwaltete Komponente"
      },
      {
        "left": "@Bean",
        "right": "Definiert Methode zur Bean-Erstellung"
      },
      {
        "left": "@Autowired",
        "right": "Injiziert Abhängigkeiten"
      }
    ],
    "explanation": "Die Annotationen haben unterschiedliche Zwecke: @SpringBootApplication für App-Konfiguration, @Component für Komponenten-Scanning, @Bean für explizite Bean-Definition, @Autowired für Dependency Injection.",
    "xp": 35,
    "tags": [
      "uebung"
    ]
  },
  {
    "difficulty": 4,
    "type": "checkbox",
    "question": "Welche Konzepte sind Teil der Spring Boot Auto-Konfiguration? (Mehrfachauswahl)",
    "options": [
      "Konvention vor Konfiguration",
      "Bedingte Bean-Registrierung",
      "Externe Konfigurationsdateien",
      "Starter Dependencies",
      "Metriken und Health-Checks"
    ],
    "correct": [
      0,
      1,
      3
    ],
    "explanation": "Spring Boot's Auto-Konfiguration basiert auf mehreren Konzepten: Konventionen, bedingter Bean-Registrierung und Starter Dependencies. Externe Konfigurationsdateien und Metriken sind separate Features.",
    "xp": 40,
    "tags": [
      "uebung"
    ]
  },
  {
    "difficulty": 4,
    "type": "matching",
    "question": "Ordne die Maven-Konzepte ihrer Bedeutung zu:",
    "pairs": [
      {
        "left": "groupId",
        "right": "Organisationsweiter, eindeutiger Identifier"
      },
      {
        "left": "artifactId",
        "right": "Name des Projekts/der Bibliothek"
      },
      {
        "left": "version",
        "right": "Spezifische Release-Kennung"
      },
      {
        "left": "parent",
        "right": "Vererbungshierarchie und gemeinsame Konfiguration"
      }
    ],
    "explanation": "Maven POM-Elemente haben spezifische Rollen: groupId für Organisation, artifactId für Projektname, version für Release-Identifikation, parent für Vererbung.",
    "xp": 40,
    "tags": [
      "uebung"
    ]
  },
  {
    "difficulty": 4,
    "type": "checkbox",
    "question": "Welche Aspekte unterscheiden Integration-Tests von Unit-Tests in Spring Boot? (Mehrfachauswahl)",
    "options": [
      "Vollständiger Spring Kontext wird geladen",
      "Testen mehrerer Komponenten zusammen",
      "Verwendung von @SpringBootTest",
      "Längere Ausführungszeit",
      "Externe Ressourcen können eingebunden sein"
    ],
    "correct": [
      0,
      1,
      2,
      3,
      4
    ],
    "explanation": "Integration-Tests unterscheiden sich durch: Laden des Spring Kontexts, Testing mehrerer Komponenten, @SpringBootTest Annotation, längere Laufzeit und mögliche externe Ressourcen.",
    "xp": 45,
    "tags": [
      "uebung"
    ]
  },
  {
    "difficulty": 1,
    "type": "multiple",
    "question": "Was ist GitHub?",
    "options": [
      "Ein Texteditor",
      "Eine Codehosting-Plattform für Versionskontrolle",
      "Eine Programmiersprache",
      "Ein Betriebssystem"
    ],
    "correct": 1,
    "explanation": "GitHub ist eine Codehosting-Plattform für die Versionskontrolle und Zusammenarbeit in Projekten.",
    "xp": 10,
    "tags": [
      "uebung",
      "offiziell"
    ]
  },
  {
    "difficulty": 2,
    "type": "multiple",
    "question": "Was ist eine Bean in Spring?",
    "options": [
      "Eine JavaScript-Bibliothek",
      "Eine Datenbank-Tabelle",
      "Ein verwaltetes Java-Objekt innerhalb des Spring Containers",
      "Ein Konfigurationsfile"
    ],
    "correct": 2,
    "explanation": "Eine Bean ist ein verwaltetes Java-Objekt innerhalb des Spring Containers. Die Bean wird erstellt, überwacht und gelöscht.",
    "xp": 20,
    "tags": [
      "uebung"
    ]
  },
  {
    "difficulty": 2,
    "type": "matching",
    "question": "Ordne die Spring-Annotationen ihrer Funktion zu:",
    "pairs": [
      {
        "left": "@SpringBootApplication",
        "right": "Kennzeichnet die Main-Klasse"
      },
      {
        "left": "@Component",
        "right": "Macht die Klasse zu einer Bean"
      },
      {
        "left": "@Autowired",
        "right": "Injiziert ein Bean-Objekt"
      },
      {
        "left": "@Bean",
        "right": "Definiert eine Bean-Methode"
      }
    ],
    "explanation": "@SpringBootApplication markiert die Main-Klasse, @Component macht Klassen zu Beans, @Autowired injiziert Dependencies, @Bean definiert Bean-Methoden.",
    "xp": 25,
    "tags": [
      "uebung"
    ]
  },
  {
    "difficulty": 2,
    "type": "fillblank",
    "question": "In Spring Boot wird die Konfiguration in der Datei _____ im Ordner _____ gespeichert.",
    "blanks": [
      "application.properties",
      "resources"
    ],
    "explanation": "Die Datei application.properties im Ordner resources enthält die Konfiguration für Spring Boot Anwendungen.",
    "xp": 20,
    "tags": [
      "uebung"
    ]
  },
  {
    "difficulty": 2,
    "type": "sort",
    "question": "Sortiere die Log-Level von niedrigster zu höchster Priorität:",
    "items": [
      "ERROR",
      "WARN",
      "INFO",
      "DEBUG",
      "TRACE"
    ],
    "correct": [
      "TRACE",
      "DEBUG",
      "INFO",
      "WARN",
      "ERROR"
    ],
  "explanation": "Die Log-Level von niedrigster zu höchster Priorität: TRACE (am detailliertesten) → DEBUG → INFO → WARN → ERROR (kritischste Fehler).\n✅ TRACE → DEBUG → INFO → WARN → ERROR",
    "xp": 25,
    "tags": [
      "uebung"
    ]
  },
  {
    "difficulty": 2,
    "type": "multiple",
    "question": "Was ist Maven?",
    "options": [
      "Ein Web-Framework",
      "Eine Datenbank",
      "Eine Programmiersprache",
      "Ein Build-Management-Tool für Java-Projekte"
    ],
    "correct": 3,
    "explanation": "Maven ist ein Build-Management-Tool, das den Software-Erstellungszyklus verwaltet. Konfiguration erfolgt in pom.xml.",
    "xp": 20,
    "tags": [
      "uebung"
    ]
  },
  {
    "difficulty": 2,
    "type": "fillblank",
    "question": "Um den Log-Level für ein Package auf DEBUG zu setzen, verwendet man in application.properties: logging.level.<Packagename>=_____",
    "blanks": [
      "DEBUG"
    ],
    "explanation": "Mit logging.level.<packagename>=DEBUG wird der Log-Level für ein Package auf DEBUG gesetzt.",
    "xp": 20,
    "tags": [
      "uebung"
    ]
  },
  {
    "difficulty": 3,
    "type": "sort",
    "question": "Sortiere die Schichten der 3-Tier-Architektur von oben nach unten:",
    "items": [
      "Datenhaltungsschicht",
      "Anwendungslogik-Schicht",
      "Präsentationsschicht"
    ],
    "correct": [
      "Präsentationsschicht",
      "Anwendungslogik-Schicht",
      "Datenhaltungsschicht"
    ],
  "explanation": "3-Tier-Architektur von oben: Präsentationsschicht (UI) → Anwendungslogik (Business Logic) → Datenhaltung (Datenbank).\n✅ Präsentationsschicht → Anwendungslogik-Schicht → Datenhaltungsschicht",
    "xp": 30,
    "tags": [
      "uebung"
    ]
  },
  {
    "difficulty": 3,
    "type": "matching",
    "question": "Ordne die REST-Prinzipien ihrer Beschreibung zu:",
    "pairs": [
      {
        "left": "Stateless",
        "right": "Zustandslosigkeit der Anfragen"
      },
      {
        "left": "Cacheability",
        "right": "Responses können gecacht werden"
      },
      {
        "left": "Uniform Interface",
        "right": "Einheitliche Schnittstelle"
      },
      {
        "left": "HATEOAS",
        "right": "Links zu verwandten Ressourcen"
      }
    ],
    "explanation": "REST-Prinzipien: Stateless (zustandslos), Cacheability (cachebar), Uniform Interface (einheitlich), HATEOAS (Hypermedia as Engine of Application State).",
    "xp": 35,
    "tags": [
      "uebung"
    ]
  },
  {
    "difficulty": 3,
    "type": "checkbox",
    "question": "Welche HTTP-Methoden sind 'safe' (sicher)? (Mehrfachauswahl)",
    "options": [
      "POST",
      "GET",
      "PUT",
      "HEAD",
      "DELETE"
    ],
    "correct": [
      1,
      3
    ],
    "explanation": "Safe (sicher) sind nur GET und HEAD - sie ändern keine Daten auf dem Server. POST, PUT und DELETE ändern Daten.",
    "xp": 30,
    "tags": [
      "uebung"
    ]
  },
  {
    "difficulty": 3,
    "type": "fillblank",
    "question": "Die Annotation _____ kennzeichnet Test-Methoden in JUnit, während _____ die Test-Klasse für Spring Boot markiert.",
    "blanks": [
      "@Test",
      "@SpringBootTest"
    ],
    "explanation": "@Test markiert einzelne Test-Methoden, @SpringBootTest kennzeichnet die Test-Klasse für Spring Boot.",
    "xp": 30,
    "tags": [
      "uebung"
    ]
  },
  {
    "difficulty": 3,
    "type": "multiple",
    "question": "Was passiert, wenn die @Autowired Annotation entfernt wird?",
    "options": [
      "Das Programm läuft schneller",
      "Die Bean wird nicht injiziert und es gibt eine NullPointerException",
      "Die Bean wird automatisch erstellt",
      "Das Programm kompiliert nicht"
    ],
    "correct": 1,
    "explanation": "Ohne @Autowired wird das Bean-Objekt nicht injiziert und bleibt null, was zu einer NullPointerException führt, wenn darauf zugegriffen wird.",
    "xp": 30,
    "tags": [
      "uebung"
    ]
  },
  {
    "difficulty": 3,
    "type": "multiple",
    "question": "Welche Operationen unterstützt GraphQL?",
    "options": [
      "SELECT, INSERT, UPDATE, DELETE",
      "GET, POST, PUT, DELETE",
      "Query, Mutation, Subscription",
      "READ, WRITE, UPDATE"
    ],
    "correct": 2,
    "explanation": "GraphQL unterstützt: Query (Abfragen), Mutation (Änderungen), Subscription (Echtzeit-Updates).",
    "xp": 30,
    "tags": [
      "uebung"
    ]
  },
  {
    "difficulty": 4,
    "type": "matching",
    "question": "Ordne die Komponenten des MVC-Patterns ihrer Rolle zu:",
    "pairs": [
      {
        "left": "Model",
        "right": "Datenmodell und Geschäftslogik"
      },
      {
        "left": "View",
        "right": "Darstellung der Benutzeroberfläche"
      },
      {
        "left": "Controller",
        "right": "Steuerung und Vermittlung"
      },
      {
        "left": "@RequestMapping",
        "right": "Verknüpfung von URLs mit Methoden"
      }
    ],
    "explanation": "MVC: Model (Daten/Logik), View (UI), Controller (Steuerung). @RequestMapping verbindet HTTP-Requests mit Handler-Methoden.",
    "xp": 40,
    "tags": [
      "uebung"
    ]
  },
  {
    "difficulty": 4,
    "type": "sort",
    "question": "Sortiere den Maven Build-Zyklus in der richtigen Reihenfolge:",
    "items": [
      "Installation",
      "Validierung",
      "Verifizierung",
      "Kompilierung",
      "Testen",
      "Paketieren"
    ],
    "correct": [
      "Validierung",
      "Kompilierung",
      "Testen",
      "Paketieren",
      "Verifizierung",
      "Installation"
    ],
  "explanation": "Maven Build-Zyklus: Validierung → Kompilierung → Testen → Paketieren → Verifizierung → Installation (Items-Reihenfolge; Integrationstests & Verteilung sind optionale weitere Phasen).\n✅ Validierung → Kompilierung → Testen → Paketieren → Verifizierung → Installation",
    "xp": 40,
    "tags": [
      "uebung"
    ]
  },
  {
    "difficulty": 2,
    "type": "multiple",
    "question": "Wo wird in einer Maven-basierten Spring-Boot-Anwendung die Spring Boot Version üblicherweise festgelegt?",
    "options": [
      "Im <dependencies>-Block der pom.xml",
      "Im <parent>-Tag der pom.xml mit artifactId 'spring-boot-starter-parent'",
      "In der application.properties",
      "In der Klasse mit @SpringBootApplication"
    ],
    "correct": 1,
    "explanation": "In Maven-Projekten wird die Spring Boot Version über den <parent>-Eintrag mit artifactId 'spring-boot-starter-parent' definiert. Die Version vererbt sich dann auf die Starter-Abhängigkeiten.",
    "xp": 20,
    "tags": [
      "uebung"
    ]
  },
  {
    "difficulty": 4,
    "type": "checkbox",
    "question": "Welche Eigenschaften hat Spring Boot? (Mehrfachauswahl)",
    "options": [
      "Benötigt externe War-Dateien",
      "Eingebettete Container (Tomcat, Jetty)",
      "Automatische Konfiguration soweit möglich",
      "Generierung von Code und Konfiguration",
      "Keine externen Laufzeitabhängigkeiten"
    ],
    "correct": [
      1,
      2,
      4
    ],
    "explanation": "Spring Boot: eingebettete Container, automatische Konfiguration, keine externen Laufzeitabhängigkeiten, KEINE War-Dateien nötig, KEINE Code-Generierung.",
    "xp": 40,
    "tags": [
      "uebung"
    ]
  },
  {
    "difficulty": 4,
    "type": "multiple",
    "question": "Welches Protokoll nutzt gRPC als Transportprotokoll und zu welcher OSI-Schicht gehört es?",
    "options": [
      "WebSocket, Schicht 6",
      "TCP, Schicht 4",
      "HTTP/2, Schicht 7",
      "HTTP/1.1, Schicht 7"
    ],
    "correct": 2,
    "explanation": "gRPC nutzt HTTP/2 als Transportprotokoll, welches zur OSI-Schicht 7 (Anwendungsschicht) gehört.",
    "xp": 40,
    "tags": [
      "uebung"
    ]
  },
  {
    "difficulty": 4,
    "type": "text",
    "question": "Was ist das besondere Feature von gRPC im Vergleich zu REST und GraphQL?",
    "correct": [
      "bidirektionales streaming",
      "bidirectional streaming",
      "streaming"
    ],
    "explanation": "gRPC unterstützt bidirektionales Streaming in verschiedenen Formen: Unary, Server-Streaming, Client-Streaming, Bidirectional-Streaming.",
    "xp": 40,
    "tags": [
      "uebung"
    ]
  },
  {
    "difficulty": 4,
    "type": "fillblank",
    "question": "Eine SPA (Single Page Application) lädt Inhalte dynamisch per _____ nach, ohne die Seite neu zu _____.",
    "blanks": [
      "ajax",
      "laden"
    ],
    "explanation": "Bei einer SPA läuft die Anwendung auf einer HTML-Seite. Inhalte werden dynamisch per AJAX nachgeladen, ohne Seitenneuladung.",
    "xp": 40,
    "tags": [
      "uebung"
    ]
  },
  {
    "difficulty": 4,
    "type": "checkbox",
    "question": "Welche sind serverseitige Technologien? (Mehrfachauswahl)",
    "options": [
      "JavaScript (Client)",
      "PHP",
      "Java Servlets",
      "CSS",
      "Node.js"
    ],
    "correct": [
      1,
      2,
      4
    ],
    "explanation": "Serverseitige Technologien: PHP, Java Servlets, Node.js, Python (Django), Ruby on Rails. JavaScript und CSS laufen primär clientseitig.",
    "xp": 40,
    "tags": [
      "uebung"
    ]
  },
  {
    "difficulty": 4,
    "type": "matching",
    "question": "Ordne die URL-Bestandteile dem Beispiel zu: http://fb2.fra-uas.de:8080/ebis/urls.html?prof=lehmann",
    "pairs": [
      {
        "left": "Scheme",
        "right": "http://"
      },
      {
        "left": "Hostname",
        "right": "fb2.fra-uas.de"
      },
      {
        "left": "Port",
        "right": ":8080"
      },
      {
        "left": "Query",
        "right": "?prof=lehmann"
      }
    ],
    "explanation": "URL-Struktur: Scheme (Protokoll) → Hostname (Domain) → Port → Path (Pfad) → Query (Parameter).",
    "xp": 45,
    "tags": [
      "uebung"
    ]
  },
  {
    "difficulty": 4,
    "type": "multiple",
    "question": "Wofür steht die Abkürzung PHP (rekursives Akronym)?",
    "options": [
      "Personal Home Page",
      "Private Hypertext Processor",
      "PHP: Hypertext Preprocessor",
      "Public HTML Protocol"
    ],
    "correct": 2,
    "explanation": "PHP steht für 'PHP: Hypertext Preprocessor' - ein rekursives Akronym. PHP ist eine serverseitige Skriptsprache.",
    "xp": 40,
    "tags": [
      "uebung"
    ]
  },
  {
    "difficulty": 3,
    "type": "multiple",
    "question": "Die Methode assertThat() wird nicht von JUnit nativ bereitgestellt.",
    "options": [
      "Wahr",
      "Falsch"
    ],
    "correct": 0,
    "explanation": "assertThat() stammt aus Bibliotheken wie AssertJ oder Hamcrest, nicht aus JUnit selbst.",
    "xp": 30,
    "tags": [
      "uebung",
      "neue-vorlesung",
      "offiziell"
    ]
  },
  {
    "difficulty": 4,
    "type": "multiple",
    "question": "Mit Maven können Abhängigkeiten eines Projekts automatisch aufgelöst werden.",
    "options": [
      "Wahr",
      "Falsch"
    ],
    "correct": 0,
    "explanation": "Maven löst Abhängigkeiten automatisch über die pom.xml auf und lädt sie aus Repositories herunter.",
    "xp": 40,
    "tags": [
      "uebung",
      "neue-vorlesung",
      "offiziell"
    ]
  },
  {
    "difficulty": 1,
    "type": "multiple",
    "question": "Wohin schreibt Spring Boot Logs standardmäßig ohne zusätzliche Konfiguration?",
    "options": [
      "In die Konsole (Standard Output)",
      "In eine Datei namens 'application.log'",
      "In eine Datenbank",
      "In das Windows Event Log"
    ],
    "correct": 0,
    "explanation": "Standardmäßig schreibt Spring Boot alle Logs in die Konsole (Standard Output). Für andere Ziele ist zusätzliche Konfiguration nötig.",
    "xp": 10,
    "tags": [
      "uebung"
    ]
  },
  {
    "difficulty": 1,
    "type": "checkbox",
    "question": "Welche Log-Level sind in Spring Boot standardmäßig verfügbar? (Mehrfachauswahl)",
    "options": [
      "ERROR",
      "WARN",
      "INFO",
      "DEBUG",
      "TRACE"
    ],
    "correct": [
      0,
      1,
      2,
      3,
      4
    ],
    "explanation": "Spring Boot unterstützt die Standard-Log-Level: ERROR (kritisch), WARN (Warnungen), INFO (Information), DEBUG (Entwicklung) und TRACE (detailliert).",
    "xp": 15,
    "tags": [
      "uebung"
    ]
  },
  {
    "difficulty": 1,
    "type": "multiple",
    "question": "Was ist das grundlegende Schema für User Stories?",
    "options": [
      "Als <Rolle> möchte ich <Ziel>, damit <Nutzen>",
      "Wenn <Bedingung> dann <Aktion>",
      "Gegeben <Zustand> wenn <Ereignis> dann <Ergebnis>",
      "Falls <Problem> soll <Lösung> implementiert werden"
    ],
    "correct": 0,
    "explanation": "User Stories folgen dem Schema: 'Als <Rolle> möchte ich <Ziel>, damit <Nutzen>'. Dies macht Anforderungen verständlich und nutzerorientiert.",
    "xp": 10,
    "tags": [
      "uebung"
    ]
  },
  {
    "difficulty": 2,
    "type": "matching",
    "question": "Ordne die Logging-Properties ihren Effekten zu:",
    "pairs": [
      {
        "left": "logging.file",
        "right": "Definiert eine spezifische Log-Datei"
      },
      {
        "left": "logging.path",
        "right": "Setzt das Verzeichnis für Log-Dateien"
      },
      {
        "left": "logging.level.*",
        "right": "Konfiguriert Log-Level für Packages"
      },
      {
        "left": "logging.pattern.console",
        "right": "Bestimmt das Format der Konsolenausgabe"
      }
    ],
    "explanation": "Die verschiedenen Logging-Properties steuern unterschiedliche Aspekte: Dateien, Pfade, Level und Ausgabeformat.",
    "xp": 25,
    "tags": [
      "uebung"
    ]
  },
  {
    "difficulty": 2,
    "type": "multiple",
    "question": "Was bewirkt logging.level.edu.fra.uas=debug in der Konfiguration?",
    "options": [
      "Setzt DEBUG-Level für das spezifische Package und Unterpackages",
      "Aktiviert Debugging für die gesamte Anwendung",
      "Loggt nur Fehler aus dem edu.fra.uas Package",
      "Deaktiviert Logging für andere Packages"
    ],
    "correct": 0,
    "explanation": "Diese Einstellung setzt das Log-Level DEBUG für das Package edu.fra.uas und alle seine Unterpackages. Andere Packages bleiben unberührt.",
    "xp": 20,
    "tags": [
      "uebung"
    ]
  },
  {
    "difficulty": 3,
    "type": "checkbox",
    "question": "Welche Vorteile bietet strukturiertes Logging (SLF4J/Logback) gegenüber System.out.println in Spring Boot? (Mehrfachauswahl)",
    "options": [
      "Konfigurierbare Log-Level und Filter",
      "Performance durch asynchrones Logging",
      "Standardisierte Formatierung",
      "Integration mit Spring Boot Actuator",
      "Automatische Dateirotation"
    ],
    "correct": [
      0,
      1,
      2,
      3,
      4
    ],
    "explanation": "Strukturiertes Logging bietet viele Vorteile: konfigurierbare Level, bessere Performance, einheitliche Formate, Monitoring-Integration und Dateiverwaltung.",
    "xp": 30,
    "tags": [
      "uebung"
    ]
  },
  {
    "difficulty": 3,
    "type": "multiple",
    "question": "Was passiert, wenn @Autowired an einer Feldstelle entfernt wird?",
    "options": [
      "Das Feld bleibt null und führt zu NullPointerException bei Verwendung",
      "Spring erstellt automatisch eine neue Instanz",
      "Die Anwendung startet nicht",
      "Es wird eine Warnung ausgegeben"
    ],
    "correct": 0,
    "explanation": "Ohne @Autowired erfolgt keine Dependency Injection. Das Feld bleibt null, was bei Verwendung zu einer NullPointerException führt.",
    "xp": 30,
    "tags": [
      "uebung"
    ]
  },
  {
    "difficulty": 4,
    "type": "matching",
    "question": "Ordne die Test-Konzepte ihren Haupteigenschaften zu:",
    "pairs": [
      {
        "left": "@SpringBootTest",
        "right": "Lädt den vollständigen Application Context"
      },
      {
        "left": "AssertJ",
        "right": "Bietet fluent assertions und bessere Fehlermeldungen"
      },
      {
        "left": "Slice Tests",
        "right": "Testet nur spezifische Schichten der Anwendung"
      },
      {
        "left": "Unit Tests",
        "right": "Testet isolierte Komponenten ohne Spring Context"
      }
    ],
    "explanation": "@SpringBootTest ist für Integrationstests mit vollem Context, AssertJ verbessert die Testlesbarkeit, Slice Tests fokussieren einzelne Schichten, Unit Tests sind am schnellsten.",
    "xp": 40,
    "tags": [
      "uebung"
    ]
  },
  {
    "difficulty": 4,
    "type": "multiple",
    "question": "Welche Funktion hat der <parent>-Eintrag in der pom.xml bei Spring Boot?",
    "options": [
      "Definiert Versionen, Dependencies und Plugins durch Vererbung",
      "Ist nur für Multi-Modul-Projekte erforderlich",
      "Dient ausschließlich der Dokumentation",
      "Wird nur für Test-Konfigurationen verwendet"
    ],
    "correct": 0,
    "explanation": "Der <parent>-Eintrag ermöglicht die Vererbung von Versionen, Dependencies und Plugin-Konfigurationen vom Spring Boot Parent POM, was die Projektkonfiguration vereinfacht.",
    "xp": 40,
    "tags": [
      "uebung"
    ]
  },
  {
    "difficulty": 4,
    "type": "checkbox",
    "question": "Was sind die Besonderheiten eines CommandLineRunner als @Bean? (Mehrfachauswahl)",
    "options": [
      "Wird nach Kontext-Initialisierung ausgeführt",
      "Kann mehrfach im Projekt definiert werden",
      "Hat Zugriff auf andere Beans",
      "Ermöglicht Start-up Logik",
      "Unterstützt Ordering mit @Order"
    ],
    "correct": [
      0,
      1,
      2,
      3,
      4
    ],
    "explanation": "CommandLineRunner als @Bean: läuft nach Kontext-Start, mehrfache Definition möglich, hat Bean-Zugriff, ideal für Start-up Logik, unterstützt Reihenfolge via @Order.",
    "xp": 45,
    "tags": [
      "uebung"
    ]
  },
  {
    "difficulty": 1,
    "type": "multiple",
    "question": "Was ist eine Bean im Spring-Container?",
    "options": [
      "Ein Java-Objekt, das von Spring verwaltet wird",
      "Eine Datenbankverbindung",
      "Ein UI-Element",
      "Eine Konfigurationsdatei"
    ],
    "correct": 0,
    "explanation": "Eine Bean ist ein Java-Objekt, das vom Spring Container verwaltet wird - inklusive Erstellung, Konfiguration und Lebenszyklus-Management.",
    "xp": 10,
    "tags": [
      "uebung"
    ]
  },
  {
    "difficulty": 1,
    "type": "multiple",
    "question": "Welches Log-Level zeigt die wichtigsten Fehler an?",
    "options": [
      "DEBUG",
      "INFO",
      "ERROR",
      "TRACE"
    ],
    "correct": 2,
    "explanation": "ERROR ist das Log-Level für die kritischsten Fehlermeldungen. Es zeigt schwerwiegende Probleme an, die sofortige Aufmerksamkeit erfordern.",
    "xp": 10,
    "tags": [
      "uebung"
    ]
  },
  {
    "difficulty": 1,
    "type": "multiple",
    "question": "Was ist ein Fork in GitHub?",
    "options": [
      "Eine Kopie eines Repositories unter deinem eigenen Account",
      "Ein Branch in einem Repository",
      "Ein Pull Request",
      "Ein Commit in der Historie"
    ],
    "correct": 0,
    "explanation": "Ein Fork ist eine persönliche Kopie eines fremden Repositories unter deinem GitHub-Account. Dies ermöglicht es dir, Änderungen vorzunehmen, ohne das Original zu beeinflussen.",
    "xp": 10,
    "tags": [
      "uebung",
      "neue-vorlesung",
      "offiziell"
    ]
  },
  {
    "difficulty": 2,
    "type": "matching",
    "question": "Ordne die Log-Level ihrer typischen Verwendung zu:",
    "pairs": [
      {
        "left": "ERROR",
        "right": "Kritische Fehler, die sofortige Aktion erfordern"
      },
      {
        "left": "WARN",
        "right": "Potenziell schädliche Situationen"
      },
      {
        "left": "INFO",
        "right": "Wichtige Geschäftsereignisse"
      },
      {
        "left": "DEBUG",
        "right": "Detaillierte Entwicklerinformationen"
      }
    ],
    "explanation": "Die Log-Level haben unterschiedliche Prioritäten und Verwendungszwecke: ERROR für kritische Fehler, WARN für Warnungen, INFO für wichtige Events, DEBUG für Entwicklerdetails.",
    "xp": 25,
    "tags": [
      "uebung"
    ]
  },
  {
    "difficulty": 2,
    "type": "checkbox",
    "question": "Welche Vorteile bietet strukturiertes Logging gegenüber System.out.println? (Mehrfachauswahl)",
    "options": [
      "Konfigurierbare Log-Level",
      "Bessere Filterbarkeit",
      "Mehrere Ausgabekanäle möglich",
      "Formatierte Zeitstempel",
      "Schnellere Ausführung"
    ],
    "correct": [
      0,
      1,
      2,
      3
    ],
    "explanation": "Strukturiertes Logging bietet viele Vorteile: konfigurierbare Level, Filterbarkeit, multiple Ausgabekanäle und automatische Zeitstempel. Die Ausführungsgeschwindigkeit ist nicht primär relevant.",
    "xp": 20,
    "tags": [
      "uebung"
    ]
  },
  {
    "difficulty": 2,
    "type": "multiple",
    "question": "Was ist die Hauptaufgabe des CommandLineRunner in Spring Boot?",
    "options": [
      "Datenbankverbindungen aufbauen",
      "Code beim Anwendungsstart ausführen",
      "REST-Endpunkte definieren",
      "Logging konfigurieren"
    ],
    "correct": 1,
    "explanation": "CommandLineRunner ist ein Interface, dessen run()-Methode nach der Initialisierung der Spring Boot App ausgeführt wird. Es eignet sich für Initialisierungscode beim Start.",
    "xp": 20,
    "tags": [
      "uebung"
    ]
  },
  {
    "difficulty": 3,
    "type": "multiple",
    "question": "Was bedeutet 'Inversion of Control' im Spring-Kontext?",
    "options": [
      "Die Umkehrung der Programmflusssteuerung",
      "Das manuelle Erstellen von Objekten",
      "Die direkte Objektreferenzierung",
      "Die Verwendung von statischen Methoden"
    ],
    "correct": 0,
    "explanation": "Inversion of Control bedeutet, dass die Kontrolle über Objekterstellung und -verwaltung an den Spring Container übertragen wird, statt sie selbst zu implementieren.",
    "xp": 30,
    "tags": [
      "uebung"
    ]
  },
  {
    "difficulty": 3,
    "type": "checkbox",
    "question": "Welche Aussagen über Konstruktor-Injektion sind korrekt? (Mehrfachauswahl)",
    "options": [
      "Garantiert vollständige Initialisierung",
      "Unterstützt Immutability",
      "Macht Abhängigkeiten explizit",
      "Ist flexibler als Setter-Injektion",
      "Erfordert weniger Code als Feld-Injektion"
    ],
    "correct": [
      0,
      1,
      2
    ],
    "explanation": "Konstruktor-Injektion wird bevorzugt, weil sie vollständige Initialisierung garantiert, Immutability ermöglicht und Abhängigkeiten explizit macht. Sie ist nicht flexibler und erfordert mehr Code.",
    "xp": 30,
    "tags": [
      "uebung"
    ]
  },
  {
    "difficulty": 3,
    "type": "matching",
    "question": "Ordne die Spring-Annotationen ihrer Hauptfunktion zu:",
    "pairs": [
      {
        "left": "@SpringBootApplication",
        "right": "Kombiniert mehrere Basis-Annotationen"
      },
      {
        "left": "@Component",
        "right": "Markiert Klasse als Spring-verwaltete Komponente"
      },
      {
        "left": "@Bean",
        "right": "Definiert Methode zur Bean-Erstellung"
      },
      {
        "left": "@Autowired",
        "right": "Injiziert Abhängigkeiten"
      }
    ],
    "explanation": "Die Annotationen haben unterschiedliche Zwecke: @SpringBootApplication für App-Konfiguration, @Component für Komponenten-Scanning, @Bean für explizite Bean-Definition, @Autowired für Dependency Injection.",
    "xp": 35,
    "tags": [
      "uebung"
    ]
  },
  {
    "difficulty": 4,
    "type": "checkbox",
    "question": "Welche Konzepte sind Teil der Spring Boot Auto-Konfiguration? (Mehrfachauswahl)",
    "options": [
      "Konvention vor Konfiguration",
      "Bedingte Bean-Registrierung",
      "Static Injection",
      "Field Injection",
      "Setter Injection",
      "Constructor Injection"
    ],
    "correct": 0,
    "explanation": "'Static Injection' ist kein gängiges DI-Verfahren in Spring; empfohlen ist i. d. R. Constructor Injection.",
    "xp": 15,
    "tags": [
      "offiziell",
      "woche3"
    ]
  },
  {
    "difficulty": 1,
    "type": "multiple",
    "question": "Das Hollywood-Prinzip (IoC) in Spring bedeutet, dass der Container den Objekten mitteilt, wann und wie sie aufgerufen werden.",
    "options": [
      "Wahr",
      "Falsch"
    ],
    "correct": 0,
    "explanation": "Richtig. 'Don't call us, we'll call you' – der Container steuert den Ablauf und ruft unseren Code auf.",
    "xp": 10,
    "tags": [
      "offiziell",
      "woche3"
    ]
  },
  {
    "difficulty": 1,
    "type": "multiple",
    "question": "Was ist ein Vorteil des Prototype-Scopes? (Variante)",
    "options": [
      "Beans können verschiedene Zustände speichern",
      "Beans sollten immer Singletons sein"
    ],
    "correct": 0,
    "explanation": "Auch hier: Prototype erlaubt je Instanz eigenen Zustand; sinnvoll bei zustandstragenden Objekten.",
    "xp": 10,
    "tags": [
      "offiziell",
      "woche3"
    ]
  },
  {
    "difficulty": 1,
    "type": "multiple",
    "question": "Wie wird eine Methode für die Initialisierung einer Bean gekennzeichnet?",
    "options": [
      "@InitBean",
      "@PreDestroy",
      "@PostConstruct",
      "@PostStart"
    ],
    "correct": 2,
    "explanation": "@PostConstruct markiert eine Methode, die nach der Konstruktion/Injection für Initialisierungscode ausgeführt wird.",
    "xp": 10,
    "tags": [
      "offiziell",
      "woche3"
    ]
  },
  {
    "difficulty": 1,
    "type": "multiple",
    "question": "Dependency Injection führt zu einer stärkeren Kopplung der Komponenten.",
    "options": [
      "Wahr",
      "Falsch"
    ],
    "correct": 1,
    "explanation": "Falsch. DI reduziert die Kopplung, da Abhängigkeiten von außen bereitgestellt werden und austauschbar sind.",
    "xp": 10,
    "tags": [
      "offiziell",
      "woche3"
    ]
  },
  {
    "difficulty": 2,
    "type": "multiple",
    "question": "Welches Problem kann auftreten, wenn mehrere Implementierungen eines Interfaces existieren?",
    "options": [
      "Der IoC-Container weiß nicht, welche Implementierung zu injizieren ist",
      "Der Code wird fehlerhaft kompiliert",
      "Die Anwendung startet nicht",
      "Keine Auswirkungen"
    ],
    "correct": 0,
    "explanation": "Ohne @Qualifier oder @Primary ist unklar, welche Bean injiziert werden soll – es kommt zu einem Startfehler.",
    "xp": 15,
    "tags": [
      "offiziell",
      "woche3"
    ]
  },
  {
    "difficulty": 1,
    "type": "multiple",
    "question": "Die Annotation @Service dient ausschließlich zum Injizieren von Datenbankobjekten.",
    "options": [
      "Wahr",
      "Falsch"
    ],
    "correct": 1,
    "explanation": "Falsch. @Service markiert Service-Klassen; Datenzugriff gehört typischerweise zu @Repository.",
    "xp": 10,
    "tags": [
      "offiziell",
      "woche3"
    ]
  },
  {
    "difficulty": 2,
    "type": "multiple",
    "question": "Was ist der Unterschied zwischen @Configuration und @Component?",
    "options": [
      "@Configuration markiert REST-Controller, @Component Daten-Repositories",
      "@Configuration ist veraltet, @Component ist aktuell",
      "@Configuration enthält @Bean-Methoden für spezifische Beans",
      "Es gibt keinen Unterschied – vollständig identisch"
    ],
    "correct": 2,
    "explanation": "@Configuration-Klassen definieren Beans explizit über @Bean-Methoden; @Component kennzeichnet allgemeine Komponenten für den Component-Scan.",
    "xp": 20,
    "tags": [
      "offiziell",
      "woche3"
    ]
  },
  {
    "difficulty": 1,
    "type": "multiple",
    "question": "Der ApplicationContext baut auf der BeanFactory auf.",
    "options": [
      "Wahr",
      "Falsch"
    ],
    "correct": 0,
    "explanation": "Richtig. ApplicationContext erweitert BeanFactory um u. a. Internationalisierung, Ereignisse, AOP-Integration.",
    "xp": 10,
    "tags": [
      "offiziell",
      "woche3"
    ]
  },
  {
    "difficulty": 1,
    "type": "multiple",
    "question": "Der IoC-Container ist für den Lebenszyklus der Beans verantwortlich.",
    "options": [
      "Wahr",
      "Falsch"
    ],
    "correct": 0,
    "explanation": "Richtig. Der Container steuert Lebenszyklus-Hooks wie @PostConstruct und @PreDestroy und verwaltet Beans insgesamt.",
    "xp": 10,
    "tags": [
      "offiziell",
      "woche3"
    ]
  }
  ,
  {
    "difficulty": 2,
    "type": "matching",
    "question": "Ordnen Sie die Arten des ApplicationContext den passenden Beschreibungen zu:",
    "pairs": [
      { "left": "AnnotationConfigApplicationContext", "right": "verwendet Annotationen, um Komponenten als Beans zu registrieren" },
      { "left": "FileSystemXmlApplicationContext", "right": "Beans werden durch eine XML-Datei registriert, die über eine URL zugänglich ist" },
      { "left": "ClassPathXmlApplicationContext", "right": "verwendet XML-Dateien im Classpath, um Beans zu registrieren" }
    ],
    "explanation": "Die verschiedenen ApplicationContext-Typen unterscheiden sich in der Art, wie und woher sie Beans laden: Annotationen, XML im Dateisystem oder XML im Classpath.",
    "xp": 20,
    "tags": ["offiziell", "woche3"]
  },
  {
    "difficulty": 2,
    "type": "checkbox",
    "question": "Welche Methoden kennzeichnen den Lebenszyklus von Beans? (Mehrfachauswahl)",
    "options": ["@PostConstruct", "@PreDestroy", "@Bean", "@Autowired"],
    "correct": [0,1],
    "explanation": "@PostConstruct und @PreDestroy markieren Methoden, die beim Initialisieren bzw. vor der Zerstörung einer Bean ausgeführt werden.",
    "xp": 15,
    "tags": ["offiziell", "woche3"]
  },
  {
    "difficulty": 2,
    "type": "multiple",
    "question": "Im Spring IoC Container wird die Zerstörung einer Bean unmittelbar nach der Bean-Initialisierung automatisch ausgelöst, es sei denn, die Bean wird explizit durch den Entwickler zur Zerstörung freigegeben.",
    "options": [
      "Wahr",
      "Falsch"
    ],
    "correct": 0,
    "explanation": "Wahr. Beans durchlaufen einen definierten Lebenszyklus: Instanziierung → Dependency Injection → Initialisierung (@PostConstruct) → Nutzung → Zerstörung (@PreDestroy). Die Zerstörung erfolgt beim Container-Shutdown, es sei denn, der Entwickler steuert dies explizit.",
    "xp": 20,
    "tags": ["offiziell", "woche3"]
  },
  {
    "difficulty": 1,
    "type": "multiple",
    "question": "Der ApplicationContext erweitert nicht die Funktionalität der BeanFactory.",
    "options": [
      "Wahr",
      "Falsch"
    ],
    "correct": 1,
    "explanation": "Falsch. Der ApplicationContext erweitert die BeanFactory um zusätzliche Enterprise-Features wie Internationalisierung, Event-Handling, AOP-Integration und deklarative Mechanismen.",
    "xp": 10,
    "tags": ["offiziell", "woche3"]
  },
  {
    "difficulty": 1,
    "type": "multiple",
    "question": "Der Model-Teil im MVC hält die Daten der Anwendung, die View generiert die Darstellung, der Controller verarbeitet eingehende HTTP-Requests.",
    "options": ["Wahr", "Falsch"],
    "correct": 0,
    "explanation": "Wahr. MVC trennt die Anwendung in Model (Daten/Geschäftslogik), View (Darstellung) und Controller (Request-Verarbeitung und Steuerung).",
    "xp": 10,
    "tags": ["uebung", "gemischt", "woche4"]
  },
  {
    "difficulty": 2,
    "type": "multiple",
    "question": "Welche Rolle leitet Model-Objekte an die View weiter?",
    "options": ["Model", "View", "Controller", "Template Engine"],
    "correct": 2,
    "explanation": "Der Controller verarbeitet Requests, füllt das Model mit Daten und gibt es an die View weiter zur Darstellung.",
    "xp": 15,
    "tags": ["uebung", "gemischt", "woche4"]
  },
  {
    "difficulty": 1,
    "type": "multiple",
    "question": "Ziel des MVC-Patterns ist eine möglichst große Unabhängigkeit der Softwarekomponenten.",
    "options": ["Wahr", "Falsch"],
    "correct": 0,
    "explanation": "Wahr. MVC trennt Darstellung, Logik und Daten, um die Komponenten voneinander unabhängig zu machen und die Wartbarkeit zu erhöhen.",
    "xp": 10,
    "tags": ["uebung", "gemischt", "woche4"]
  },
  {
    "difficulty": 1,
    "type": "multiple",
    "question": "In der Beispielstruktur liegen Controller-Klassen in welchem Ordner?",
    "options": ["/service", "/controller", "/repository", "/config"],
    "correct": 1,
    "explanation": "Controller-Klassen befinden sich konventionsgemäß im /controller-Ordner der Package-Struktur.",
    "xp": 10,
    "tags": ["uebung", "gemischt", "woche4"]
  },
  {
    "difficulty": 2,
    "type": "multiple",
    "question": "Welche Aussage zu Entity-/Model-Klassen trifft zu?",
    "options": [
      "Müssen ein Spring-Interface implementieren",
      "Müssen von einer Spring-Basisklasse erben",
      "Benötigen nur einen Default-Konstruktor",
      "Dürfen keine Felder besitzen"
    ],
    "correct": 2,
    "explanation": "Entity-/Model-Klassen benötigen einen parameterlosen Default-Konstruktor für die Instanziierung durch Frameworks. Sie müssen keine Spring-spezifischen Interfaces implementieren.",
    "xp": 15,
    "tags": ["uebung", "gemischt", "woche4"]
  },
  {
    "difficulty": 1,
    "type": "multiple",
    "question": "Das Beispiel-Repository erweitert lediglich eine HashMap als Speicher.",
    "options": ["Wahr", "Falsch"],
    "correct": 0,
    "explanation": "Wahr. In einfachen Beispielen wird oft eine HashMap als In-Memory-Speicher verwendet, bevor eine echte Datenbank angebunden wird.",
    "xp": 10,
    "tags": ["uebung", "gemischt", "woche4"]
  },
  {
    "difficulty": 2,
    "type": "multiple",
    "question": "Wofür steht der Ordner /config im Beispielprojekt?",
    "options": [
      "Thymeleaf-Vorlagen",
      "Initiale Datenkonfiguration (InitData)",
      "Statische Ressourcen",
      "Datenbankmigrationen"
    ],
    "correct": 1,
    "explanation": "Der /config-Ordner enthält Konfigurationsklassen wie InitData für die initiale Dateninitialisierung beim Anwendungsstart.",
    "xp": 15,
    "tags": ["uebung", "gemischt", "woche4"]
  },
  {
    "difficulty": 1,
    "type": "multiple",
    "question": "Welche Annotation macht eine Klasse zum Web-Controller?",
    "options": ["@Service", "@Controller", "@Repository", "@RestClient"],
    "correct": 1,
    "explanation": "@Controller markiert eine Klasse als Spring MVC Controller, der HTTP-Requests verarbeitet und Views zurückgibt.",
    "xp": 10,
    "tags": ["uebung", "gemischt", "woche4"]
  },
  {
    "difficulty": 2,
    "type": "multiple",
    "question": "Welche Mapping-Annotation wird im Beispiel für GET auf '/add' verwendet?",
    "options": [
      "@Get",
      "@GetMapping(\"/add\")",
      "@RequestMapping(value={\"/add\"}, method=GET)",
      "@Route(\"/add\")"
    ],
    "correct": 2,
    "explanation": "@RequestMapping mit method=GET ist die klassische Form. @GetMapping ist eine kürzere Alternative für GET-Requests.",
    "xp": 15,
    "tags": ["uebung", "gemischt", "woche4"]
  },
  {
    "difficulty": 2,
    "type": "multiple",
    "question": "Der HandlerMapping bestimmt anhand der URL den passenden Controller und die Methode.",
    "options": ["Wahr", "Falsch"],
    "correct": 0,
    "explanation": "Wahr. Das HandlerMapping ist für das URL-Routing zuständig und findet die passende Controller-Methode für einen Request.",
    "xp": 15,
    "tags": ["uebung", "gemischt", "woche4"]
  },
  {
    "difficulty": 2,
    "type": "multiple",
    "question": "Welche Klasse verarbeitet eingehende Requests zentral?",
    "options": ["ViewResolver", "DispatcherServlet", "ResourceHandler", "ModelFactory"],
    "correct": 1,
    "explanation": "Das DispatcherServlet ist das zentrale Front-Controller-Servlet, das alle Requests empfängt und an die passenden Handler weiterleitet.",
    "xp": 15,
    "tags": ["uebung", "gemischt", "woche4"]
  },
  {
    "difficulty": 2,
    "type": "checkbox",
    "question": "Welche Schritte gehören zum Ablauf einer Request-Verarbeitung in Spring MVC? (Mehrfachauswahl)",
    "options": [
      "DispatcherServlet empfängt Request",
      "HandlerMapping findet Controller/Methode",
      "ViewResolver ermittelt Ressource",
      "Model-Daten werden in Template integriert"
    ],
    "correct": [0, 1, 2, 3],
    "explanation": "Alle vier Schritte sind Teil des Spring MVC Request-Flows: DispatcherServlet → HandlerMapping → Controller → ViewResolver → View-Rendering.",
    "xp": 20,
    "tags": ["uebung", "gemischt", "woche4"]
  },
  {
    "difficulty": 2,
    "type": "multiple",
    "question": "Welche Parameterquelle nutzt @RequestParam?",
    "options": ["Header", "Path Variable", "Query-String/Form", "Cookie"],
    "correct": 2,
    "explanation": "@RequestParam bindet Parameter aus dem Query-String (URL ?key=value) oder aus Formulardaten.",
    "xp": 15,
    "tags": ["uebung", "gemischt", "woche4"]
  },
  {
    "difficulty": 2,
    "type": "matching",
    "question": "Ordne URL-Bestandteile zu:",
    "pairs": [
      {"left": "Host", "right": "example.com"},
      {"left": "Pfad", "right": "/path"},
      {"left": "Query String", "right": "Teil nach '?'"},
      {"left": "Parameter/Wert", "right": "name=value"},
      {"left": "Mehrere Parameter", "right": "mit '&' verbinden"}
    ],
    "explanation": "URL-Struktur: http://host/pfad?param1=wert1&param2=wert2",
    "xp": 20,
    "tags": ["uebung", "gemischt", "woche4"]
  },
  {
    "difficulty": 1,
    "type": "multiple",
    "question": "Im Controller kann per model.addAttribute(...) ein Objekt für die View bereitgestellt werden.",
    "options": ["Wahr", "Falsch"],
    "correct": 0,
    "explanation": "Wahr. Mit model.addAttribute(key, value) fügt man Daten zum Model hinzu, die dann in der View verfügbar sind.",
    "xp": 10,
    "tags": ["uebung", "gemischt", "woche4"]
  },
  {
    "difficulty": 2,
    "type": "multiple",
    "question": "Was liefert die Beispielmethode add(...) zurück?",
    "options": [
      "Ein JSON-Objekt",
      "Den Namen einer View (z. B. 'add.html') als String",
      "Eine ResponseEntity",
      "Eine Model-Instanz"
    ],
    "correct": 1,
    "explanation": "Controller-Methoden geben typischerweise einen View-Namen als String zurück, den der ViewResolver zur entsprechenden Template-Datei auflöst.",
    "xp": 15,
    "tags": ["uebung", "gemischt", "woche4"]
  },
  {
    "difficulty": 1,
    "type": "multiple",
    "question": "Thymeleaf verarbeitet Model-Daten zur Laufzeit im Template.",
    "options": ["Wahr", "Falsch"],
    "correct": 0,
    "explanation": "Wahr. Thymeleaf ist eine serverseitige Template Engine, die zur Laufzeit Model-Daten in HTML einbettet.",
    "xp": 10,
    "tags": ["uebung", "gemischt", "woche4"]
  },
  {
    "difficulty": 2,
    "type": "multiple",
    "question": "Welches Namespace-Attribut aktiviert Thymeleaf-Attribute in HTML?",
    "options": [
      "xmlns:tl",
      "xmlns:th=\"http://www.thymeleaf.org\"",
      "xmlns:spring",
      "th:xmlns"
    ],
    "correct": 1,
    "explanation": "xmlns:th=\"http://www.thymeleaf.org\" im <html>-Tag aktiviert Thymeleaf-Syntax wie th:text, th:if etc.",
    "xp": 15,
    "tags": ["uebung", "gemischt", "woche4"]
  },
  {
    "difficulty": 1,
    "type": "multiple",
    "question": "Wo liegen dynamische HTML-Templates?",
    "options": [
      "src/main/resources/templates",
      "src/main/webapp",
      "src/main/resources/static",
      "templates/ außerhalb von resources"
    ],
    "correct": 0,
    "explanation": "Templates liegen standardmäßig in src/main/resources/templates und werden von Thymeleaf verarbeitet.",
    "xp": 10,
    "tags": ["uebung", "gemischt", "woche4"]
  },
  {
    "difficulty": 1,
    "type": "multiple",
    "question": "Wo liegen statische Ressourcen (CSS, Bilder, JS)?",
    "options": [
      "/public",
      "src/main/resources/static",
      "/templates/static",
      "/assets/root"
    ],
    "correct": 1,
    "explanation": "Statische Ressourcen wie CSS, JavaScript und Bilder liegen in src/main/resources/static.",
    "xp": 10,
    "tags": ["uebung", "gemischt", "woche4"]
  },
  {
    "difficulty": 1,
    "type": "multiple",
    "question": "Alle Ressourcen, die Spring Boot finden soll, müssen unterhalb von /resources liegen.",
    "options": ["Wahr", "Falsch"],
    "correct": 0,
    "explanation": "Wahr. Spring Boot sucht Ressourcen (Templates, statische Dateien, Properties) in src/main/resources und Unterordnern.",
    "xp": 10,
    "tags": ["uebung", "gemischt", "woche4"]
  },
  {
    "difficulty": 1,
    "type": "multiple",
    "question": "Welcher Thymeleaf-Ausdruck setzt Textinhalt aus dem Model?",
    "options": ["th:if", "th:text", "th:src", "th:class"],
    "correct": 1,
    "explanation": "th:text=\"${variable}\" setzt den Textinhalt eines HTML-Elements mit einem Wert aus dem Model.",
    "xp": 10,
    "tags": ["uebung", "gemischt", "woche4"]
  },
  {
    "difficulty": 1,
    "type": "multiple",
    "question": "Läuft eine Standard‑Spring‑Boot‑App ohne Portkonfiguration unter http://localhost:8080/?",
    "options": ["Wahr", "Falsch"],
    "correct": 0,
    "explanation": "Wahr. Spring Boot nutzt standardmäßig Port 8080, sofern kein anderer Port konfiguriert ist.",
    "xp": 10,
    "tags": ["uebung", "gemischt", "woche4"]
  },
  {
    "difficulty": 1,
    "type": "multiple",
    "question": "Welche HTTP‑Methode wird typischerweise zum Abrufen von HTML‑Seiten verwendet?",
    "options": ["POST", "GET", "PUT", "PATCH"],
    "correct": 1,
    "explanation": "GET dient dem Abruf von Ressourcen wie HTML‑Seiten, ohne deren Zustand serverseitig zu verändern.",
    "xp": 10,
    "tags": ["uebung", "gemischt", "woche4"]
  },
  {
    "difficulty": 2,
    "type": "checkbox",
    "question": "Welche Prüfungen sind sinnvoll, um eine HTML‑Antwort zu validieren? (Mehrfachauswahl)",
    "options": [
      "HTTP-Response-Status",
      "Response-Inhalt vs. list.html",
      "Cookies mit CSRF-Token",
      "Request-Headers (User-Agent)"
    ],
    "correct": [0, 1],
    "explanation": "Wichtige Prüfungen sind u. a. der Status‑Code und der Response‑Body im Vergleich zur erwarteten Vorlage (Template).",
    "xp": 20,
    "tags": ["uebung", "gemischt", "woche4"]
  },
  {
    "difficulty": 2,
    "type": "multiple",
    "question": "Welcher Pfad fügt im Beispiel einen Nutzer per GET hinzu (inkl. URL-Encoding)?",
    "options": [
      "/add?firstName=John&lastName=Doe&email=jd@gmx.de&password=abc",
      "/add?firstName=John&lastName=Doe&email=jd%40gmx.de&password=abc",
      "/add/John/Doe",
      "/user/add?json"
    ],
    "correct": 1,
    "explanation": "Das @-Zeichen wird URL-encoded als %40. Die korrekte URL ist /add?firstName=John&lastName=Doe&email=jd%40gmx.de&password=abc",
    "xp": 20,
    "tags": ["uebung", "gemischt", "woche4"]
  },
  {
    "difficulty": 1,
    "type": "multiple",
    "question": "Ein Sequenzdiagramm stellt den Nachrichtenfluss zwischen Client, Server und Komponenten dar.",
    "options": ["Wahr", "Falsch"],
    "correct": 0,
    "explanation": "Wahr. Sequenzdiagramme visualisieren den zeitlichen Ablauf von Nachrichten/Methodenaufrufen zwischen beteiligten Instanzen.",
    "xp": 10,
    "tags": ["uebung", "gemischt", "woche4"]
  },
  {
    "difficulty": 2,
    "type": "multiple",
    "question": "Was passiert bei /add?firstName=John&lastName=Doe (fehlende Parameter)?",
    "options": [
      "Success-Seite",
      "Silent-Ignore",
      "Exception, die zentral behandelt werden kann",
      "301 Redirect"
    ],
    "correct": 2,
    "explanation": "Fehlende @RequestParam-Parameter führen zu einer MissingServletRequestParameterException, die zentral behandelt werden kann.",
    "xp": 20,
    "tags": ["uebung", "gemischt", "woche4"]
  },
  {
    "difficulty": 2,
    "type": "multiple",
    "question": "@ControllerAdvice ermöglicht eine globale Exception-Behandlung für alle Controller.",
    "options": ["Wahr", "Falsch"],
    "correct": 0,
    "explanation": "Wahr. @ControllerAdvice definiert eine Klasse, die Exceptions für alle Controller zentral behandelt.",
    "xp": 15,
    "tags": ["uebung", "gemischt", "woche4"]
  },
  {
    "difficulty": 2,
    "type": "multiple",
    "question": "Welche Exception reicht die Methode add(...) bei fehlenden Parametern weiter?",
    "options": [
      "MethodArgumentNotValidException",
      "MissingServletRequestParameterException",
      "HttpMessageNotReadableException",
      "IllegalArgumentException"
    ],
    "correct": 1,
    "explanation": "MissingServletRequestParameterException wird geworfen, wenn ein erforderlicher @RequestParam fehlt.",
    "xp": 20,
    "tags": ["uebung", "gemischt", "woche4"]
  },
  {
    "difficulty": 2,
    "type": "multiple",
    "question": "Welche Annotation markiert in einem Advice die Methode, die eine bestimmte Exception verarbeitet?",
    "options": ["@Handle", "@ExceptionHandler", "@Catch", "@OnError"],
    "correct": 1,
    "explanation": "@ExceptionHandler(ExceptionType.class) markiert Methoden in @ControllerAdvice zur Exception-Behandlung.",
    "xp": 15,
    "tags": ["uebung", "gemischt", "woche4"]
  },
  {
    "difficulty": 2,
    "type": "multiple",
    "question": "Welches Rückgabeobjekt wird im Beispiel zur Fehlerdarstellung verwendet?",
    "options": [
      "ResponseEntity<String>",
      "ModelAndView",
      "String (View-Name)",
      "Optional<Model>"
    ],
    "correct": 1,
    "explanation": "ModelAndView kombiniert View-Name und Model-Daten und ist ideal für Exception-Handler.",
    "xp": 20,
    "tags": ["uebung", "gemischt", "woche4"]
  },
  {
    "difficulty": 2,
    "type": "multiple",
    "question": "Welche View-Datei rendert die zentrale Fehlerausgabe im Beispiel?",
    "options": ["error.html", "support.html", "exception.html", "fault.html"],
    "correct": 1,
    "explanation": "Die support.html-Datei wird im Beispiel für die nutzerfreundliche Fehlerdarstellung verwendet.",
    "xp": 15,
    "tags": ["uebung", "gemischt", "woche4"]
  },
  {
    "difficulty": 2,
    "type": "multiple",
    "question": "Welche Exception tritt auf, wenn ein Request‑Parameter nicht in den erwarteten Typ konvertiert werden kann?",
    "options": [
      "MethodArgumentTypeMismatchException",
      "MissingServletRequestParameterException",
      "HttpMessageNotReadableException",
      "ConstraintViolationException"
    ],
    "correct": 0,
    "explanation": "Fehltypisierte Parameter (z. B. 'id=abc' statt Zahl) führen zu MethodArgumentTypeMismatchException.",
    "xp": 15,
    "tags": ["uebung", "gemischt", "woche4"]
  },
  {
    "difficulty": 2,
    "type": "matching",
    "question": "Ordne Ordner → Zweck zu:",
    "pairs": [
      {"left": "controller", "right": "Nutzerschnittstelle/Controller"},
      {"left": "model", "right": "Entity-Klassen"},
      {"left": "repository", "right": "Zugriff auf persistente Daten"},
      {"left": "service", "right": "Dienstlogik"},
      {"left": "config", "right": "Initiale Datenkonfiguration"}
    ],
    "explanation": "Standard Spring Boot Package-Struktur trennt Verantwortlichkeiten nach Schichten.",
    "xp": 20,
    "tags": ["uebung", "gemischt", "woche4"]
  },
  {
    "difficulty": 2,
    "type": "checkbox",
    "question": "Welche Vorteile bieten MVC/Schichten? (Mehrfachauswahl)",
    "options": [
      "Trennung von Darstellung und Logik",
      "Leichtere Änderbarkeit/Wartbarkeit",
      "Zwang zu Monolithen",
      "Bessere Testbarkeit"
    ],
    "correct": [0, 1, 3],
    "explanation": "MVC trennt Concerns, verbessert Wartbarkeit und Testbarkeit; es erzwingt keine monolithische Architektur.",
    "xp": 20,
    "tags": ["uebung", "gemischt", "woche4"]
  },
  {
    "difficulty": 1,
    "type": "multiple",
    "question": "Mit welcher Thymeleaf‑Anweisung iterierst du über eine Liste im Model?",
    "options": ["th:if", "th:each", "th:text", "th:src"],
    "correct": 1,
    "explanation": "th:each durchläuft Sammlungen und rendert für jedes Element ein Fragment.",
    "xp": 10,
    "tags": ["uebung", "gemischt", "woche4"]
  },
  {
    "difficulty": 1,
    "type": "multiple",
    "question": "Thymeleaf kann Variablen, Befehle und Fragmente in Templates verwenden.",
    "options": ["Wahr", "Falsch"],
    "correct": 0,
    "explanation": "Wahr. Thymeleaf unterstützt Variablen (${...}), Befehle (th:if, th:each) und wiederverwendbare Fragmente (th:fragment).",
    "xp": 10,
    "tags": ["uebung", "gemischt", "woche4"]
  },
  {
    "difficulty": 3,
    "type": "matching",
    "question": "Ordne Akteur → Aufgabe im MVC-Requestflow zu:",
    "pairs": [
      {"left": "DispatcherServlet", "right": "empfängt Request & orchestriert"},
      {"left": "HandlerMapping", "right": "ermittelt Ziel-Controller"},
      {"left": "Controller", "right": "verarbeitet & füllt Model"},
      {"left": "ViewResolver", "right": "findet Template"},
      {"left": "View", "right": "rendert HTML mit Model"}
    ],
    "explanation": "Der Spring MVC Request-Flow durchläuft diese Komponenten in dieser Reihenfolge.",
    "xp": 30,
    "tags": ["uebung", "gemischt", "woche4"]
  },
  {
    "difficulty": 1,
    "type": "multiple",
    "question": "Wo muss sich eine repräsentierbare Ressource befinden, damit Spring Boot sie findet?",
    "options": [
      "Irgendwo im Projekt",
      "/opt/resources",
      "Unterhalb von src/main/resources",
      "Nur im Klassenpfad META-INF/resources"
    ],
    "correct": 2,
    "explanation": "Spring Boot sucht Ressourcen standardmäßig in src/main/resources und dessen Unterordnern (static, templates, etc.).",
    "xp": 10,
    "tags": ["uebung", "gemischt", "woche4"]
  }
  ,
  {
    "difficulty": 2,
    "type": "checkbox",
    "question": "Welche Aussagen unterscheiden HTML5 von HTML4? (Mehrfachauswahl)",
    "options": [
      "Einfachere Doctype-Deklaration: <!DOCTYPE html>",
      "Semantische Elemente wie <header>, <nav>, <section>, <footer>",
      "Native Medien-Elemente (<audio>, <video>) ohne Plugins",
      "Framesets sind die empfohlene Layout-Technik"
    ],
    "correct": [0, 1, 2],
    "explanation": "HTML5 vereinfacht den Doctype, führt neue semantische Elemente ein und bringt native Audio-/Video-Tags; Framesets gelten als veraltet.",
    "xp": 20,
  "tags": ["woche4", "gemischt", "vl-offiziell"]
  },
  {
    "difficulty": 2,
    "type": "matching",
    "question": "Ordne typische HTML5-Boilerplate-Elemente ihrem Zweck zu:",
    "pairs": [
      {"left": "<!DOCTYPE html>", "right": "Aktiviert Standards-Modus/HTML5"},
      {"left": "<meta charset=\"utf-8\">", "right": "Zeichensatz festlegen"},
      {"left": "<meta name=\"viewport\" content=\"width=device-width, initial-scale=1\">", "right": "Responsive Skalierung auf Mobilgeräten"},
      {"left": "<link rel=\"stylesheet\" href=\"style.css\">", "right": "Externe CSS-Datei einbinden"},
      {"left": "<script defer src=\"app.js\"></script>", "right": "JavaScript nicht-blockierend laden"}
    ],
    "explanation": "Diese Elemente bilden die Basis einer modernen HTML5-Seite für korrekte Darstellung und Performance.",
    "xp": 20,
  "tags": ["woche4", "gemischt", "vl-offiziell"]
  },
  {
    "difficulty": 2,
    "type": "matching",
    "question": "Ordne Sitzungs-/Zustands-Management-Methoden ihrem Merkmal zu:",
    "pairs": [
      {"left": "Cookies", "right": "ID clientseitig gespeichert, an jede Anfrage gesendet"},
      {"left": "URL-Rewriting", "right": "Session-ID in der URL (z. B. ;jsessionid=...)"},
      {"left": "Hidden Fields", "right": "Daten nur bei Formular-Submit gesendet"},
      {"left": "HttpSession", "right": "Serverseitiger Zustand, via Cookie/URL referenziert"},
      {"left": "Local/SessionStorage", "right": "Persistenz im Browser, nicht automatisch an Server gesendet"}
    ],
    "explanation": "Web-Apps kombinieren häufig serverseitige Sessions mit clientseitigen Speichern und Cookies zur Wiedererkennung.",
    "xp": 25,
  "tags": ["woche4", "gemischt", "vl-offiziell"]
  },
  {
    "difficulty": 1,
    "type": "multiple",
    "question": "Wer pflegt den aktuellen HTML-Standard (Living Standard)?",
    "options": ["W3C", "WHATWG", "ECMA", "ISO"],
    "correct": 1,
    "explanation": "Die WHATWG pflegt das HTML Living Standard. Das W3C hat frühere HTML-Versionen standardisiert.",
    "xp": 15,
  "tags": ["woche4", "gemischt", "vl-offiziell"]
  },
  {
    "difficulty": 1,
    "type": "matching",
    "question": "Wie kann CSS eingebunden werden? Ordne Methode → Beispiel zu:",
    "pairs": [
      {"left": "Inline-Stile", "right": "<h1 style=\"color:red\">..."},
      {"left": "Interne Styles", "right": "<style> h1{color:red} </style>"},
      {"left": "Externe Datei", "right": "<link rel=\"stylesheet\" href=\"style.css\">"},
      {"left": "@import", "right": "@import url('theme.css');"}
    ],
    "explanation": "CSS kann inline, im <style>-Block, per <link> oder mit @import geladen werden.",
    "xp": 15,
  "tags": ["woche4", "gemischt", "vl-offiziell"]
  },
  {
    "difficulty": 2,
    "type": "matching",
    "question": "Ordne Selektor-Typ → Beispiel zu:",
    "pairs": [
      {"left": "Typselektor", "right": "p"},
      {"left": "Klassenselektor", "right": ".btn"},
      {"left": "ID-Selektor", "right": "#main"},
      {"left": "Attributselektor", "right": "input[type=\"text\"]"},
      {"left": "Pseudoklasse", "right": "a:hover"}
    ],
    "explanation": "Die wichtigsten CSS-Selektoren adressieren Elemente nach Typ, Klasse, ID, Attributen oder Zustand.",
    "xp": 20,
  "tags": ["woche4", "gemischt", "vl-offiziell"]
  },
  {
    "difficulty": 1,
    "type": "matching",
    "question": "Ordne Box-Model-Schicht → Beschreibung zu:",
    "pairs": [
      {"left": "content", "right": "Eigentlicher Inhalt (z. B. Text, Bild)"},
      {"left": "padding", "right": "Innenabstand zwischen Inhalt und Rahmen"},
      {"left": "border", "right": "Rahmenlinie um das Element"},
      {"left": "margin", "right": "Außenabstand zum nächsten Element"}
    ],
    "explanation": "Das CSS-Box-Modell besteht aus content, padding, border und margin in dieser Reihenfolge von innen nach außen.",
    "xp": 15,
  "tags": ["woche4", "gemischt", "vl-offiziell"]
  },
  {
    "difficulty": 2,
    "type": "checkbox",
    "question": "Warum wird JavaScript überwiegend clientseitig eingesetzt? (Mehrfachauswahl)",
    "options": [
      "Interaktive UI ohne Server-Roundtrip",
      "Direkter Zugriff auf DOM und Browser-Events",
      "Weil Browser kein HTML rendern können",
      "Geringere Latenz und unmittelbares Feedback"
    ],
    "correct": [0, 1, 3],
    "explanation": "JS reagiert im Browser direkt auf Nutzeraktionen, manipuliert das DOM und liefert schnelles Feedback; HTML wird natürlich weiterhin nativ gerendert.",
    "xp": 20,
  "tags": ["woche4", "gemischt", "vl-offiziell"]
  },
  {
    "difficulty": 2,
    "type": "checkbox",
    "question": "Typische Anwendungsfälle für JavaScript im Browser sind … (Mehrfachauswahl)",
    "options": [
      "Formularvalidierung im Client",
      "DOM- und Style-Manipulation",
      "SPA-Routing und Navigation",
      "SSL-Verschlüsselung auf Transportebene",
      "Asynchrone Requests per fetch/AJAX"
    ],
    "correct": [0, 1, 2, 4],
    "explanation": "JavaScript validiert Formulare, steuert SPAs, manipuliert DOM/CSS und ruft Daten asynchron ab; SSL erledigt die Transportebene (TLS), nicht JS.",
    "xp": 25,
  "tags": ["woche4", "gemischt", "vl-offiziell"]
  },
  {
    "difficulty": 1,
    "type": "multiple",
    "question": "Was beschreibt das Document Object Model (DOM) korrekt?",
    "options": [
      "Baumstruktur aus Knoten, die ein Dokument repräsentiert",
      "JSON-Format zur Browserkonfiguration",
      "Netzwerkprotokoll zur Datenübertragung",
      "CSS-Spezifikation für Layout"
    ],
    "correct": 0,
    "explanation": "Das DOM bildet HTML/XML als Baum von Knoten ab, den Skripte lesen und verändern können.",
    "xp": 15,
  "tags": ["woche4", "gemischt", "vl-offiziell"]
  }
  ,
  {
    "difficulty": 1,
    "type": "multiple",
    "question": "Das MVC-Pattern fördert lose Kopplung zwischen Komponenten.",
    "options": ["Falsch", "Wahr"],
    "correct": 1,
    "explanation": "Durch Trennung von Model, View und Controller entsteht geringere Abhängigkeit zwischen Schichten.",
    "xp": 10,
    "tags": ["offiziell", "woche4"]
  },
  {
    "difficulty": 1,
    "type": "multiple",
    "question": "Welche Annotation wird für HTTP Request Mappings verwendet?",
    "options": ["@ControllerAdvice", "@RequestMapping", "@Service", "@ModelAttribute"],
    "correct": 1,
    "explanation": "@RequestMapping (bzw. @GetMapping/@PostMapping etc.) verknüpft URL-Pfade mit Controller-Methoden.",
    "xp": 10,
    "tags": ["offiziell", "woche4"]
  },
  {
    "difficulty": 2,
    "type": "multiple",
    "question": "@ExceptionHandler in Kombination mit @ControllerAdvice ermöglicht zentrale Behandlung einer Exception.",
    "options": ["Falsch", "Wahr"],
    "correct": 1,
    "explanation": "@ControllerAdvice + @ExceptionHandler erlaubt globale Fehlerbehandlung für definierte Exception-Typen.",
    "xp": 15,
    "tags": ["offiziell", "woche4"]
  },
  {
    "difficulty": 2,
    "type": "multiple",
    "question": "Was passiert, wenn eine HTTP-Anfrage mit fehlenden Parametern gesendet wird?",
    "options": [
      "Anfrage wird normal verarbeitet",
      "MissingServletRequestParameterException wird ausgelöst",
      "Server ignoriert die Anfrage",
      "Controller erstellt Parameter automatisch"
    ],
    "correct": 1,
    "explanation": "✅ Richtig: MissingServletRequestParameterException – Fehlende Pflicht-Parameter führen zu dieser Exception.",
    "xp": 15,
    "tags": ["offiziell", "woche4"]
  },
  {
    "difficulty": 1,
    "type": "multiple",
    "question": "Die View leitet Model-Daten an den Controller weiter, um eine dynamische Anzeige zu generieren.",
    "options": ["Falsch", "Wahr"],
    "correct": 0,
    "explanation": "✅ Richtig: Falsch – Im MVC-Pattern stellt der Controller dem Model Daten bereit und übergibt diese an die View zum Rendern, nicht umgekehrt.",
    "xp": 10,
    "tags": ["offiziell", "woche4"]
  },
  {
    "difficulty": 1,
    "type": "multiple",
    "question": "Im Beispiel /add?firstName=Celine&lastName=Clever ist lastName der Name eines Parameters.",
    "options": ["Falsch", "Wahr"],
    "correct": 1,
    "explanation": "✅ Richtig: Wahr – Im Query-String sind firstName und lastName die Parameternamen.",
    "xp": 10,
    "tags": ["offiziell", "woche4"]
  },
  {
    "difficulty": 2,
    "type": "matching",
    "question": "Ordne MVC-Komponente → Beschreibung zu:",
    "pairs": [
      {"left": "Model", "right": "Enthält Daten und Geschäftslogik"},
      {"left": "View", "right": "Darstellung für den Benutzer"},
      {"left": "Controller", "right": "Verarbeitet Anfragen und verbindet Model & View"}
    ],
    "explanation": "✅ Richtige Zuordnungen: Model = Daten & Geschäftslogik | View = Darstellung für den Benutzer | Controller = Verarbeitet Anfragen und verbindet Model & View.",
    "xp": 15,
    "tags": ["offiziell", "woche4"]
  },
  {
    "difficulty": 1,
    "type": "multiple",
    "question": "Welches Muster trennt Daten, Logik und Darstellung?",
    "options": ["Factory", "MVC", "Decorator", "Singleton"],
    "correct": 1,
    "explanation": "✅ Richtig: MVC (Model-View-Controller) trennt Daten, Logik und Darstellung in drei separate Komponenten.",
    "xp": 10,
    "tags": ["offiziell", "woche4"]
  },
  {
    "difficulty": 2,
    "type": "multiple",
    "question": "Was passiert, wenn ein Parameter in einer HTTP-Anfrage fehlt?",
    "options": ["Ignorieren", "MissingServletRequestParameterException", "Normal verarbeitet", "Automatische Ergänzung"],
    "correct": 1,
    "explanation": "✅ Richtig: MissingServletRequestParameterException – Fehlende Pflicht-Parameter führen zu dieser Exception.",
    "xp": 15,
    "tags": ["offiziell", "woche4"]
  },
  {
    "difficulty": 1,
    "type": "multiple",
    "question": "Welche Komponente löst den View-Namen auf und sucht passende Ressource?",
    "options": ["DispatcherServlet", "Controller", "ViewResolver", "TemplateEngine"],
    "correct": 2,
    "explanation": "✅ Richtig: ViewResolver – Diese Komponente mappt View-Namen zu den entsprechenden Template-Dateien.",
    "xp": 10,
    "tags": ["offiziell", "woche4"]
  },
  {
    "difficulty": 1,
    "type": "multiple",
    "question": "Welche Annotation wird verwendet, um Exception-Handler global bereitzustellen?",
    "options": ["@ResponseStatus", "@ControllerAdvice", "@RestController", "@ExceptionHandler"],
    "correct": 1,
    "explanation": "✅ Richtig: @ControllerAdvice – Diese Annotation ermöglicht globale Exception-Handler für die gesamte Anwendung.",
    "xp": 10,
    "tags": ["offiziell", "woche4"]
  },
  {
    "difficulty": 1,
    "type": "multiple",
    "question": "Welche Annotation markiert eine Methode, die Exceptions behandelt?",
    "options": ["@ErrorMapping", "@Handle", "@ExceptionHandler", "@Catch"],
    "correct": 2,
    "explanation": "✅ Richtig: @ExceptionHandler – Diese Annotation markiert Methoden, die spezifische Exception-Typen behandeln.",
    "xp": 10,
    "tags": ["offiziell", "woche4"]
  },
  {
    "difficulty": 1,
    "type": "multiple",
    "question": "Was passiert mit einer Anfrage ohne passende Controller-Methode?",
    "options": ["302 Redirect", "404 Fehler", "204 Leerantwort", "500 Fehler"],
    "correct": 1,
    "explanation": "✅ Richtig: 404 Fehler – Ohne passendes Mapping wird ein 404 Not Found zurückgegeben.",
    "xp": 10,
    "tags": ["offiziell", "woche4"]
  },
  {
    "difficulty": 1,
    "type": "multiple",
    "question": "Welche Annotation dient der Darstellung von Views in Spring Boot?",
    "options": ["@Repository", "@Service", "@Controller", "@Component"],
    "correct": 2,
    "explanation": "✅ Richtig: @Controller – Diese Annotation kennzeichnet eine MVC-Controller-Klasse zur View-Darstellung.",
    "xp": 10,
    "tags": ["offiziell", "woche4"]
  },
  {
    "difficulty": 1,
    "type": "multiple",
    "question": "Welche Annotation wird verwendet, um Controller-Methoden mit URL-Pfaden zu verbinden?",
    "options": ["@Qualifier", "@RequestMapping", "@Autowired", "@Resource"],
    "correct": 1,
    "explanation": "✅ Richtig: @RequestMapping – Diese Annotation (und ihre Spezialisierungen wie @GetMapping, @PostMapping) verbindet URL-Pfade mit Controller-Methoden.",
    "xp": 10,
    "tags": ["offiziell", "woche4"]
  },
  {
    "difficulty": 1,
    "type": "multiple",
    "question": "Was ist die Hauptaufgabe des Controllers im MVC-Muster?",
    "options": ["Persistenz-Schicht verwalten", "Datenhaltung", "Rendering", "Verarbeitung von Anfragen und Übergabe der Daten an die View"],
    "correct": 3,
    "explanation": "✅ Richtig: Verarbeitung von Anfragen und Übergabe der Daten an die View – Der Controller vermittelt zwischen Anfrage und Darstellung.",
    "xp": 10,
    "tags": ["offiziell", "woche4"]
  },
  {
    "difficulty": 1,
    "type": "multiple",
    "question": "Was ist die Hauptaufgabe des Models im MVC-Muster?",
    "options": ["Routing", "Styling", "Geschäftslogik & Daten verwalten", "HTML erzeugen"],
    "correct": 2,
    "explanation": "✅ Richtig: Geschäftslogik & Daten verwalten – Das Model kapselt die Geschäftslogik und verwaltet die Daten der Anwendung.",
    "xp": 10,
    "tags": ["offiziell", "woche4"]
  },
  {
    "difficulty": 1,
    "type": "multiple",
    "question": "Was ist die Hauptaufgabe der View im MVC-Muster?",
    "options": ["Persistenz", "Darstellung der Daten", "Business-Logik", "Request-Routing"],
    "correct": 1,
    "explanation": "✅ Richtig: Darstellung der Daten – Die View rendert die Inhalte für den Benutzer.",
    "xp": 10,
    "tags": ["offiziell", "woche4"]
  },
  {
    "difficulty": 2,
    "type": "multiple",
    "question": "Welche Annotation verbindet HTTP-Parameter mit Methodenparametern?",
    "options": ["@PathVariable", "@RequestParam", "@Param", "@BindParam"],
    "correct": 1,
    "explanation": "✅ Richtig: @RequestParam – Diese Annotation bindet HTTP Query-Parameter an Methodenparameter.",
    "xp": 15,
    "tags": ["offiziell", "woche4"]
  },
  {
    "difficulty": 1,
    "type": "multiple",
    "question": "Welche Spring-Komponente ist für das Rendern von HTML-Seiten zuständig?",
    "options": ["Controller", "HandlerMapping", "View", "Model"],
    "correct": 2,
    "explanation": "✅ Richtig: View – Die View-Komponente generiert die HTML-Ausgabe für den Benutzer.",
    "xp": 10,
    "tags": ["offiziell", "woche4"]
  },
  {
    "difficulty": 2,
    "type": "sort",
    "question": "In welcher Reihenfolge erfolgt die Verarbeitung eines HTTP-Requests im MVC-Framework?",
    "items": ["Client", "DispatcherServlet", "Controller", "Model", "ViewResolver", "View", "Client"],
    "correct": ["Client", "DispatcherServlet", "Controller", "Model", "ViewResolver", "View", "Client"],
    "explanation": "Standardfluss einer Anfrage.\n✅ Client → DispatcherServlet → Controller → Model → ViewResolver → View → Client",
    "xp": 15,
    "tags": ["offiziell", "woche4"]
  },
  {
    "difficulty": 1,
    "type": "multiple",
    "question": "Welcher Vorteil ergibt sich durch das MVC-Muster?",
    "options": ["Weniger Modularität", "Bessere Wartbarkeit durch klare Trennung", "Mehr Serverlast", "Höhere Kopplung"],
    "correct": 1,
    "explanation": "✅ Richtig: Bessere Wartbarkeit durch klare Trennung – Die Trennung der Komponenten erhöht Wartbarkeit und Testbarkeit.",
    "xp": 10,
    "tags": ["offiziell", "woche4"]
  },
  {
    "difficulty": 1,
    "type": "multiple",
    "question": "Welche Datei-Struktur nutzt Spring Boot für statische Ressourcen wie CSS oder JS?",
    "options": ["/src/main/resources/templates", "/public", "/src/main/resources/static", "/static/assets"],
    "correct": 2,
    "explanation": "✅ Richtig: /src/main/resources/static – Statische Ressourcen wie CSS, JS und Bilder werden in diesem Ordner abgelegt.",
    "xp": 10,
    "tags": ["offiziell", "woche4"]
  },
  {
    "difficulty": 1,
    "type": "multiple",
    "question": "Wie werden dynamische Werte aus dem Model in Thymeleaf angezeigt?",
    "options": ["th:model", "th:attr", "th:text", "th:data"],
    "correct": 2,
    "explanation": "✅ Richtig: th:text – Das Attribut th:text=\"${variable}\" bindet einen Model-Wert als Textinhalt im HTML-Element.",
    "xp": 10,
    "tags": ["offiziell", "woche4"]
  },
  {
    "difficulty": 2,
    "type": "multiple",
    "question": "Welches Verhalten zeigt Spring Boot, wenn eine Exception nicht abgefangen wird?",
    "options": ["Silent Ignoring", "Automatische Wiederholung", "Standard-Error-Controller zeigt Fehlerseite", "Server stoppt"],
    "correct": 2,
    "explanation": "✅ Richtig: Standard-Error-Controller zeigt Fehlerseite – Unbehandelte Exceptions werden vom ErrorController abgefangen und als Fehlerseite dargestellt.",
    "xp": 15,
    "tags": ["offiziell", "woche4"]
  },
  {
    "difficulty": 2,
    "type": "multiple",
    "question": "Welche Methode ruft das DispatcherServlet nach der Auflösung des Controllers auf?",
    "options": ["Filter-Kette", "Passende Handler-Methode gemäß Mapping", "Destroy-Methode", "Init-Methode"],
    "correct": 1,
    "explanation": "✅ Richtig: Passende Handler-Methode gemäß Mapping – Das DispatcherServlet führt die Controller-Methode aus, die dem URL-Mapping entspricht.",
    "xp": 15,
    "tags": ["offiziell", "woche4"]
  },
  {
    "difficulty": 2,
    "type": "multiple",
    "question": "Welche Komponente übernimmt das Mapping zwischen URL und Controller-Methode?",
    "options": ["ErrorController", "ViewResolver", "HandlerMapping", "BeanFactory"],
    "correct": 2,
    "explanation": "✅ Richtig: HandlerMapping – Diese Komponente bestimmt die passende Controller-Methode für eine eingehende URL.",
    "xp": 15,
    "tags": ["offiziell", "woche4"]
  },
  {
    "difficulty": 2,
    "type": "multiple",
    "question": "Wofür wird @ModelAttribute verwendet?",
    "options": ["Validierung erzwingen", "Logging aktivieren", "Bean registrieren", "Model-Daten binden oder bereitstellen"],
    "correct": 3,
    "explanation": "✅ Richtig: Model-Daten binden oder bereitstellen – @ModelAttribute bindet Formular-/Request-Daten und stellt sie der View bereit.",
    "xp": 15,
    "tags": ["offiziell", "woche4"]
  },
  {
    "difficulty": 2,
    "type": "multiple",
    "question": "Was passiert, wenn ein Controller eine View zurückgibt, aber kein Model bereitstellt?",
    "options": ["Automatische Dummy-Daten", "Leere View ohne dynamische Daten", "Fehler 500", "Endlosschleife"],
    "correct": 1,
    "explanation": "✅ Richtig: Leere View ohne dynamische Daten – Ohne Model-Inhalte wird nur das statische Template ohne dynamische Werte gerendert.",
    "xp": 15,
    "tags": ["offiziell", "woche4"]
  },
  {
    "difficulty": 2,
    "type": "multiple",
    "question": "Welche Spring-Annotation markiert eine Klasse als Controller, der direkt JSON-Objekte zurückgibt?",
    "options": ["@ControllerJSON", "@JsonController", "@RestController", "@ResponseController"],
    "correct": 2,
    "explanation": "✅ Richtig: @RestController – Diese Annotation kombiniert @Controller und @ResponseBody für REST-APIs mit JSON-Rückgaben.",
    "xp": 15,
    "tags": ["offiziell", "woche4"]
  },
  {
    "difficulty": 1,
    "type": "multiple",
    "question": "Welche Schicht enthält in der Regel die Geschäftslogik?",
    "options": ["DispatcherServlet", "Model", "Templating", "View"],
    "correct": 1,
    "explanation": "✅ Richtig: Model – Die Geschäftslogik und Daten befinden sich im Model bzw. Service-Layer.",
    "xp": 10,
    "tags": ["offiziell", "woche4"]
  },
  {
    "difficulty": 2,
    "type": "multiple",
    "question": "Welcher Vorteil ergibt sich aus @ControllerAdvice und @ExceptionHandler?",
    "options": ["Performance-Optimierung", "Zentrale einheitliche Fehlerbehandlung", "Automatisches Logging deaktivieren", "Mehr Kopplung"],
    "correct": 1,
    "explanation": "✅ Richtig: Zentrale einheitliche Fehlerbehandlung – Globale Fehlerlogik statt duplizierter Exception-Handler in jedem Controller.",
    "xp": 15,
    "tags": ["offiziell", "woche4"]
  },
  {
    "difficulty": 1,
    "type": "multiple",
    "question": "Was ist der Zweck der Annotation @Service?",
    "options": ["Routing", "Static Binding", "Markiert Geschäftslogik-Komponente", "Templating"],
    "correct": 2,
    "explanation": "✅ Richtig: Markiert Geschäftslogik-Komponente – @Service kennzeichnet eine Service-Klasse mit Business-Logik.",
    "xp": 10,
    "tags": ["offiziell", "woche4"]
  },
  {
    "difficulty": 2,
    "type": "multiple",
    "question": "Wie nennt man den Mechanismus, der View-Namen in Dateien wie HTML oder JSP auflöst?",
    "options": ["TemplateScanner", "ViewEngine", "ViewResolver", "NameMapper"],
    "correct": 2,
    "explanation": "✅ Richtig: ViewResolver – Dieser Mechanismus löst View-Namen in entsprechende Template-Dateien (HTML, JSP) auf.",
    "xp": 15,
    "tags": ["offiziell", "woche4"]
  },
  {
    "difficulty": 2,
    "type": "matching",
    "question": "Ordne MVC Ablauf: Komponente → Aufgabe",
    "pairs": [
      {"left": "Controller", "right": "Nimmt HTTP-Requests entgegen"},
      {"left": "Model", "right": "Speichert Daten und Logik"},
      {"left": "View", "right": "Rendert HTML-Ausgabe"}
    ],
    "explanation": "✅ Richtige Zuordnungen: Controller = Nimmt HTTP-Requests entgegen | Model = Speichert Daten und Logik | View = Rendert HTML-Ausgabe. Dies sind die grundlegenden Verantwortlichkeiten der MVC-Schichten.",
    "xp": 15,
    "tags": ["offiziell", "woche4"]
  }
  ,
  {
    "difficulty": 1,
    "type": "multiple",
    "question": "Das Model enthält die Logik zur Anzeige der Daten.",
    "options": ["Falsch", "Wahr"],
    "correct": 0,
    "explanation": "✅ Richtig: Falsch – Die Anzeige (Rendering) ist Aufgabe der View. Das Model hält Daten und Geschäftslogik, nicht die Präsentationslogik.",
    "xp": 10,
    "tags": ["offiziell", "woche4"]
  },
  {
    "difficulty": 1,
    "type": "multiple",
    "question": "Der Hostname example.com besteht aus einer Top-Level-Domain, einer Second-Level-Domain und ggf. einer Subdomain.",
    "options": ["Falsch", "Wahr"],
    "correct": 1,
    "explanation": "✅ Richtig: Wahr – example.com besteht aus Second-Level-Domain 'example' + Top-Level-Domain '.com'; Subdomains sind optional (z.B. www.example.com).",
    "xp": 10,
    "tags": ["offiziell", "woche4"]
  },
  {
    "difficulty": 1,
    "type": "multiple",
    "question": "Welches Attribut in Thymeleaf wird verwendet, um dynamische Daten darzustellen?",
    "options": ["th:each", "th:class", "th:src", "th:text"],
    "correct": 3,
    "explanation": "✅ Richtig: th:text – Das Attribut th:text=\"${variable}\" zeigt dynamische Daten aus dem Model im HTML-Element an.",
    "xp": 10,
    "tags": ["offiziell", "woche4"]
  },
  {
    "difficulty": 1,
    "type": "multiple",
    "question": "Die Trennung von Model, View und Controller erleichtert die Wartung der Anwendung.",
    "options": ["Falsch", "Wahr"],
    "correct": 1,
    "explanation": "✅ Richtig: Wahr – Die klare Trennung der MVC-Komponenten sorgt für bessere Testbarkeit, Wiederverwendbarkeit und Wartbarkeit.",
    "xp": 10,
    "tags": ["offiziell", "woche4"]
  },
  {
    "difficulty": 1,
    "type": "multiple",
    "question": "Welche Klasse ist für die Verarbeitung von Ausnahmen in der gesamten Anwendung zuständig?",
    "options": ["FaultController", "ErrorService", "GlobalExceptionHandler", "ExceptionManager"],
    "correct": 2,
    "explanation": "✅ Richtig: GlobalExceptionHandler – Diese Klasse (typischerweise mit @ControllerAdvice annotiert) behandelt zentral alle Exceptions der Anwendung.",
    "xp": 10,
    "tags": ["offiziell", "woche4"]
  },
  {
    "difficulty": 1,
    "type": "multiple",
    "question": "HTML-Dateien für dynamische Inhalte müssen im Ordner /templates gespeichert werden.",
    "options": ["Falsch", "Wahr"],
    "correct": 1,
    "explanation": "✅ Richtig: Wahr – Thymeleaf-Templates für dynamische Views werden unter src/main/resources/templates gespeichert.",
    "xp": 10,
    "tags": ["offiziell", "woche4"]
  },
  {
    "difficulty": 1,
    "type": "multiple",
    "question": "Welche Rolle übernimmt der Controller im MVC-Entwurfsmuster?",
    "options": ["HTML rendern", "Datenbank verwalten", "Anfragen verarbeiten und Daten an die View weiterleiten", "Daten speichern"],
    "correct": 2,
    "explanation": "✅ Richtig: Anfragen verarbeiten und Daten an die View weiterleiten – Der Controller nimmt Requests entgegen, verarbeitet sie (ggf. mit Model) und leitet die Daten an die View weiter.",
    "xp": 10,
    "tags": ["offiziell", "woche4"]
  },
  {
    "difficulty": 1,
    "type": "multiple",
    "question": "Was beschreibt REST im Kern?",
    "options": [
      "Ein Protokoll zur Datenbankkommunikation",
      "Ein Architekturstil für verteilte Systeme",
      "Ein Messaging-Framework",
      "Eine serverseitige Template-Engine"
    ],
    "correct": 1,
    "explanation": "✅ Richtig: REST ist ein Architekturstil für verteilte Systeme und definiert Prinzipien wie Ressourcenorientierung, standardisierte HTTP-Methoden und Hypermedia-Navigation.",
    "xp": 12,
    "tags": ["uebung", "woche5"]
  },
  {
    "difficulty": 1,
    "type": "multiple",
    "question": "Welche Aussage beschreibt eine Ressource korrekt?",
    "options": [
      "Ressourcen bestehen immer aus JSON",
      "Alles, was eindeutig adressierbar ist, kann eine Ressource sein",
      "Ressourcen sind nur Dateien",
      "Ressourcen können keine Listen sein"
    ],
    "correct": 1,
    "explanation": "✅ Richtig: Jede eindeutig adressierbare Entität – Dokument, Sammlung, Ergebnisliste – kann eine Ressource sein, unabhängig vom Format.",
    "xp": 12,
    "tags": ["uebung", "woche5"]
  },
  {
    "difficulty": 1,
    "type": "fillblank",
    "question": "Eine REST-Ressource wird eindeutig über eine _____ adressiert.",
    "blanks": ["URI"],
    "explanation": "✅ Richtig: URIs (Uniform Resource Identifier) identifizieren Ressourcen eindeutig und stellen sicher, dass Client und Server über dieselbe Adresse sprechen.",
    "xp": 15,
    "tags": ["uebung", "woche5"]
  },
  {
    "difficulty": 2,
    "type": "sort",
    "question": "Sortiere die Bestandteile einer vollständigen URI in der Reihenfolge, wie sie in der Adresse erscheinen:",
    "items": ["query", "host", "scheme", "path", "port"],
    "correct": ["scheme", "host", "port", "path", "query"],
    "explanation": "✅ Richtig: scheme://host:port/path?query – erst das Schema, dann Host, optional der Port, anschließend der Pfad und zuletzt der Query-Teil.",
    "xp": 18,
    "tags": ["uebung", "woche5"]
  },
  {
    "difficulty": 1,
    "type": "multiple",
    "question": "Welche Eigenschaft beschreibt zustandslose Kommunikation (stateless) korrekt?",
    "options": [
      "Der Server speichert Session-Daten eines Clients",
      "Der Client übermittelt alle nötigen Informationen bei jeder Anfrage",
      "Cookies müssen immer gesetzt werden",
      "Der Server hält den Zustand der letzten zehn Requests"
    ],
    "correct": 1,
    "explanation": "✅ Richtig: Bei Statelessness enthält jede Anfrage sämtliche benötigten Kontextinformationen, sodass der Server keinen Sitzungszustand behalten muss.",
    "xp": 12,
    "tags": ["uebung", "woche5"]
  },
  {
    "difficulty": 1,
    "type": "multiple",
    "question": "Welche HTTP-Methode wird klassisch zum Erstellen einer neuen Ressource verwendet?",
    "options": ["GET", "PUT", "POST", "DELETE"],
    "correct": 2,
    "explanation": "✅ Richtig: POST erzeugt neue Ressourcen oder löst serverseitige Verarbeitung aus, bei der der Server die finale URI bestimmt.",
    "xp": 10,
    "tags": ["uebung", "woche5"]
  },
  {
    "difficulty": 1,
    "type": "multiple",
    "question": "Welche HTTP-Methode gilt im CRUD-Kontext als idempotent für Updates?",
    "options": ["POST", "PUT", "PATCH", "OPTIONS"],
    "correct": 1,
    "explanation": "✅ Richtig: PUT überschreibt eine Ressource vollständig – mehrere identische Aufrufe führen zum selben Ergebnis und sind deshalb idempotent.",
    "xp": 12,
    "tags": ["uebung", "woche5"]
  },
  {
    "difficulty": 1,
    "type": "multiple",
    "question": "Was tut die DELETE-Methode im REST-Kontext?",
    "options": [
      "Sie führt Berechnungen aus",
      "Sie löscht eine Ressource",
      "Sie listet mehrere Ressourcen auf",
      "Sie erstellt mehrere Ressourcen"
    ],
    "correct": 1,
    "explanation": "✅ Richtig: DELETE entfernt die adressierte Ressource – wiederholte Aufrufe liefern höchstens einen 404, verändern das Ergebnis aber nicht.",
    "xp": 10,
    "tags": ["uebung", "woche5"]
  },
  {
    "difficulty": 1,
    "type": "multiple",
    "question": "Welche Operation ist NICHT idempotent?",
    "options": ["GET", "PUT", "DELETE", "POST"],
    "correct": 3,
    "explanation": "✅ Richtig: POST ist nicht idempotent, weil jeder Aufruf eine neue Ressource erzeugen oder einen neuen Zustand bewirken kann.",
    "xp": 12,
    "tags": ["uebung", "woche5"]
  },
  {
    "difficulty": 2,
    "type": "checkbox",
    "question": "Welche Annotationen bildet ein klassischer CrudController ab? (Mehrfachauswahl)",
    "options": ["@GetMapping", "@PostMapping", "@PutMapping", "@DeleteMapping", "@PatchMapping"],
    "correct": [0, 1, 2, 3],
    "explanation": "✅ Richtig: CRUD deckt Lesen, Erstellen, Aktualisieren und Löschen ab – typischerweise @GetMapping, @PostMapping, @PutMapping und @DeleteMapping.",
    "xp": 18,
    "tags": ["uebung", "woche5"]
  },
  {
    "difficulty": 1,
    "type": "multiple",
    "question": "Welche Aussage über Repräsentationen ist korrekt?",
    "options": [
      "Eine Ressource kann nur in HTML ausgeliefert werden",
      "Ressourcen können verschiedene Repräsentationen haben",
      "Der Client entscheidet nicht über das Format",
      "Repräsentationen dürfen kein JSON enthalten"
    ],
    "correct": 1,
    "explanation": "✅ Richtig: Eine Ressource kann mehrere Repräsentationen (JSON, XML, HTML …) besitzen – Content-Negotiation wählt das passende Format.",
    "xp": 12,
    "tags": ["uebung", "woche5"]
  },
  {
    "difficulty": 1,
    "type": "multiple",
    "question": "Warum ist es sinnvoll, komplexe Daten im Request-Body statt in der URL zu übertragen?",
    "options": [
      "URLs unterstützen nur Zahlen",
      "URLs sind nicht verschlüsselbar",
      "URLs sind begrenzt und ungeeignet für komplexe Daten",
      "Body-Daten sind grundsätzlich schneller"
    ],
    "correct": 2,
    "explanation": "✅ Richtig: URLs haben Längenlimits und sind schlecht lesbar für komplexe Strukturen; der Body erlaubt strukturierte JSON/Payloads.",
    "xp": 12,
    "tags": ["uebung", "woche5"]
  },
  {
    "difficulty": 1,
    "type": "multiple",
    "question": "Was repräsentiert ResponseEntity?",
    "options": [
      "Nur den HTTP-Body",
      "HTTP-Status, Header und Body zusammen",
      "Nur den HTTP-Header",
      "Nur Metadaten"
    ],
    "correct": 1,
    "explanation": "✅ Richtig: ResponseEntity kapselt Statuscode, Header und Body und erlaubt so vollständige Kontrolle über die Antwort.",
    "xp": 12,
    "tags": ["uebung", "woche5"]
  },
  {
    "difficulty": 1,
    "type": "multiple",
    "question": "Welche Annotation kombiniert @Controller und @ResponseBody?",
    "options": ["@RestController", "@JSONController", "@HtmlController", "@ResponseRest"],
    "correct": 0,
    "explanation": "✅ Richtig: @RestController setzt automatisch @Controller + @ResponseBody und liefert Rückgabewerte direkt als JSON/XML.",
    "xp": 10,
    "tags": ["uebung", "woche5"]
  },
  {
    "difficulty": 1,
    "type": "multiple",
    "question": "Was bewirkt produces=MediaType.APPLICATION_JSON_VALUE?",
    "options": [
      "Der Client sendet nur XML",
      "Der Rückgabewert wird im JSON-Format geliefert",
      "Der Controller wird nicht aufgerufen",
      "HTML wird automatisch erzeugt"
    ],
    "correct": 1,
    "explanation": "✅ Richtig: Über das produces-Attribut signalisiert die Methode, dass sie eine JSON-Repräsentation liefert.",
    "xp": 10,
    "tags": ["uebung", "woche5"]
  },
  {
    "difficulty": 1,
    "type": "multiple",
    "question": "Welcher Statuscode wird gesendet, wenn eine Liste existiert und zurückgegeben wird?",
    "options": ["200 OK", "201 Created", "204 No Content", "404 Not Found"],
    "correct": 0,
    "explanation": "✅ Richtig: 200 OK signalisiert, dass eine Ressource gefunden und im Body (z.B. als Liste) übertragen wurde.",
    "xp": 10,
    "tags": ["uebung", "woche5"]
  },
  {
    "difficulty": 1,
    "type": "multiple",
    "question": "Welcher Statuscode wird für eine leere Liste zurückgegeben?",
    "options": ["200 OK", "204 No Content", "422 Unprocessable Entity", "500 Internal Server Error"],
    "correct": 1,
    "explanation": "✅ Richtig: 204 No Content signalisiert erfolgreiche Verarbeitung ohne Body – passend für leere Sammlungen.",
    "xp": 10,
    "tags": ["uebung", "woche5"]
  },
  {
    "difficulty": 1,
    "type": "multiple",
    "question": "Was bedeutet 201 Created?",
    "options": [
      "Eine Ressource wurde gefunden",
      "Eine Ressource wurde erfolgreich erstellt",
      "Der Request war unvollständig",
      "Der Client ist nicht autorisiert"
    ],
    "correct": 1,
    "explanation": "✅ Richtig: 201 Created bestätigt, dass eine neue Ressource erstellt wurde – meist mit Verweis auf deren URI.",
    "xp": 10,
    "tags": ["uebung", "woche5"]
  },
  {
    "difficulty": 1,
    "type": "multiple",
    "question": "Wann wird der Statuscode 422 Unprocessable Entity gesendet?",
    "options": [
      "Wenn ein URL-Parameter fehlt oder leer ist",
      "Wenn die Ressource nicht existiert",
      "Wenn die Anfrage syntaktisch gültig ist, aber nicht verarbeitet werden kann",
      "Wenn der Server abstürzt"
    ],
    "correct": 2,
    "explanation": "✅ Richtig: 422 signalisiert, dass der Request formal korrekt ist, aber fachlich nicht verarbeitet werden kann (z.B. Validierungsfehler).",
    "xp": 12,
    "tags": ["uebung", "woche5"]
  },
  {
    "difficulty": 1,
    "type": "multiple",
    "question": "Welcher Header wird bei 201 Created in der Regel zusätzlich gesetzt?",
    "options": ["Accept-Language", "Authorization", "Location", "Content-Encoding"],
    "correct": 2,
    "explanation": "✅ Richtig: Der Location-Header enthält die URI der neu erstellten Ressource und ermöglicht dem Client direktes Nachladen.",
    "xp": 12,
    "tags": ["uebung", "woche5"]
  },
  {
    "difficulty": 1,
    "type": "multiple",
    "question": "Wofür steht das Akronym HATEOAS?",
    "options": [
      "Hypermedia As The Engine Of Application State",
      "Hyperlinks And Testing Engine Of API Services",
      "HTML As Template Engine On API Services",
      "Hostname Allocation Through External API System"
    ],
    "correct": 0,
    "explanation": "✅ Richtig: HATEOAS bedeutet Hypermedia As The Engine Of Application State – Links in den Antworten führen den Client durch den API-Zustand.",
    "xp": 12,
    "tags": ["uebung", "woche5"]
  },
  {
    "difficulty": 1,
    "type": "multiple",
    "question": "Was enthält eine Sammelressource (Collection Resource)?",
    "options": [
      "Alle Details aller Objekte",
      "Eine Liste plus Links zu Einzelressourcen",
      "Ein einzelnes Objekt",
      "Nur Query-Parameter"
    ],
    "correct": 1,
    "explanation": "✅ Richtig: Collections bündeln mehrere Elemente und liefern Hypermedia-Links zu den jeweiligen Einzelressourcen.",
    "xp": 12,
    "tags": ["uebung", "woche5"]
  },
  {
    "difficulty": 1,
    "type": "multiple",
    "question": "Was enthält eine Einzelressource?",
    "options": [
      "Nur einen Link",
      "Alle Details zur Ressource",
      "Nur Metadaten",
      "Nur die Ressourcengröße"
    ],
    "correct": 1,
    "explanation": "✅ Richtig: Einzelressourcen liefern die vollständige Darstellung eines konkreten Objekts inklusive seiner Attribute und Links.",
    "xp": 12,
    "tags": ["uebung", "woche5"]
  },
  {
    "difficulty": 1,
    "type": "multiple",
    "question": "Welche URI entspricht einer korrekten Ressourcendefinition?",
    "options": ["/createUser", "/deleteConversation", "/conversations/{id}", "/runActionNow"],
    "correct": 2,
    "explanation": "✅ Richtig: /conversations/{id} nutzt Substantive und Platzhalter – REST-URIs benennen Ressourcen, nicht Aktionen.",
    "xp": 12,
    "tags": ["uebung", "woche5"]
  },
  {
    "difficulty": 1,
    "type": "multiple",
    "question": "Welche Regel gilt für URIs im REST-Design?",
    "options": [
      "Verben müssen verwendet werden",
      "URIs bestehen ausschließlich aus Substantiven",
      "URIs enthalten immer einen Query-String",
      "URIs müssen groß geschrieben sein"
    ],
    "correct": 1,
    "explanation": "✅ Richtig: Ressourcen werden als Substantive modelliert (z.B. /users/42) – Aktionen werden durch HTTP-Methoden beschrieben, nicht durch den Pfad.",
    "xp": 12,
    "tags": ["uebung", "woche5"]
  },
  {
    "difficulty": 1,
    "type": "multiple",
    "question": "Welche URI zeigt Paging?",
    "options": ["/conversations?page=1", "/conversations!page", "/page/conversations/1", "/conversation/page?next"],
    "correct": 0,
    "explanation": "✅ Richtig: Query-Parameter wie page=1 signalisieren Paging – die Ressource selbst bleibt /conversations.",
    "xp": 10,
    "tags": ["uebung", "woche5"]
  },
  {
    "difficulty": 1,
    "type": "multiple",
    "question": "Was beschreibt eine sekundäre Sammlung?",
    "options": [
      "Eine Ressourcenliste, die eine Untermenge einer anderen Liste ist",
      "Eine Ressource ohne ID",
      "Ein Datenbankindex",
      "Einen Fehlercode"
    ],
    "correct": 0,
    "explanation": "✅ Richtig: Sekundäre Sammlungen hängen an einer Oberressource (z.B. /conversations/42/messages) und bilden deren Teilmengen ab.",
    "xp": 12,
    "tags": ["uebung", "woche5"]
  },
  {
    "difficulty": 1,
    "type": "multiple",
    "question": "Welche Funktion erfüllt Swagger-UI?",
    "options": [
      "Es generiert automatisch HTML-Views",
      "Es dokumentiert und testet REST-APIs im Browser",
      "Es überwacht Serverlogs",
      "Es ersetzt ResponseEntity"
    ],
    "correct": 1,
    "explanation": "✅ Richtig: Swagger-UI visualisiert OpenAPI-Spezifikationen, dokumentiert Endpunkte und erlaubt interaktive Tests direkt im Browser.",
    "xp": 12,
    "tags": ["uebung", "woche5"]
  },
  {
    "difficulty": 1,
    "type": "multiple",
    "question": "Welche Aussage zu cURL ist korrekt?",
    "options": [
      "cURL kann nur GET-Requests senden",
      "cURL kann alle HTTP-Methoden senden",
      "cURL funktioniert nur mit HTML-Webseiten",
      "cURL kann keine Header anzeigen"
    ],
    "correct": 1,
    "explanation": "✅ Richtig: cURL ist ein Kommandozeilen-Client für HTTP/HTTPS und unterstützt sämtliche Methoden inklusive Header- und Body-Konfiguration.",
    "xp": 12,
    "tags": ["uebung", "woche5"]
  },
  {
    "difficulty": 1,
    "type": "multiple",
    "question": "Welche Antwort gibt GET /restful/users/25 zurück, wenn der User nicht existiert?",
    "options": ["200 OK", "204 No Content", "404 Not Found", "422 Unprocessable Entity"],
    "correct": 2,
    "explanation": "✅ Richtig: Existiert die Ressource nicht, liefert der Server 404 Not Found – der Client weiß so, dass die URI unbekannt ist.",
    "xp": 12,
    "tags": ["uebung", "woche5"]
  },
  {
    "difficulty": 1,
    "type": "multiple",
    "question": "Welche HTTP-Methode wird bei GraphQL-Requests in der Übung verwendet?",
    "options": ["GET", "PUT", "POST", "DELETE"],
    "correct": 2,
    "explanation": "✅ Richtig: GraphQL-Anfragen werden typischerweise per POST an einen einzigen Endpoint gesendet, unabhängig davon, ob es sich um Query, Mutation oder Subscription handelt.",
    "xp": 10,
    "tags": ["uebung", "woche6"]
  },
  {
    "difficulty": 1,
    "type": "multiple",
    "question": "Welches Datenformat wird für die Übertragung von GraphQL-Anfragen und -Antworten genutzt?",
    "options": ["XML", "JSON", "CSV", "YAML"],
    "correct": 1,
    "explanation": "✅ Richtig: JSON ist das Standardformat für GraphQL-Request-Payloads und -Responses und gewährleistet strukturierte Daten.",
    "xp": 10,
    "tags": ["uebung", "woche6"]
  },
  {
    "difficulty": 1,
    "type": "multiple",
    "question": "Was ist ein zentrales Merkmal von GraphQL im Vergleich zu REST?",
    "options": [
      "Jede Operation braucht einen eigenen HTTP-Endpoint",
      "Der Client kann exakt angeben, welche Felder er zurückhaben möchte",
      "Es werden ausschließlich GET-Requests verwendet",
      "GraphQL unterstützt keine Mutationen"
    ],
    "correct": 1,
    "explanation": "✅ Richtig: GraphQL erlaubt es dem Client, in der Query präzise zu spezifizieren, welche Felder er benötigt – das reduziert Over- und Underfetching.",
    "xp": 12,
    "tags": ["uebung", "woche6"]
  },
  {
    "difficulty": 1,
    "type": "multiple",
    "question": "Welche Operation aus dem Schema ist eine \"read\"-Operation (Query)?",
    "options": ["addUser", "updateUser", "deleteUser", "allUsers"],
    "correct": 3,
    "explanation": "✅ Richtig: allUsers ist eine Query zum Abrufen von Daten. Mutationen wie addUser, updateUser oder deleteUser verändern Daten.",
    "xp": 10,
    "tags": ["uebung", "woche6"]
  },
  {
    "difficulty": 1,
    "type": "fillblank",
    "question": "Der Typ _____ im GraphQL-Schema beschreibt die Struktur eines User-Objekts mit seinen Feldern.",
    "blanks": ["User"],
    "explanation": "✅ Richtig: Der User-Typ definiert die Feldstruktur (id, firstName, lastName etc.) und legt fest, welche Daten ein User-Objekt enthält.",
    "xp": 15,
    "tags": ["uebung", "woche6"]
  },
  {
    "difficulty": 1,
    "type": "multiple",
    "question": "Was bedeutet das Ausrufezeichen ! hinter einem Feldtyp im GraphQL-Schema (z. B. firstName: String!)?",
    "options": [
      "Das Feld ist veraltet",
      "Das Feld wird clientseitig berechnet",
      "Das Feld darf nicht null sein",
      "Das Feld ist optional"
    ],
    "correct": 2,
    "explanation": "✅ Richtig: Das ! markiert ein Pflichtfeld – der Server garantiert, dass dieses Feld nie null ist.",
    "xp": 12,
    "tags": ["uebung", "woche6"]
  },
  {
    "difficulty": 1,
    "type": "checkbox",
    "question": "Welche Scalar-Typen gehören zu den standardmäßig in GraphQL unterstützten Typen? (Mehrfachauswahl)",
    "options": ["Int", "Float", "String", "Boolean", "ID"],
    "correct": [0, 1, 2, 3, 4],
    "explanation": "✅ Richtig: GraphQL definiert die fünf Standard-Scalar-Typen Int, Float, String, Boolean und ID – sie bilden die Basis für alle Felder.",
    "xp": 15,
    "tags": ["uebung", "woche6"]
  },
  {
    "difficulty": 1,
    "type": "multiple",
    "question": "Welche Operationen werden in GraphQL typischerweise über Mutation abgebildet?",
    "options": [
      "Nur Lese-Operationen",
      "Änderungen, Erstellungen oder Löschungen von Daten",
      "Nur Logging-Operationen",
      "Nur Authentifizierungs-Operationen"
    ],
    "correct": 1,
    "explanation": "✅ Richtig: Mutationen dienen zum Erstellen, Ändern oder Löschen von Daten – im Gegensatz zu Queries, die nur lesen.",
    "xp": 12,
    "tags": ["uebung", "woche6"]
  },
  {
    "difficulty": 1,
    "type": "multiple",
    "question": "Welche Query im Schema unterstützt Paging-Funktionalität?",
    "options": ["allUsers", "users", "userById", "addUser"],
    "correct": 1,
    "explanation": "✅ Richtig: Die Query users(offset: Int, limit: Int) ermöglicht Paging durch optionale Parameter für Offset und Limit.",
    "xp": 12,
    "tags": ["uebung", "woche6"]
  },
  {
    "difficulty": 1,
    "type": "multiple",
    "question": "Wie werden die GraphQL-Schema-Dateien in der Beispielanwendung organisiert?",
    "options": [
      "In src/main/resources/graphql",
      "In src/main/resources/templates",
      "In src/main/java/graphql",
      "In src/test/resources/graphql"
    ],
    "correct": 0,
    "explanation": "✅ Richtig: Spring for GraphQL sucht Schema-Dateien standardmäßig unter src/main/resources/graphql und lädt sie automatisch.",
    "xp": 12,
    "tags": ["uebung", "woche6"]
  },
  {
    "difficulty": 1,
    "type": "multiple",
    "question": "Welche Annotation wird im Spring-Controller verwendet, um eine Query wie allUsers zu binden?",
    "options": ["@GetMapping", "@QueryMapping", "@GraphQLQuery", "@RestController"],
    "correct": 1,
    "explanation": "✅ Richtig: @QueryMapping verknüpft eine Controller-Methode mit einer GraphQL-Query aus dem Schema.",
    "xp": 12,
    "tags": ["uebung", "woche6"]
  },
  {
    "difficulty": 1,
    "type": "multiple",
    "question": "Welche Annotation wird verwendet, um eine Mutation wie deleteUser zu binden?",
    "options": ["@MutationMapping", "@PostMapping", "@PatchMapping", "@CommandMapping"],
    "correct": 0,
    "explanation": "✅ Richtig: @MutationMapping bindet Controller-Methoden an Mutation-Operationen im GraphQL-Schema.",
    "xp": 12,
    "tags": ["uebung", "woche6"]
  },
  {
    "difficulty": 2,
    "type": "multiple",
    "question": "Wozu dient die Annotation @SchemaMapping(typeName = \"User\") auf Klassenebene?",
    "options": [
      "Sie aktiviert die HTTP-Security für die Klasse",
      "Sie legt fest, dass alle Handler-Methoden dieser Klasse sich standardmäßig auf den Typ User im Schema beziehen",
      "Sie erzeugt automatisch das User-Repository",
      "Sie registriert den Controller als REST-Endpoint unter /user"
    ],
    "correct": 1,
    "explanation": "✅ Richtig: @SchemaMapping(typeName = \"User\") setzt den Kontext für alle Handler in der Klasse – sie beziehen sich auf den User-Typ.",
    "xp": 18,
    "tags": ["uebung", "woche6"]
  },
  {
    "difficulty": 1,
    "type": "fillblank",
    "question": "Um die GraphiQL-Oberfläche zu aktivieren, wird in application.properties die Eigenschaft _____ auf true gesetzt.",
    "blanks": ["spring.graphql.graphiql.enabled"],
    "explanation": "✅ Richtig: spring.graphql.graphiql.enabled=true aktiviert die integrierte GraphiQL-Oberfläche für interaktive Tests.",
    "xp": 15,
    "tags": ["uebung", "woche6"]
  },
  {
    "difficulty": 1,
    "type": "multiple",
    "question": "Unter welcher URI wird der GraphiQL-Editor in der Übung aufgerufen?",
    "options": [
      "http://127.0.0.1:8080/graphql-ui",
      "http://127.0.0.1:8080/graphiql?path=/graphql",
      "http://127.0.0.1:8080/api/graphiql",
      "http://127.0.0.1:8080/graphqleditor"
    ],
    "correct": 1,
    "explanation": "✅ Richtig: GraphiQL ist unter /graphiql?path=/graphql erreichbar und bietet eine grafische Oberfläche zum Testen von Queries und Mutationen.",
    "xp": 12,
    "tags": ["uebung", "woche6"]
  },
  {
    "difficulty": 1,
    "type": "multiple",
    "question": "Welche Dependency stellt in der Spring-Boot-Anwendung die GraphQL-Funktionalität bereit?",
    "options": [
      "spring-boot-starter-data-jpa",
      "spring-boot-starter-webflux",
      "spring-boot-starter-graphql",
      "spring-boot-starter-thymeleaf"
    ],
    "correct": 2,
    "explanation": "✅ Richtig: spring-boot-starter-graphql bringt die nötigen Bibliotheken für Spring for GraphQL und den GraphQL-Endpoint mit.",
    "xp": 12,
    "tags": ["uebung", "woche6"]
  },
  {
    "difficulty": 2,
    "type": "multiple",
    "question": "Was ist der Zweck der Klasse HttpSyncGraphQlClient im GraphQL-Client?",
    "options": [
      "Sie implementiert einen asynchronen Non-Blocking-Client",
      "Sie stellt eine synchrone GraphQL-Client-API auf Basis eines REST-Clients bereit",
      "Sie rendert GraphQL-Antworten als HTML",
      "Sie ersetzt den DispatcherServlet"
    ],
    "correct": 1,
    "explanation": "✅ Richtig: HttpSyncGraphQlClient ermöglicht synchrone GraphQL-Anfragen über HTTP und baut auf RestClient auf.",
    "xp": 18,
    "tags": ["uebung", "woche6"]
  },
  {
    "difficulty": 1,
    "type": "multiple",
    "question": "Wie wird in der Client-Methode getAllUsers() die GraphQL-Query repräsentiert?",
    "options": [
      "Als Java-Annotation",
      "Als XML-Datei",
      "Als String document mit der GraphQL-Syntax",
      "Als JSON-Schema"
    ],
    "correct": 2,
    "explanation": "✅ Richtig: Die Query wird als String document = \"{ allUsers { ... } }\" definiert und an den Server gesendet.",
    "xp": 12,
    "tags": ["uebung", "woche6"]
  },
  {
    "difficulty": 1,
    "type": "multiple",
    "question": "Welche Methode des GraphQL-Clients wird verwendet, um die Antwort in eine Liste von User-Objekten umzuwandeln?",
    "options": ["toList()", "toEntity(User.class)", "toEntityList(User.class)", "mapToList(User.class)"],
    "correct": 2,
    "explanation": "✅ Richtig: toEntityList(User.class) wandelt die JSON-Antwort in eine typisierte Liste von User-Objekten um.",
    "xp": 12,
    "tags": ["uebung", "woche6"]
  },
  {
    "difficulty": 1,
    "type": "multiple",
    "question": "Was passiert in der Methode deleteUser(int id) im GraphQL-Client?",
    "options": [
      "Es wird ein REST-DELETE auf /users/{id} gesendet",
      "Es wird eine GraphQL-Mutation deleteUser mit der übergebenen ID ausgeführt",
      "Es wird nur lokal aus der Liste entfernt",
      "Es wird ein WebSocket-Event gesendet"
    ],
    "correct": 1,
    "explanation": "✅ Richtig: Die Methode führt eine GraphQL-Mutation aus: mutation { deleteUser(id: ...) } – keine REST-Operationen.",
    "xp": 12,
    "tags": ["uebung", "woche6"]
  },
  {
    "difficulty": 2,
    "type": "multiple",
    "question": "Welche Aufgabe hat die Methode logExceptionalResponse(ClientGraphQlResponse response) im Client?",
    "options": [
      "Sie loggt erfolgreiche Responses",
      "Sie wandelt die Antwort in JSON um",
      "Sie protokolliert Fehler und Response-Fehlermeldungen",
      "Sie führt Retries bei Timeout durch"
    ],
    "correct": 2,
    "explanation": "✅ Richtig: logExceptionalResponse() prüft auf Fehler in der Antwort (response.getErrors()) und loggt diese für Debugging-Zwecke.",
    "xp": 18,
    "tags": ["uebung", "woche6"]
  },
  {
    "difficulty": 1,
    "type": "fillblank",
    "question": "Der GraphQL-Endpoint wird im Client als statische Variable _____ = \"http://localhost:8080/graphql\" definiert.",
    "blanks": ["baseURI"],
    "explanation": "✅ Richtig: Die Variable baseURI speichert die URL des GraphQL-Servers und wird beim Client-Aufbau verwendet.",
    "xp": 15,
    "tags": ["uebung", "woche6"]
  },
  {
    "difficulty": 1,
    "type": "multiple",
    "question": "Was ist der Zweck von GraphQL-Subscriptions?",
    "options": [
      "Einmalige Lese-Anfragen",
      "Serverseitiges Streaming von Datenänderungen an den Client",
      "Nur zum Löschen von Daten",
      "Nur für Authentifizierung"
    ],
    "correct": 1,
    "explanation": "✅ Richtig: Subscriptions ermöglichen es dem Server, Datenänderungen in Echtzeit an verbundene Clients zu streamen.",
    "xp": 12,
    "tags": ["uebung", "woche6"]
  },
  {
    "difficulty": 1,
    "type": "multiple",
    "question": "Welcher zusätzliche Datentyp wird für das Subscription-Beispiel definiert?",
    "options": ["UserEvent", "StockPrice", "SubscriptionEvent", "PriceHistory"],
    "correct": 1,
    "explanation": "✅ Richtig: Der Typ StockPrice (mit Feldern wie symbol, price, timestamp) wird im Schema definiert, um Aktienkurse zu streamen.",
    "xp": 12,
    "tags": ["uebung", "woche6"]
  },
  {
    "difficulty": 1,
    "type": "multiple",
    "question": "Welche Annotation kennzeichnet im Controller eine GraphQL-Subscription-Methode?",
    "options": ["@QueryMapping", "@MutationMapping", "@SubscriptionMapping", "@WebSocketMapping"],
    "correct": 2,
    "explanation": "✅ Richtig: @SubscriptionMapping bindet eine Controller-Methode an eine Subscription-Operation aus dem Schema.",
    "xp": 12,
    "tags": ["uebung", "woche6"]
  },
  {
    "difficulty": 2,
    "type": "multiple",
    "question": "Warum wird im Subscription-Beispiel die Klasse Flux verwendet?",
    "options": [
      "Um HTML-Templates zu parsen",
      "Um reaktive Datenströme mit regelmäßigen Intervallen zu erzeugen",
      "Um Datenbanktransaktionen zu verwalten",
      "Um REST-Endpunkte zu registrieren"
    ],
    "correct": 1,
    "explanation": "✅ Richtig: Flux (aus Project Reactor) ermöglicht reaktive, asynchrone Datenströme – ideal für kontinuierliche Subscriptions.",
    "xp": 18,
    "tags": ["uebung", "woche6"]
  },
  {
    "difficulty": 1,
    "type": "fillblank",
    "question": "Der WebSocket-Endpoint für GraphQL-Subscriptions wird in application.properties als _____ konfiguriert.",
    "blanks": ["/graphqlws"],
    "explanation": "✅ Richtig: spring.graphql.websocket.path=/graphqlws legt den WebSocket-Pfad fest, über den Subscriptions laufen.",
    "xp": 15,
    "tags": ["uebung", "woche6"]
  },
  {
    "difficulty": 1,
    "type": "multiple",
    "question": "Welche zusätzliche Spring-Boot-Dependency wird für WebSockets benötigt?",
    "options": [
      "spring-boot-starter-security",
      "spring-boot-starter-web",
      "spring-boot-starter-websocket",
      "spring-boot-starter-logging"
    ],
    "correct": 2,
    "explanation": "✅ Richtig: spring-boot-starter-websocket bringt die WebSocket-Infrastruktur mit, die für GraphQL-Subscriptions nötig ist.",
    "xp": 12,
    "tags": ["uebung", "woche6"]
  },
  {
    "difficulty": 1,
    "type": "multiple",
    "question": "Wofür wird der Parameter wsPath=/graphqlws in der GraphiQL-URL verwendet?",
    "options": [
      "Zur Angabe des REST-Endpoints",
      "Zur Konfiguration des Datenbankpfads",
      "Zur Angabe des WebSocket-Endpoints für Subscriptions",
      "Zur Auswahl des Schemanamens"
    ],
    "correct": 2,
    "explanation": "✅ Richtig: wsPath=/graphqlws teilt GraphiQL mit, wo es sich für Subscriptions per WebSocket verbinden soll.",
    "xp": 12,
    "tags": ["uebung", "woche6"]
  },
  {
    "difficulty": 2,
    "type": "multiple",
    "question": "Wie unterscheidet sich die Ausführung mehrerer Operationen (Queries/Mutations) in einer GraphQL-Request vom typischen REST-Ansatz?",
    "options": [
      "In GraphQL kann nur genau eine Operation pro Request gesendet werden",
      "In GraphQL können mehrere Operationen in einer einzigen HTTP-Request kombiniert werden",
      "REST unterstützt grundsätzlich keine POST-Requests",
      "REST sendet immer mehrere Operationen automatisch"
    ],
    "correct": 1,
    "explanation": "✅ Richtig: GraphQL erlaubt Batching mehrerer Queries/Mutations in einem Request – REST benötigt in der Regel separate Calls.",
    "xp": 18,
    "tags": ["uebung", "woche6"]
  },
  {
    "difficulty": 1,
    "type": "matching",
    "question": "Ordnen Sie die entsprechenden HTTP-Statuscodes richtig zu:",
    "pairs": [
      {
        "left": "Ressource erfolgreich erstellt",
        "right": "201 (Created)"
      },
      {
        "left": "Anfrage konnte aufgrund fehlerhafter Parameter nicht verarbeitet werden",
        "right": "422 (Unprocessable Entity)"
      },
      {
        "left": "Anfrage erfolgreich, Inhalt im Body vorhanden",
        "right": "200 (OK)"
      },
      {
        "left": "Ressource nicht gefunden",
        "right": "404 (Not Found)"
      },
      {
        "left": "Anfrage erfolgreich, aber keine Rückgabe",
        "right": "204 (No Content)"
      }
    ],
    "explanation": "✅ Richtig: 201 = Created (neue Ressource), 422 = Unprocessable Entity (fehlerhafte Parameter), 200 = OK (Erfolg mit Body), 404 = Not Found (unbekannte URI), 204 = No Content (Erfolg ohne Body).",
    "xp": 20,
    "tags": ["offiziell", "woche5"]
  },
  {
    "difficulty": 1,
    "type": "multiple",
    "question": "Welche Annotation wird verwendet, um eine Klasse als REST-Controller zu markieren?",
    "options": ["@RestController", "@Controller", "@ResponseEntity", "@Service"],
    "correct": 0,
    "explanation": "✅ Richtig: @RestController kombiniert @Controller und @ResponseBody – die Rückgabewerte werden direkt serialisiert (z. B. als JSON).",
    "xp": 10,
    "tags": ["offiziell", "woche5"]
  },
  {
    "difficulty": 1,
    "type": "multiple",
    "question": "Ressourcen-URIs im REST-Design sollen möglichst Verben enthalten, um Aktionen zu beschreiben.",
    "options": ["Wahr", "Falsch"],
    "correct": 1,
    "explanation": "✅ Richtig: URIs sollten Substantive (Ressourcen) verwenden, z. B. /users/123. Aktionen werden durch HTTP-Methoden (GET, POST, PUT, DELETE) ausgedrückt.",
    "xp": 10,
    "tags": ["offiziell", "woche5"]
  },
  {
    "difficulty": 1,
    "type": "multiple",
    "question": "REST-Kommunikation ist immer synchron.",
    "options": ["Wahr", "Falsch"],
    "correct": 1,
    "explanation": "✅ Richtig: REST ist typischerweise synchron (Request-Response), kann aber mit Callbacks, Webhooks oder asynchronen Patterns (z. B. 202 Accepted) asynchron gestaltet werden.",
    "xp": 12,
    "tags": ["offiziell", "woche5"]
  },
  {
    "difficulty": 1,
    "type": "multiple",
    "question": "GET-Anfragen können den HTTP-Body enthalten. (Im Sinne der Best Practice)",
    "options": ["Wahr", "Falsch"],
    "correct": 1,
    "explanation": "✅ Richtig: Laut HTTP-Spezifikation ist ein Body bei GET technisch erlaubt, aber Best Practice und viele Frameworks ignorieren ihn – Parameter gehören in die URL.",
    "xp": 12,
    "tags": ["offiziell", "woche5"]
  },
  {
    "difficulty": 1,
    "type": "multiple",
    "question": "Was bedeutet es, dass REST-Kommunikation zustandslos ist?",
    "options": [
      "Kommunikation erfolgt synchron",
      "Der Server speichert keine Sitzungsinformationen",
      "Der Client hält die Sitzungsinformationen",
      "Der Server speichert alle Client-Daten"
    ],
    "correct": 1,
    "explanation": "✅ Richtig: Stateless bedeutet, der Server speichert keinen Session-State – jede Anfrage enthält alle benötigten Informationen (z. B. via Token).",
    "xp": 12,
    "tags": ["offiziell", "woche5"]
  },
  {
    "difficulty": 2,
    "type": "checkbox",
    "question": "Markieren Sie alle HTTP-Methoden, die sowohl 'safe' (sicher) als auch 'idempotent' (idempotent) sind:",
    "options": ["GET", "POST", "PUT", "DELETE", "HEAD", "OPTIONS", "PATCH"],
    "correct": [0, 4, 5],
    "explanation": "✅ Richtig: GET, HEAD und OPTIONS sind safe (keine Seiteneffekte) und idempotent (wiederholbar ohne Änderung). POST und PATCH sind weder safe noch idempotent. PUT und DELETE sind idempotent, aber nicht safe.",
    "xp": 18,
    "tags": ["offiziell", "woche5"]
  },
  {
    "difficulty": 1,
    "type": "checkbox",
    "question": "Markieren Sie alle HTTP-Methoden, die idempotent sind (wiederholbare Aufrufe führen zum gleichen Zustand):",
    "options": ["GET", "POST", "PUT", "DELETE", "HEAD", "OPTIONS", "PATCH"],
    "correct": [0, 2, 3, 4, 5],
    "explanation": "✅ Richtig: GET, PUT, DELETE, HEAD und OPTIONS sind idempotent. POST ist nicht idempotent (erzeugt mehrfach Ressourcen). PATCH ist typischerweise nicht idempotent.",
    "xp": 15,
    "tags": ["offiziell", "woche5"]
  },
  {
    "difficulty": 1,
    "type": "multiple",
    "question": "Eine Ressource kann nur aus einem einzelnen Objekt bestehen, niemals aus einer Liste.",
    "options": ["Wahr", "Falsch"],
    "correct": 1,
    "explanation": "✅ Richtig: Eine Ressource kann sowohl eine einzelne Entität (/users/123) als auch eine Sammlung (/users) darstellen.",
    "xp": 10,
    "tags": ["offiziell", "woche5"]
  },
  {
    "difficulty": 1,
    "type": "multiple",
    "question": "Ein MVC-Controller ist darauf ausgelegt, View-Namen zurückzugeben und ein Modell für die Darstellung in HTML-Seiten anzureichern.",
    "options": ["Wahr", "Falsch"],
    "correct": 0,
    "explanation": "✅ Richtig: Klassische @Controller in Spring MVC geben View-Namen (z. B. \"index\") zurück und füllen das Model für Template-Engines wie Thymeleaf.",
    "xp": 10,
    "tags": ["offiziell", "woche5"]
  },
  {
    "difficulty": 1,
    "type": "multiple",
    "question": "Es ist sinnvoll, Nutzdaten bei HTTP-POST- oder PUT-Requests im URL-Parameter zu übertragen, da URLs für alle Nutzdaten optimiert sind.",
    "options": ["Wahr", "Falsch"],
    "correct": 1,
    "explanation": "✅ Richtig: Nutzdaten (z. B. JSON) gehören in den HTTP-Body, nicht in URL-Parameter – URLs sind begrenzt, unsicher für sensible Daten und schlecht lesbar bei großen Payloads.",
    "xp": 12,
    "tags": ["offiziell", "woche5"]
  },
  {
    "difficulty": 1,
    "type": "multiple",
    "question": "Primärsammlungen sind Hauptsammlungen von Ressourcen, während Sekundärsammlungen Untersammlungen innerhalb einer Primärsammlung sind.",
    "options": ["Wahr", "Falsch"],
    "correct": 0,
    "explanation": "✅ Richtig: Primärsammlung: /users (Hauptressource). Sekundärsammlung: /users/123/orders (Unterressourcen eines Users).",
    "xp": 12,
    "tags": ["offiziell", "woche5"]
  },
  {
    "difficulty": 1,
    "type": "multiple",
    "question": "Ohne HATEOAS wäre eine REST-API immer vollständig und intuitiv navigierbar.",
    "options": ["Wahr", "Falsch"],
    "correct": 1,
    "explanation": "✅ Richtig: HATEOAS (Hypermedia As The Engine Of Application State) macht APIs navigierbar, indem Responses Links zu verwandten Ressourcen enthalten – ohne HATEOAS muss der Client alle URIs kennen.",
    "xp": 12,
    "tags": ["offiziell", "woche5"]
  },
  {
    "difficulty": 1,
    "type": "multiple",
    "question": "Die HTTP-Methoden @GetMapping, @PostMapping, @PutMapping und @DeleteMapping werden sowohl in MVC- als auch in REST-Controllern zur Behandlung von Requests verwendet, unterscheiden sich aber in der Art der Rückgabe.",
    "options": ["Wahr", "Falsch"],
    "correct": 0,
    "explanation": "✅ Richtig: Die Annotations sind identisch – der Unterschied liegt in der Rückgabe: MVC-Controller geben View-Namen zurück, REST-Controller (@RestController) serialisieren direkt zu JSON/XML.",
    "xp": 12,
    "tags": ["offiziell", "woche5"]
  },
  {
    "difficulty": 1,
    "type": "multiple",
    "question": "RESTful APIs verwenden häufig JSON für Datenrepräsentation.",
    "options": ["Wahr", "Falsch"],
    "correct": 0,
    "explanation": "✅ Richtig: JSON ist das Standard-Datenformat für moderne REST-APIs – es ist kompakt, lesbar und wird von allen Plattformen unterstützt.",
    "xp": 10,
    "tags": ["offiziell", "woche5"]
  },
  {
    "difficulty": 1,
    "type": "multiple",
    "question": "Im REST-Paradigma ist Sitzungsverwaltung (Session Management) zwingend erforderlich.",
    "options": ["Wahr", "Falsch"],
    "correct": 1,
    "explanation": "✅ Richtig: REST ist stateless – keine serverseitige Session nötig. Authentifizierung erfolgt per Token (z. B. JWT) in jedem Request.",
    "xp": 12,
    "tags": ["offiziell", "woche5"]
  },
  {
    "difficulty": 1,
    "type": "multiple",
    "question": "Welche HTTP-Methode wird verwendet, um neue Ressourcen zu erstellen?",
    "options": ["DELETE", "PATCH", "GET", "POST"],
    "correct": 3,
    "explanation": "✅ Richtig: POST erstellt neue Ressourcen (z. B. POST /users mit JSON-Body) – der Server generiert die ID und gibt 201 Created zurück.",
    "xp": 10,
    "tags": ["offiziell", "woche5"]
  },
  {
    "difficulty": 1,
    "type": "multiple",
    "question": "Eine Sammelressource sollte nur die wichtigsten Informationen über die enthaltenen Einzelressourcen zurückliefern, um die Antwort klein zu halten.",
    "options": ["Wahr", "Falsch"],
    "correct": 0,
    "explanation": "✅ Richtig: Collections (z. B. GET /users) liefern oft nur Basis-Felder (id, name) – Details per GET /users/123. Das reduziert Payload-Größe und Ladezeit.",
    "xp": 12,
    "tags": ["offiziell", "woche5"]
  },
  {
    "difficulty": 1,
    "type": "checkbox",
    "question": "Welche Formate werden häufig für die Darstellung von REST-Ressourcen verwendet? (Mehrfachauswahl)",
    "options": ["HTML", "XML", "YAML", "JSON", "CSV"],
    "correct": [1, 3],
    "explanation": "✅ Richtig: JSON und XML sind die Standard-Formate für REST-APIs. JSON dominiert heute aufgrund seiner Einfachheit und Kompaktheit.",
    "xp": 12,
    "tags": ["offiziell", "woche5"]
  },
  {
    "difficulty": 1,
    "type": "multiple",
    "question": "HATEOAS bedeutet, dass der Client alle möglichen URLs und Aktionen bereits kennen muss, bevor er mit der API kommuniziert.",
    "options": ["Wahr", "Falsch"],
    "correct": 1,
    "explanation": "✅ Richtig: HATEOAS ist das Gegenteil – der Server liefert dynamisch Links zu verfügbaren Aktionen mit, sodass der Client nur den Entry-Point kennen muss.",
    "xp": 12,
    "tags": ["offiziell", "woche5"]
  },
  {
    "difficulty": 2,
    "type": "multiple",
    "question": "Gegeben sei die HTTP-Antwort:\n\nHTTP/1.1 201 Created\nLocation: http://127.0.0.1:8080/api/v1/users/alice\nContent-Type: application/json\n\nWelche HTTP-Methode mit Ressource wurde verwendet?",
    "options": [
      "POST /users/alice",
      "PUT /users/alice",
      "DELETE /users/alice",
      "GET /users/alice",
      "POST /users"
    ],
    "correct": 4,
    "explanation": "✅ Richtig: 201 Created + Location-Header zeigen, dass eine neue Ressource erstellt wurde. POST /users (Collection) erstellt eine neue User-Ressource – der Server generiert die ID (alice) und gibt die URI im Location-Header zurück.",
    "xp": 18,
    "tags": ["offiziell", "woche5"]
  },
  {
    "difficulty": 1,
    "type": "multiple",
    "question": "HATEOAS ist ein Konzept innerhalb von REST, das sicherstellt, dass die API dem Client über Links im Response mitteilt, welche nächsten Schritte möglich sind.",
    "options": ["Wahr", "Falsch"],
    "correct": 0,
    "explanation": "✅ Richtig: HATEOAS (Hypermedia as the Engine of Application State) nutzt Hyperlinks in Responses, um dem Client dynamisch verfügbare Aktionen mitzuteilen.",
    "xp": 12,
    "tags": ["offiziell", "woche5"]
  },
  {
    "difficulty": 1,
    "type": "multiple",
    "question": "Welches Prinzip beschreibt die REST-Anforderung, dass eine Ressource immer über eine URI identifiziert wird?",
    "options": [
      "Standardmethoden",
      "Zustandlose Kommunikation",
      "Hypermedia",
      "Eindeutige Identifikation von Ressourcen"
    ],
    "correct": 3,
    "explanation": "✅ Richtig: REST verlangt, dass jede Ressource durch eine eindeutige URI identifizierbar ist – das ist das Prinzip der Ressourcen-Identifikation.",
    "xp": 12,
    "tags": ["offiziell", "woche5"]
  },
  {
    "difficulty": 1,
    "type": "multiple",
    "question": "Einzelressourcen enthalten vollständige Informationen zu einer spezifischen Entität und können Links zu anderen Ressourcen enthalten.",
    "options": ["Wahr", "Falsch"],
    "correct": 0,
    "explanation": "✅ Richtig: Einzelressourcen (z. B. GET /users/123) liefern alle Details einer Entität und oft HATEOAS-Links zu verwandten Ressourcen (z. B. /users/123/orders).",
    "xp": 10,
    "tags": ["offiziell", "woche5"]
  },
  {
    "difficulty": 1,
    "type": "multiple",
    "question": "HATEOAS stellt sicher, dass der Client weiß, welche Aktionen als Nächstes möglich sind.",
    "options": ["Wahr", "Falsch"],
    "correct": 0,
    "explanation": "✅ Richtig: Durch eingebettete Links in Responses weiß der Client dynamisch, welche Aktionen verfügbar sind – er muss keine URIs vorher kennen.",
    "xp": 10,
    "tags": ["offiziell", "woche5"]
  },
  {
    "difficulty": 1,
    "type": "multiple",
    "question": "REST definiert, dass Ressourcen immer durch eine eindeutige URI identifiziert werden.",
    "options": ["Wahr", "Falsch"],
    "correct": 0,
    "explanation": "✅ Richtig: Jede Ressource hat eine eindeutige URI – das ist ein Grundprinzip von REST (Uniform Resource Identifier).",
    "xp": 10,
    "tags": ["offiziell", "woche5"]
  },
  {
    "difficulty": 1,
    "type": "multiple",
    "question": "Der HTTP-Statuscode 204 No Content bedeutet, dass keine Daten im Body zurückgegeben werden.",
    "options": ["Wahr", "Falsch"],
    "correct": 0,
    "explanation": "✅ Richtig: 204 No Content signalisiert erfolgreiche Verarbeitung ohne Response-Body – typisch bei DELETE oder bei leeren Collections.",
    "xp": 10,
    "tags": ["offiziell", "woche5"]
  },
  {
    "difficulty": 1,
    "type": "multiple",
    "question": "REST und HATEOAS sind zwei völlig unabhängige Architekturen, die nichts miteinander zu tun haben.",
    "options": ["Wahr", "Falsch"],
    "correct": 1,
    "explanation": "✅ Richtig: HATEOAS ist Teil der REST-Architektur (Level 3 im Richardson Maturity Model) – es erweitert REST um Hypermedia-Links für dynamische Navigation.",
    "xp": 12,
    "tags": ["offiziell", "woche5"]
  },
  {
    "difficulty": 1,
    "type": "multiple",
    "question": "Sekundärsammlungen sind eigenständige, unabhängige Ressourcen, die keine Beziehung zu einer Primärsammlung haben.",
    "options": ["Wahr", "Falsch"],
    "correct": 1,
    "explanation": "✅ Richtig: Sekundärsammlungen sind Unterressourcen einer Primärsammlung – z. B. /users/123/orders (Orders eines bestimmten Users).",
    "xp": 12,
    "tags": ["offiziell", "woche5"]
  },
  {
    "difficulty": 1,
    "type": "multiple",
    "question": "Ein ResponseEntity-Objekt kann HTTP-Status, Header und Body enthalten.",
    "options": ["Wahr", "Falsch"],
    "correct": 0,
    "explanation": "✅ Richtig: ResponseEntity in Spring ermöglicht volle Kontrolle über HTTP-Responses – Status (z. B. 201), Header (z. B. Location) und Body (z. B. JSON).",
    "xp": 10,
    "tags": ["offiziell", "woche5"]
  },
  {
    "difficulty": 1,
    "type": "multiple",
    "question": "Ein GET-Request darf niemals Daten auf dem Server verändern.",
    "options": ["Wahr", "Falsch"],
    "correct": 0,
    "explanation": "✅ Richtig: GET ist eine 'safe' Methode – sie darf keine Seiteneffekte (Datenänderungen) verursachen, sondern nur lesen.",
    "xp": 10,
    "tags": ["offiziell", "woche5"]
  },
  {
    "difficulty": 1,
    "type": "multiple",
    "question": "Jede Ressource oder Sammlung muss mindestens einen Link enthalten, der typischerweise auf sich selbst verweist (Self-Link).",
    "options": ["Wahr", "Falsch"],
    "correct": 0,
    "explanation": "✅ Richtig: In HATEOAS-konformen REST-APIs enthält jede Ressource einen Self-Link (rel=\"self\") zur eigenen URI – das ermöglicht eindeutige Referenzierung.",
    "xp": 12,
    "tags": ["offiziell", "woche5"]
  },
  {
    "difficulty": 1,
    "type": "multiple",
    "question": "Der HTTP-Statuscode 404 bedeutet \"Nicht gefunden\".",
    "options": ["Wahr", "Falsch"],
    "correct": 0,
    "explanation": "✅ Richtig: 404 Not Found signalisiert, dass die angeforderte Ressource unter der angegebenen URI nicht existiert.",
    "xp": 10,
    "tags": ["offiziell", "woche5"]
  },
  {
    "difficulty": 1,
    "type": "checkbox",
    "question": "Welche HTTP-Statuscodes beschreiben eine erfolgreiche Anfrage? (Mehrfachauswahl)",
    "options": ["200", "201", "204", "301", "404", "422"],
    "correct": [0, 1, 2],
    "explanation": "✅ Richtig: 200 OK (Erfolg mit Body), 201 Created (Ressource erstellt), 204 No Content (Erfolg ohne Body) sind Erfolgs-Statuscodes (2xx). 301 ist Redirect, 404/422 sind Fehler.",
    "xp": 15,
    "tags": ["offiziell", "woche5"]
  },
  {
    "difficulty": 1,
    "type": "multiple",
    "question": "HATEOAS fügt den HTTP-Responses Links hinzu, die mögliche nächste Aktionen beschreiben.",
    "options": ["Wahr", "Falsch"],
    "correct": 0,
    "explanation": "✅ Richtig: HATEOAS erweitert REST-Responses mit Hyperlinks (z. B. rel=\"self\", rel=\"next\"), die dem Client verfügbare Aktionen aufzeigen.",
    "xp": 12,
    "tags": ["offiziell", "woche5"]
  },
  {
    "difficulty": 1,
    "type": "multiple",
    "question": "Welche HTTP-Methode wird verwendet, um eine Ressource zu löschen?",
    "options": ["DELETE", "GET", "POST", "PATCH", "PUT"],
    "correct": 0,
    "explanation": "✅ Richtig: DELETE entfernt eine Ressource – z. B. DELETE /users/123 löscht den User mit ID 123.",
    "xp": 10,
    "tags": ["offiziell", "woche5"]
  },
  {
    "difficulty": 1,
    "type": "matching",
    "question": "Ordnen Sie die HTTP-Methoden den entsprechenden Beschreibungen zu:",
    "pairs": [
      {
        "left": "GET",
        "right": "Liest eine Ressource oder eine Liste von Ressourcen"
      },
      {
        "left": "PUT",
        "right": "Aktualisiert oder legt eine Ressource neu an"
      },
      {
        "left": "POST",
        "right": "Erstellt eine neue Ressource"
      },
      {
        "left": "PATCH",
        "right": "Aktualisiert Teile einer bestehenden Ressource"
      },
      {
        "left": "DELETE",
        "right": "Löscht eine Ressource"
      }
    ],
    "explanation": "✅ Richtig: GET = Lesen, POST = Erstellen, PUT = Vollständig aktualisieren/ersetzen, PATCH = Teilweise aktualisieren, DELETE = Löschen.",
    "xp": 20,
    "tags": ["offiziell", "woche5"]
  },
  {
    "difficulty": 1,
    "type": "multiple",
    "question": "Was ist GraphQL im Kern?",
    "options": [
      "Eine Datenbank-Sprache wie SQL",
      "Ein Protokoll zur verschlüsselten Übertragung von HTTP",
      "Ein Frontend-Framework für Single-Page-Apps",
      "Eine Abfragesprache für APIs und eine Server-Laufzeitumgebung auf Basis eines Typsystems"
    ],
    "correct": 3,
    "explanation": "✅ Richtig: GraphQL ist eine Abfragesprache für APIs mit typisiertem Schema – der Client kann präzise definieren, welche Daten er benötigt.",
    "xp": 12,
    "tags": ["uebung", "woche6"]
  },
  {
    "difficulty": 1,
    "type": "multiple",
    "question": "Wie viele Endpunkte nutzt eine typische GraphQL-API?",
    "options": [
      "Einen Endpunkt, z.B. /graphql, für alle Operationen",
      "Einen Endpunkt pro HTTP-Methode",
      "Einen Endpunkt pro Ressource (z.B. /users, /roles)",
      "Einen Endpunkt pro Datenbanktabelle"
    ],
    "correct": 0,
    "explanation": "✅ Richtig: GraphQL nutzt typischerweise einen zentralen Endpunkt (/graphql) für Queries, Mutations und Subscriptions – im Gegensatz zu REST mit vielen ressourcenorientierten Endpunkten.",
    "xp": 12,
    "tags": ["uebung", "woche6"]
  },
  {
    "difficulty": 1,
    "type": "fillblank",
    "question": "Die zentrale Spring Boot Dependency für GraphQL heißt _____.",
    "blanks": ["spring-boot-starter-graphql"],
    "explanation": "✅ Richtig: spring-boot-starter-graphql ist der Starter, der alle benötigten GraphQL-Bibliotheken für Spring Boot bereitstellt.",
    "xp": 15,
    "tags": ["uebung", "woche6"]
  },
  {
    "difficulty": 1,
    "type": "multiple",
    "question": "Welcher weitere Starter ist zusätzlich zu spring-boot-starter-graphql erforderlich, um einen GraphQL-Server zu betreiben?",
    "options": [
      "spring-boot-starter-data-mongodb",
      "spring-boot-starter-jdbc",
      "spring-boot-starter-web",
      "spring-boot-starter-test"
    ],
    "correct": 2,
    "explanation": "✅ Richtig: spring-boot-starter-web stellt den eingebetteten Webserver (Tomcat) bereit, über den der /graphql-Endpunkt erreichbar wird.",
    "xp": 12,
    "tags": ["uebung", "woche6"]
  },
  {
    "difficulty": 1,
    "type": "multiple",
    "question": "Wo wird das GraphQL-Schema typischerweise definiert?",
    "options": [
      "In der application.properties",
      "In der pom.xml",
      "Im Java-Controller",
      "In einer eigenen Schema-Datei (z.B. schema.graphqls)"
    ],
    "correct": 3,
    "explanation": "✅ Richtig: Das GraphQL-Schema wird in .graphqls-Dateien (meist in src/main/resources/graphql) definiert und beschreibt Typen, Queries und Mutations.",
    "xp": 12,
    "tags": ["uebung", "woche6"]
  },
  {
    "difficulty": 1,
    "type": "multiple",
    "question": "Was beschreibt der Typ 'type User' im GraphQL-Schema?",
    "options": [
      "Die möglichen HTTP-Methoden",
      "Die Konfiguration der Datenbankverbindung",
      "Die Struktur des User-Objekts mit seinen Feldern und Typen",
      "Die Error-Handling-Strategie"
    ],
    "correct": 2,
    "explanation": "✅ Richtig: type User definiert die Struktur eines User-Objekts (z. B. id: ID!, firstName: String!) – ähnlich einer Klasse in Java.",
    "xp": 10,
    "tags": ["uebung", "woche6"]
  },
  {
    "difficulty": 1,
    "type": "fillblank",
    "question": "Das Ausrufezeichen _____ hinter einem Feldtyp in GraphQL bedeutet, dass das Feld nicht null sein darf.",
    "blanks": ["!"],
    "explanation": "✅ Richtig: Das ! (z. B. id: ID!) markiert ein Pflichtfeld (Non-Null) – der Server garantiert, dass dieses Feld immer einen Wert hat.",
    "xp": 15,
    "tags": ["uebung", "woche6"]
  },
  {
    "difficulty": 1,
    "type": "matching",
    "question": "Ordnen Sie die GraphQL-Schema-Typen ihren Zwecken zu:",
    "pairs": [
      {
        "left": "type Query",
        "right": "Alle Leseoperationen (Abfragen)"
      },
      {
        "left": "type Mutation",
        "right": "Alle Schreib-/Änderungsoperationen (Erstellen, Ändern, Löschen)"
      },
      {
        "left": "type Subscription",
        "right": "Echtzeitdaten mit fortlaufenden Server-Updates"
      }
    ],
    "explanation": "✅ Richtig: Query = Lesen (GET), Mutation = Schreiben/Ändern (POST/PUT/DELETE), Subscription = Echtzeit-Updates (WebSocket).",
    "xp": 18,
    "tags": ["uebung", "woche6"]
  },
  {
    "difficulty": 1,
    "type": "checkbox",
    "question": "Welche Annotations in Spring ordnen Handler GraphQL-Operationen zu? (Mehrfachauswahl)",
    "options": [
      "@QueryMapping",
      "@GetMapping",
      "@MutationMapping",
      "@PostMapping",
      "@SubscriptionMapping"
    ],
    "correct": [0, 2, 4],
    "explanation": "✅ Richtig: @QueryMapping (Queries), @MutationMapping (Mutations) und @SubscriptionMapping (Subscriptions) sind die GraphQL-spezifischen Annotations.",
    "xp": 15,
    "tags": ["uebung", "woche6"]
  },
  {
    "difficulty": 2,
    "type": "multiple",
    "question": "Wozu dient @SchemaMapping typischerweise?",
    "options": [
      "Zur Konfiguration von Datenbanktabellen",
      "Zur Definition von HTTP-Statuscodes",
      "Zur Zuordnung von Handler-Methoden zu einem bestimmten GraphQL-Typ (z.B. 'User')",
      "Zur Konfiguration von CORS"
    ],
    "correct": 2,
    "explanation": "✅ Richtig: @SchemaMapping(typeName = \"User\") bindet alle Methoden einer Controller-Klasse an den User-Typ im Schema – praktisch für verschachtelte Felder.",
    "xp": 18,
    "tags": ["uebung", "woche6"]
  },
  {
    "difficulty": 1,
    "type": "multiple",
    "question": "Was ist ein zentraler Vorteil von GraphQL gegenüber REST?",
    "options": [
      "Server bestimmt immer, welche Felder geliefert werden",
      "Es können nur einzelne Ressourcen pro Request abgefragt werden",
      "Es können nur GET-Requests genutzt werden",
      "Der Client kann genau festlegen, welche Felder er benötigt (Vermeidung von Over-Fetching)"
    ],
    "correct": 3,
    "explanation": "✅ Richtig: GraphQL ermöglicht präzise Feldselektion – der Client fordert nur die Daten an, die er wirklich braucht (kein Over-Fetching).",
    "xp": 12,
    "tags": ["uebung", "woche6"]
  },
  {
    "difficulty": 1,
    "type": "multiple",
    "question": "Was beschreibt 'Over-Fetching' im Kontext von REST?",
    "options": [
      "Der Client bekommt zu wenig Daten",
      "Der Client bekommt mehr Daten, als er eigentlich benötigt",
      "Der Server bekommt zu viele Requests",
      "Die Daten werden mehrfach gespeichert"
    ],
    "correct": 1,
    "explanation": "✅ Richtig: Over-Fetching bedeutet, der Client erhält unnötige Felder – z. B. GET /users liefert alle User-Felder, auch wenn nur Name + ID benötigt werden.",
    "xp": 12,
    "tags": ["uebung", "woche6"]
  },
  {
    "difficulty": 1,
    "type": "fillblank",
    "question": "GraphQL löst das Problem des Over-Fetching durch _____, bei der der Client nur die konkreten Felder anfordert, die er braucht.",
    "blanks": ["Feldselektion"],
    "explanation": "✅ Richtig: Feldselektion (Field Selection) erlaubt es dem Client, in der Query präzise zu spezifizieren: { id, firstName } statt aller Felder.",
    "xp": 15,
    "tags": ["uebung", "woche6"]
  },
  {
    "difficulty": 1,
    "type": "multiple",
    "question": "Welche HTTP-Methode wird typischerweise für GraphQL-Queries und -Mutations verwendet?",
    "options": [
      "GET für Queries, POST für Mutations",
      "GET für alles",
      "PUT für Mutations",
      "POST für Queries und Mutations"
    ],
    "correct": 3,
    "explanation": "✅ Richtig: GraphQL nutzt standardmäßig POST für alle Operationen (Queries + Mutations) – die Query/Mutation steht im Request-Body.",
    "xp": 12,
    "tags": ["uebung", "woche6"]
  },
  {
    "difficulty": 1,
    "type": "multiple",
    "question": "Welches Datenformat nutzt GraphQL für die Übertragung von Requests und Responses?",
    "options": ["XML", "YAML", "Protobuf", "JSON"],
    "correct": 3,
    "explanation": "✅ Richtig: JSON ist das Standard-Datenformat für GraphQL – sowohl Request-Payloads als auch Responses sind JSON-strukturiert.",
    "xp": 10,
    "tags": ["uebung", "woche6"]
  },
  {
    "difficulty": 1,
    "type": "multiple",
    "question": "Welche der folgenden Aussagen trifft typischerweise auf REST-APIs zu (im Vergleich zu GraphQL)?",
    "options": [
      "Es gibt genau einen Endpunkt",
      "Es gibt viele, ressourcenorientierte Endpunkte (z.B. /users, /users/{id})",
      "Der Client definiert dynamisch die Datenstruktur",
      "Alle Requests laufen standardmäßig über WebSockets"
    ],
    "correct": 1,
    "explanation": "✅ Richtig: REST nutzt viele spezifische Endpunkte pro Ressource (/users, /posts), während GraphQL nur einen zentralen Endpunkt hat.",
    "xp": 12,
    "tags": ["uebung", "woche6"]
  },
  {
    "difficulty": 1,
    "type": "sort",
    "question": "Sortieren Sie die Schritte einer GraphQL-Query in die richtige Reihenfolge:",
    "items": [
      "Client sendet Query an /graphql",
      "Server validiert Query gegen Schema",
      "Server führt Resolver-Funktionen aus",
      "Server gibt JSON-Response mit selektierten Feldern zurück"
    ],
    "correct": [
      "Client sendet Query an /graphql",
      "Server validiert Query gegen Schema",
      "Server führt Resolver-Funktionen aus",
      "Server gibt JSON-Response mit selektierten Feldern zurück"
    ],
    "explanation": "✅ Richtig: 1) Client-Query → 2) Schema-Validierung → 3) Resolver-Ausführung → 4) JSON-Response mit exakten Feldern.",
    "xp": 18,
    "tags": ["uebung", "woche6"]
  },
  {
    "difficulty": 1,
    "type": "multiple",
    "question": "Wofür werden Subscriptions in GraphQL verwendet?",
    "options": [
      "Zum Einmal-Abruf von Daten",
      "Für Echtzeitdaten, bei denen der Server fortlaufend Updates zum Client sendet",
      "Nur zum Löschen von Ressourcen",
      "Nur zum Erstellen von neuen Einträgen"
    ],
    "correct": 1,
    "explanation": "✅ Richtig: Subscriptions ermöglichen Echtzeit-Updates – der Server pusht Änderungen (z. B. neue Nachrichten, Aktienkurse) kontinuierlich an den Client.",
    "xp": 12,
    "tags": ["uebung", "woche6"]
  },
  {
    "difficulty": 1,
    "type": "fillblank",
    "question": "GraphQL-Subscriptions nutzen typischerweise _____ als Transport-Protokoll für Echtzeit-Updates.",
    "blanks": ["WebSockets"],
    "explanation": "✅ Richtig: WebSockets (z. B. /graphqlws) ermöglichen bidirektionale, persistente Verbindungen für Subscription-Updates.",
    "xp": 15,
    "tags": ["uebung", "woche6"]
  },
  {
    "difficulty": 1,
    "type": "checkbox",
    "question": "Was ist im Request-Body einer GraphQL-POST-Anfrage enthalten? (Mehrfachauswahl)",
    "options": [
      "Die GraphQL-Query bzw. Mutation",
      "Die gewünschten Felder (Feldselektion)",
      "Ein SQL-Statement",
      "Nur HTTP-Header",
      "Variablen für die Query"
    ],
    "correct": [0, 1, 4],
    "explanation": "✅ Richtig: Der Request-Body enthält die Query/Mutation, Feldselektion und optional Variablen – alles in JSON-Format.",
    "xp": 15,
    "tags": ["uebung", "woche6"]
  },
  {
    "difficulty": 1,
    "type": "multiple",
    "question": "Was ist ein typischer Vorteil von GraphQL für Frontend-Entwickler?",
    "options": [
      "Es zwingt zu festen, vorgegebenen Response-Strukturen",
      "Jeder neue Use-Case erfordert einen neuen REST-Endpunkt",
      "Sie können exakt die Daten anfordern, die sie für den jeweiligen View brauchen, ohne neue Endpunkte anzufordern",
      "Es erlaubt ausschließlich synchrone Kommunikation"
    ],
    "correct": 2,
    "explanation": "✅ Richtig: Frontend-Entwickler können per Query genau die Daten für ihren View zusammenstellen – keine Backend-Änderungen nötig für neue Kombinationen.",
    "xp": 12,
    "tags": ["uebung", "woche6"]
  },
  {
    "difficulty": 2,
    "type": "matching",
    "question": "Ordnen Sie die GraphQL-Konzepte den REST-Äquivalenten zu:",
    "pairs": [
      {
        "left": "Query",
        "right": "GET-Request"
      },
      {
        "left": "Mutation (erstellen)",
        "right": "POST-Request"
      },
      {
        "left": "Mutation (aktualisieren)",
        "right": "PUT/PATCH-Request"
      },
      {
        "left": "Mutation (löschen)",
        "right": "DELETE-Request"
      },
      {
        "left": "Subscription",
        "right": "WebSocket/Server-Sent Events"
      }
    ],
    "explanation": "✅ Richtig: GraphQL-Operationen entsprechen konzeptionell REST-HTTP-Methoden – Queries = GET, Mutations = POST/PUT/DELETE, Subscriptions = Echtzeit-Streams.",
    "xp": 20,
    "tags": ["uebung", "woche6"]
  },
  {
    "difficulty": 1,
    "type": "multiple",
    "question": "Welche Annotation bindet Subscriptions im Spring-Controller an das GraphQL-Schema?",
    "options": ["@EventListener", "@Async", "@SubscriptionMapping", "@Scheduled"],
    "correct": 2,
    "explanation": "✅ Richtig: @SubscriptionMapping verknüpft eine Controller-Methode mit einer Subscription-Operation im Schema.",
    "xp": 12,
    "tags": ["uebung", "woche6"]
  },
  {
    "difficulty": 1,
    "type": "multiple",
    "question": "GraphQL ist besonders geeignet für mobile Anwendungen mit geringer Bandbreite.",
    "options": ["Wahr", "Falsch"],
    "correct": 0,
    "explanation": "✅ Richtig: GraphQL ermöglicht präzise Feldselektion – mobile Clients können nur notwendige Daten abrufen und so Bandbreite sparen (kein Over-Fetching).",
    "xp": 12,
    "tags": ["offiziell", "woche6"]
  },
  {
    "difficulty": 1,
    "type": "multiple",
    "question": "In GraphQL können Clients genau die Felder abrufen, die sie benötigen.",
    "options": ["Wahr", "Falsch"],
    "correct": 0,
    "explanation": "✅ Richtig: Clients spezifizieren in der Query exakt, welche Felder sie benötigen – z. B. { id, name } statt aller User-Felder.",
    "xp": 10,
    "tags": ["offiziell", "woche6"]
  },
  {
    "difficulty": 1,
    "type": "multiple",
    "question": "GraphQL erlaubt es, genau die Felder zu spezifizieren, die zurückgegeben werden sollen.",
    "options": ["Wahr", "Falsch"],
    "correct": 0,
    "explanation": "✅ Richtig: Die Feldselektion ist ein Kernmerkmal von GraphQL – der Client bestimmt die Antwortstruktur durch die Query.",
    "xp": 10,
    "tags": ["offiziell", "woche6"]
  },
  {
    "difficulty": 1,
    "type": "multiple",
    "question": "In GraphQL gibt es vordefinierte HTTP-Statuscodes für jede Antwort.",
    "options": ["Wahr", "Falsch"],
    "correct": 1,
    "explanation": "✅ Richtig: GraphQL nutzt meist 200 OK auch bei Fehlern – Fehlerdetails stehen im Response-Body unter 'errors', nicht im HTTP-Status.",
    "xp": 12,
    "tags": ["offiziell", "woche6"]
  },
  {
    "difficulty": 1,
    "type": "multiple",
    "question": "HTTP-Methoden wie GET und POST sind in GraphQL vordefinierte Operationen.",
    "options": ["Wahr", "Falsch"],
    "correct": 1,
    "explanation": "✅ Richtig: GraphQL nutzt Query, Mutation und Subscription als Operationen – GET/POST sind nur HTTP-Transport-Methoden, keine GraphQL-Konzepte.",
    "xp": 12,
    "tags": ["offiziell", "woche6"]
  },
  {
    "difficulty": 1,
    "type": "multiple",
    "question": "GraphQL ist ein Datenbanksystem.",
    "options": ["Wahr", "Falsch"],
    "correct": 1,
    "explanation": "✅ Richtig: GraphQL ist eine Abfragesprache für APIs, keine Datenbank – es sitzt zwischen Client und Datenbank/Backend-Services.",
    "xp": 10,
    "tags": ["offiziell", "woche6"]
  },
  {
    "difficulty": 1,
    "type": "multiple",
    "question": "Mit einer Query kann man mehrere Ressourcen in einer einzigen Anfrage abfragen.",
    "options": ["Wahr", "Falsch"],
    "correct": 0,
    "explanation": "✅ Richtig: GraphQL ermöglicht das Abfragen mehrerer Ressourcen in einer Query – z. B. { users { ... } posts { ... } } in einem Request.",
    "xp": 12,
    "tags": ["offiziell", "woche6"]
  },
  {
    "difficulty": 1,
    "type": "multiple",
    "question": "Query ist eine Standardmethode in GraphQL zum Abfragen von Daten.",
    "options": ["Wahr", "Falsch"],
    "correct": 0,
    "explanation": "✅ Richtig: Query ist eine der drei Hauptoperationen in GraphQL (Query, Mutation, Subscription) – sie dient dem Lesen von Daten.",
    "xp": 10,
    "tags": ["offiziell", "woche6"]
  },
  {
    "difficulty": 1,
    "type": "multiple",
    "question": "GraphQL unterstützt neben Queries und Mutations auch Subscriptions, um Daten in Echtzeit zu übertragen.",
    "options": ["Wahr", "Falsch"],
    "correct": 0,
    "explanation": "✅ Richtig: Subscriptions ermöglichen Echtzeit-Updates über WebSockets – der Server pusht Änderungen kontinuierlich an den Client.",
    "xp": 12,
    "tags": ["offiziell", "woche6"]
  },
  {
    "difficulty": 1,
    "type": "multiple",
    "question": "Was ist GraphQL? \nWählen Sie eine Antwort:",
    "options": [
      "a) Eine NoSQL-Datenbank",
      "b) Ein neuer Standard für HTTP",
      "c) Ein Framework für Webentwicklung",
      "d) Eine Abfragesprache für APIs"
    ],
    "correct": 3,
    "explanation": "✅ Richtig: GraphQL ist eine Abfragesprache und Laufzeitumgebung für APIs – entwickelt von Facebook, ermöglicht präzise Datenabfragen.",
    "xp": 10,
    "tags": ["offiziell", "woche6"]
  },
  {
    "difficulty": 1,
    "type": "checkbox",
    "question": "Welche der folgenden Aussagen trifft auf GraphQL zu?\nWählen Sie eine oder mehrere Antworten:",
    "options": [
      "a) GraphQL unterstützt keine Mutations",
      "b) Clients können exakt die Daten anfragen, die sie benötigen",
      "c) GraphQL ist nur für relationale Datenbanken geeignet",
      "d) GraphQL ersetzt REST vollständig"
    ],
    "correct": [1],
    "explanation": "✅ Richtig: Nur b) ist korrekt – GraphQL unterstützt Mutations, ist datenbankagnostisch und koexistiert oft mit REST.",
    "xp": 15,
    "tags": ["offiziell", "woche6"]
  },
  {
    "difficulty": 1,
    "type": "multiple",
    "question": "Welche GraphQL-Funktion entspricht einer HTTP-POST-Anfrage in REST?\nWählen Sie eine Antwort:",
    "options": ["a) Subscription", "b) Resolver", "c) Mutation", "d) Query"],
    "correct": 2,
    "explanation": "✅ Richtig: Mutation entspricht POST/PUT/DELETE in REST – sie verändert Daten (Erstellen, Aktualisieren, Löschen).",
    "xp": 12,
    "tags": ["offiziell", "woche6"]
  },
  {
    "difficulty": 1,
    "type": "multiple",
    "question": "Was ist der Zweck des Query-Typs in GraphQL?\nWählen Sie eine Antwort:",
    "options": [
      "a) Er definiert die Struktur von Datenbanktabellen",
      "b) Er erlaubt das Abrufen von Daten",
      "c) Er definiert API-Endpunkte",
      "d) Er wird für Datentransaktionen verwendet"
    ],
    "correct": 1,
    "explanation": "✅ Richtig: type Query definiert alle verfügbaren Lese-Operationen – z. B. allUsers, user(id: ID!): User.",
    "xp": 10,
    "tags": ["offiziell", "woche6"]
  },
  {
    "difficulty": 1,
    "type": "multiple",
    "question": "Was ist eine GraphQL Subscription?\nWählen Sie eine Antwort:",
    "options": [
      "a) Eine Möglichkeit, wiederkehrende Zahlungen zu verwalten",
      "b) Eine spezielle Art von Mutation",
      "c) Eine Echtzeit-Datenverbindung zwischen Client und Server",
      "d) Ein Feature zur API-Dokumentation"
    ],
    "correct": 2,
    "explanation": "✅ Richtig: Subscriptions etablieren eine persistente Verbindung (meist WebSocket), über die der Server Echtzeit-Updates sendet.",
    "xp": 12,
    "tags": ["offiziell", "woche6"]
  },
  {
    "difficulty": 1,
    "type": "multiple",
    "question": "Bei Start der Subscription im GraphQL-Interface werden die Daten sofort als einmalige Antwort gesendet und nicht kontinuierlich aktualisiert.",
    "options": ["Wahr", "Falsch"],
    "correct": 1,
    "explanation": "✅ Richtig: Subscriptions senden Updates kontinuierlich – z. B. bei jeder Änderung eines Aktienkurses wird ein neues Event gepusht.",
    "xp": 12,
    "tags": ["offiziell", "woche6"]
  },
  {
    "difficulty": 1,
    "type": "multiple",
    "question": "GraphQL Subscriptions können vollständig über einfache HTTP-GET-Anfragen realisiert werden.",
    "options": ["Wahr", "Falsch"],
    "correct": 1,
    "explanation": "✅ Richtig: Subscriptions benötigen persistente Verbindungen – typischerweise WebSockets, nicht stateless HTTP-GET.",
    "xp": 12,
    "tags": ["offiziell", "woche6"]
  },
  {
    "difficulty": 1,
    "type": "multiple",
    "question": "Subscription erlaubt in GraphQL das Empfangen von Echtzeit-Updates.",
    "options": ["Wahr", "Falsch"],
    "correct": 0,
    "explanation": "✅ Richtig: Subscriptions sind für Echtzeit-Szenarien gedacht – z. B. Live-Chats, Börsenticker, Benachrichtigungen.",
    "xp": 10,
    "tags": ["offiziell", "woche6"]
  },
  {
    "difficulty": 1,
    "type": "multiple",
    "question": "Eine Mutation wird für das Erstellen, Aktualisieren oder Löschen von Daten verwendet.",
    "options": ["Wahr", "Falsch"],
    "correct": 0,
    "explanation": "✅ Richtig: Mutations sind Schreib-Operationen – createUser, updateUser, deleteUser sind typische Mutation-Namen.",
    "xp": 10,
    "tags": ["offiziell", "woche6"]
  },
  {
    "difficulty": 1,
    "type": "multiple",
    "question": "HTTP/1.1 unterstützt von Haus aus die fortlaufende Übertragung von Daten an den Client ohne Zusatztechnologien.",
    "options": ["Wahr", "Falsch"],
    "correct": 1,
    "explanation": "✅ Richtig: HTTP/1.1 ist request-response-basiert – für Echtzeit-Streams werden Technologien wie WebSockets oder Server-Sent Events benötigt.",
    "xp": 12,
    "tags": ["offiziell", "woche6"]
  },
  {
    "difficulty": 1,
    "type": "multiple",
    "question": "WebSocket ist ein Protokoll, das auf HTTP/3 basiert.",
    "options": ["Wahr", "Falsch"],
    "correct": 1,
    "explanation": "✅ Richtig: WebSocket basiert auf HTTP/1.1 (Upgrade-Handshake) – es ist unabhängig von HTTP/2 oder HTTP/3.",
    "xp": 12,
    "tags": ["offiziell", "woche6"]
  },
  {
    "difficulty": 1,
    "type": "multiple",
    "question": "Eine GraphQL Subscription wird über HTTP 1.1 abgewickelt.",
    "options": ["Wahr", "Falsch"],
    "correct": 1,
    "explanation": "✅ Richtig: Subscriptions nutzen WebSockets (Upgrade über HTTP/1.1) – nicht reines HTTP/1.1, sondern eine persistente Verbindung.",
    "xp": 12,
    "tags": ["offiziell", "woche6"]
  },
  {
    "difficulty": 1,
    "type": "multiple",
    "question": "WebSocket ist eine Technologie, die eine dauerhafte, bidirektionale Kommunikation zwischen Client und Server ermöglicht.",
    "options": ["Wahr", "Falsch"],
    "correct": 0,
    "explanation": "✅ Richtig: WebSocket etabliert eine persistente Verbindung – beide Seiten können jederzeit Nachrichten senden (Full-Duplex).",
    "xp": 10,
    "tags": ["offiziell", "woche6"]
  },
  {
    "difficulty": 1,
    "type": "multiple",
    "question": "Welche Datei enthält in einer Spring-GraphQL-Anwendung das Schema?\nWählen Sie eine Antwort:",
    "options": [
      "a) database.xml",
      "b) schema.graphql",
      "c) graphql-config.yml",
      "d) application.properties"
    ],
    "correct": 1,
    "explanation": "✅ Richtig: Das GraphQL-Schema wird in schema.graphql (oder .graphqls) definiert – typischerweise in src/main/resources/graphql/.",
    "xp": 10,
    "tags": ["offiziell", "woche6"]
  },
  {
    "difficulty": 1,
    "type": "multiple",
    "question": "In der pom.xml muss für WebSockets das Dependency spring-boot-starter-websocket eingebunden werden.",
    "options": ["Wahr", "Falsch"],
    "correct": 0,
    "explanation": "✅ Richtig: spring-boot-starter-websocket bringt die WebSocket-Infrastruktur für Subscriptions – ohne diese Dependency funktionieren Subscriptions nicht.",
    "xp": 10,
    "tags": ["offiziell", "woche6"]
  },
  {
    "difficulty": 1,
    "type": "multiple",
    "question": "Die Abhängigkeit spring-boot-starter-websocket ist notwendig, um WebSocket-Funktionalitäten in einer Spring Boot-Anwendung zu nutzen.",
    "options": ["Wahr", "Falsch"],
    "correct": 0,
    "explanation": "✅ Richtig: Diese Dependency stellt WebSocket-Support bereit – essentiell für GraphQL-Subscriptions und andere Echtzeit-Features.",
    "xp": 10,
    "tags": ["offiziell", "woche6"]
  },
  {
    "difficulty": 1,
    "type": "multiple",
    "question": "Der WebSocket-Endpunkt in der application.properties wird über den Schlüssel spring.graphql.websocket.path konfiguriert.",
    "options": ["Wahr", "Falsch"],
    "correct": 0,
    "explanation": "✅ Richtig: spring.graphql.websocket.path=/graphqlws definiert den WebSocket-Pfad für Subscriptions – z. B. ws://localhost:8080/graphqlws.",
    "xp": 12,
    "tags": ["offiziell", "woche6"]
  },
  {
    "difficulty": 1,
    "type": "multiple",
    "question": "Welche Annotation wird in Spring Boot für eine Mutation verwendet? \nWählen Sie eine Antwort:",
    "options": [
      "a) @MutationMapping",
      "b) @GraphQlRequest",
      "c) @SubscriptionMapping",
      "d) @QueryMapping"
    ],
    "correct": 0,
    "explanation": "✅ Richtig: @MutationMapping bindet eine Controller-Methode an eine Mutation im GraphQL-Schema – z. B. createUser, deleteUser.",
    "xp": 10,
    "tags": ["offiziell", "woche6"]
  },
  {
    "difficulty": 1,
    "type": "multiple",
    "question": "Die Annotation @SubscriptionMapping in Spring Boot kennzeichnet eine Methode als Subscription-Handler.",
    "options": ["Wahr", "Falsch"],
    "correct": 0,
    "explanation": "✅ Richtig: @SubscriptionMapping verknüpft eine Methode mit einer Subscription-Operation – die Methode gibt typischerweise einen Flux zurück.",
    "xp": 10,
    "tags": ["offiziell", "woche6"]
  },
  {
    "difficulty": 1,
    "type": "multiple",
    "question": "Die Annotation @SubscriptionMapping kennzeichnet eine Methode als Subscription-Endpunkt in Spring GraphQL.",
    "options": ["Wahr", "Falsch"],
    "correct": 0,
    "explanation": "✅ Richtig: @SubscriptionMapping ist die Spring-Annotation für Subscription-Resolver – ermöglicht reaktive Datenströme (z. B. Flux<T>).",
    "xp": 10,
    "tags": ["offiziell", "woche6"]
  },
  {
    "difficulty": 1,
    "type": "multiple",
    "question": "@RestController kann in einer Spring-GraphQL-Anwendung verwendet werden.",
    "options": ["Wahr", "Falsch"],
    "correct": 1,
    "explanation": "✅ Richtig: GraphQL-Controller nutzen @Controller, nicht @RestController – GraphQL-Handler verwenden @QueryMapping/@MutationMapping statt @GetMapping/@PostMapping.",
    "xp": 12,
    "tags": ["offiziell", "woche6"]
  },
  {
    "difficulty": 1,
    "type": "multiple",
    "question": "Im Beispiel wird flux.interval(Duration.ofSeconds(1)) verwendet, um jede Sekunde neue Daten zu erzeugen.",
    "options": ["Wahr", "Falsch"],
    "correct": 0,
    "explanation": "✅ Richtig: Flux.interval(Duration.ofSeconds(1)) erstellt einen reaktiven Stream, der jede Sekunde ein Event emittiert – ideal für Subscriptions.",
    "xp": 12,
    "tags": ["offiziell", "woche6"]
  },
  {
    "difficulty": 2,
    "type": "matching",
    "question": "Weisen Sie den GraphQL-Anfragen die entsprechenden User Stories korrekt zu.",
    "pairs": [
      {
        "left": "query { users { id name email } }",
        "right": "Als Nutzer möchte ich eine Liste aller vorhandenen User abfragen, damit ich eine Übersicht habe."
      },
      {
        "left": "mutation { createUser(input: { name: \"Max\", email: \"max@x\" }) { id name } }",
        "right": "Als Nutzer möchte ich einen neuen User anlegen, damit ich einen neuen User erstelle."
      },
      {
        "left": "mutation { updateUser(id: \"123\", input: { name: \"Max neu\" }) { id name } }",
        "right": "Als Nutzer möchte ich die Daten eines bestehenden Users ändern, damit die Änderungen gespeichert werden."
      },
      {
        "left": "query { user(id: \"123\") { id name email } }",
        "right": "Als Nutzer möchte ich einen bestimmten User über seine ID abrufen, damit ich dessen Daten sehen kann."
      },
      {
        "left": "mutation { deleteUser(id: \"123\") { success } }",
        "right": "Als Nutzer möchte ich einen User löschen, damit der entfernte User nicht mehr existiert."
      }
    ],
    "explanation": "✅ Richtig: 1=Liste abrufen (Query users), 2=Erstellen (Mutation createUser), 3=Ändern (Mutation updateUser), 4=Einzelner User (Query user), 5=Löschen (Mutation deleteUser).",
    "xp": 25,
    "tags": ["offiziell", "woche6"]
  },
  {
    "difficulty": 1,
    "type": "multiple",
    "question": "GraphQL wurde von Google entwickelt.",
    "options": ["Wahr", "Falsch"],
    "correct": 1,
    "explanation": "✅ Richtig: GraphQL wurde 2012 von Facebook entwickelt und 2015 als Open Source veröffentlicht, nicht von Google.",
    "xp": 10,
    "tags": ["offiziell", "woche6"]
  },
  {
    "difficulty": 1,
    "type": "multiple",
    "question": "GraphQL kann nur mit SQL-Datenbanken verwendet werden.",
    "options": ["Wahr", "Falsch"],
    "correct": 1,
    "explanation": "✅ Richtig: GraphQL ist datenbankagnostisch – es funktioniert mit SQL-Datenbanken, NoSQL, REST-APIs, Microservices oder anderen Datenquellen.",
    "xp": 10,
    "tags": ["offiziell", "woche6"]
  },
  {
    "difficulty": 1,
    "type": "multiple",
    "question": "GraphQL Queries liefern immer alle Felder eines Objekts, unabhängig davon, was der Client anfragt.",
    "options": ["Wahr", "Falsch"],
    "correct": 1,
    "explanation": "✅ Richtig: GraphQL liefert nur die vom Client explizit angefragten Felder – keine Über- oder Unterversorgung mit Daten.",
    "xp": 12,
    "tags": ["offiziell", "woche6"]
  },
  {
    "difficulty": 1,
    "type": "multiple",
    "question": "GraphQL ersetzt REST komplett und verwendet keine HTTP-Methoden mehr.",
    "options": ["Wahr", "Falsch"],
    "correct": 1,
    "explanation": "✅ Richtig: GraphQL nutzt HTTP (meist POST) als Transportschicht – es ersetzt REST nicht komplett, sondern ergänzt oder bietet Alternativen.",
    "xp": 12,
    "tags": ["offiziell", "woche6"]
  },
  {
    "difficulty": 1,
    "type": "multiple",
    "question": "Was passiert, wenn ein GraphQL-Feld mit ! markiert ist?\nWählen Sie eine Antwort:",
    "options": [
      "a) Es darf nicht null sein",
      "b) Es bedeutet, dass das Feld optional ist",
      "c) Es wird in der Datenbank gespeichert",
      "d) Es kann nur leere Werte enthalten"
    ],
    "correct": 0,
    "explanation": "✅ Richtig: Das Ausrufezeichen (!) markiert ein Feld als Non-Nullable – es muss immer einen Wert haben (z. B. name: String!).",
    "xp": 12,
    "tags": ["offiziell", "woche6"]
  },
  {
    "difficulty": 1,
    "type": "multiple",
    "question": "Subscriptions in GraphQL erlauben dem Client, fortlaufend Updates vom Server zu erhalten, ohne ständig neue Anfragen zu stellen.",
    "options": ["Wahr", "Falsch"],
    "correct": 0,
    "explanation": "✅ Richtig: Subscriptions etablieren eine persistente Verbindung – der Server pushed Updates automatisch bei Änderungen (Push-Modell statt Polling).",
    "xp": 12,
    "tags": ["offiziell", "woche6"]
  },
  {
    "difficulty": 1,
    "type": "multiple",
    "question": "Ohne WebSocket-Technologie wäre es im Beispiel trotzdem möglich, eine echte GraphQL-Subscription umzusetzen.",
    "options": ["Wahr", "Falsch"],
    "correct": 1,
    "explanation": "✅ Richtig: Echte Subscriptions benötigen persistente Verbindungen – ohne WebSocket müsste man auf Polling zurückgreifen, was keine echte Subscription ist.",
    "xp": 12,
    "tags": ["offiziell", "woche6"]
  },
  {
    "difficulty": 1,
    "type": "multiple",
    "question": "Für GraphQL-Subscriptions in Spring Boot muss immer eine Datenbank angebunden sein.",
    "options": ["Wahr", "Falsch"],
    "correct": 1,
    "explanation": "✅ Richtig: Subscriptions können auch ohne Datenbank funktionieren – z. B. mit In-Memory-Daten, externen APIs oder reaktiven Streams (Flux.interval).",
    "xp": 12,
    "tags": ["offiziell", "woche6"]
  },
  {
    "difficulty": 1,
    "type": "multiple",
    "question": "Die GraphQL-Subscription wird in der schema.graphqls-Datei durch den Typ Subscription definiert.",
    "options": ["Wahr", "Falsch"],
    "correct": 0,
    "explanation": "✅ Richtig: type Subscription { ... } definiert alle verfügbaren Subscription-Operationen im Schema – analog zu type Query und type Mutation.",
    "xp": 10,
    "tags": ["offiziell", "woche6"]
  },
  {
    "difficulty": 1,
    "type": "multiple",
    "question": "Reactive Programming, z.B. mit Flux von Spring Webflux, wird oft verwendet, um asynchrone Datenströme in Subscriptions zu handhaben.",
    "options": ["Wahr", "Falsch"],
    "correct": 0,
    "explanation": "✅ Richtig: Flux<T> (aus Project Reactor) ermöglicht reaktive Streams – ideal für Subscriptions, die kontinuierlich Daten emittieren (z. B. Flux.interval).",
    "xp": 15,
    "tags": ["offiziell", "woche6"]
  },
  {
    "difficulty": 1,
    "type": "multiple",
    "question": "HTTP/1.1 eignet sich standardmäßig gut für WebSocket-Verbindungen, die für Subscriptions benötigt werden.",
    "options": ["Wahr", "Falsch"],
    "correct": 1,
    "explanation": "✅ Richtig: HTTP/1.1 ist request-response-basiert – WebSocket nutzt HTTP/1.1 nur für den initialen Upgrade-Handshake, danach ist es ein eigenes Protokoll.",
    "xp": 12,
    "tags": ["offiziell", "woche6"]
  },
  {
    "difficulty": 1,
    "type": "multiple",
    "question": "Im Browser kann man die WebSocket-Kommunikation über die Entwicklertools im Netzwerk-Tab überwachen.",
    "options": ["Wahr", "Falsch"],
    "correct": 0,
    "explanation": "✅ Richtig: Browser-DevTools zeigen WebSocket-Verbindungen im Netzwerk-Tab an – man kann Frames (Nachrichten) inspizieren und Verbindungsstatus prüfen.",
    "xp": 10,
    "tags": ["offiziell", "woche6"]
  },
  {
    "difficulty": 1,
    "type": "multiple",
    "question": "Ein Header wie Sec-WebSocket-Key zeigt an, dass eine WebSocket-Verbindung aufgebaut wird.",
    "options": ["Wahr", "Falsch"],
    "correct": 0,
    "explanation": "✅ Richtig: Sec-WebSocket-Key ist Teil des WebSocket-Upgrade-Handshakes – er authentifiziert die Verbindung zwischen Client und Server.",
    "xp": 12,
    "tags": ["offiziell", "woche6"]
  },
  {
    "difficulty": 1,
    "type": "multiple",
    "question": "Die Konfiguration von WebSocket-Endpunkten erfolgt ausschließlich im Controller, nicht in der application.properties.",
    "options": ["Wahr", "Falsch"],
    "correct": 1,
    "explanation": "✅ Richtig: WebSocket-Pfade können in application.properties konfiguriert werden – z. B. spring.graphql.websocket.path=/graphqlws.",
    "xp": 12,
    "tags": ["offiziell", "woche6"]
  },
    {
    "difficulty": 1,
    "type": "checkbox",
    "question": "Welche Technologie wird für GraphQL-Subscriptions typischerweise verwendet? \nWählen Sie eine oder mehrere Antworten:",
    "options": [
      "a) Long Polling",
      "b) RESTful Requests",
      "c) WebSockets",
      "d) AJAX"
    ],
    "correct": [2],
    "explanation": "✅ Richtig: Nur c) ist korrekt.",
    "xp": 15,
    "tags": ["offiziell", "woche6"]
  },
  {
    "difficulty": 1,
    "type": "multiple",
    "question": "Welche Aufgabe hat das protobuf-maven-plugin im gRPC-Projekt?",
    "options": [
      "Es startet automatisch den gRPC-Server",
      "Es generiert Java-Klassen aus den .proto-Dateien",
      "Es ersetzt die Spring-Boot-Configuration",
      "Es übersetzt REST-Endpunkte in gRPC"
    ],
    "correct": 1,
    "explanation": "✅ Richtig: Das protobuf-maven-plugin generiert Java-Klassen aus den .proto-Dateien während des Build-Prozesses.",
    "xp": 12,
    "tags": ["uebung", "woche7"]
  },
  {
    "difficulty": 1,
    "type": "multiple",
    "question": "Welches Feld in UsersResponse erlaubt es, mehrere User zurückzugeben?",
    "options": [
      "optional UserProto user = 1;",
      "map<int64, UserProto> users = 1;",
      "repeated UserProto users = 1;",
      "list<UserProto> users = 1;"
    ],
    "correct": 2,
    "explanation": "✅ Richtig: Das Schlüsselwort 'repeated' in Protobuf definiert ein Array/Liste von Elementen.",
    "xp": 12,
    "tags": ["uebung", "woche7"]
  },
  {
    "difficulty": 1,
    "type": "multiple",
    "question": "Wofür steht das Schlüsselwort repeated in einer Protocol-Buffer-Definition?",
    "options": [
      "Feld darf nur einmal vorkommen",
      "Feld ist verpflichtend",
      "Feld kann null- oder mehrfach vorkommen",
      "Feld ist nur im Streaming-Modus erlaubt"
    ],
    "correct": 2,
    "explanation": "✅ Richtig: 'repeated' bedeutet, dass das Feld 0 oder mehrere Werte enthalten kann (wie eine Liste/Array).",
    "xp": 12,
    "tags": ["uebung", "woche7"]
  },
  {
    "difficulty": 1,
    "type": "multiple",
    "question": "Welcher Service-Methodentyp wird in der Übung für listUsers verwendet?",
    "options": [
      "Client-Streaming",
      "Server-Streaming",
      "Bidirektionales Streaming",
      "Unary Request/Response"
    ],
    "correct": 3,
    "explanation": "✅ Richtig: listUsers verwendet den einfachsten Typ: Unary Request/Response (eine Anfrage → eine Antwort).",
    "xp": 12,
    "tags": ["uebung", "woche7"]
  },
  {
    "difficulty": 1,
    "type": "multiple",
    "question": "Welche gRPC-bezogene Dependency macht den Server in Spring Boot lauffähig?",
    "options": [
      "grpc-client-spring-boot-starter",
      "grpc-server-spring-boot-starter",
      "spring-boot-starter-web",
      "spring-boot-starter-data-jpa"
    ],
    "correct": 1,
    "explanation": "✅ Richtig: Die Dependency 'grpc-server-spring-boot-starter' stellt die Server-Funktionalität für gRPC bereit.",
    "xp": 12,
    "tags": ["uebung", "woche7"]
  },
  {
    "difficulty": 1,
    "type": "multiple",
    "question": "Warum existiert in der gRPC-Variante der Anwendung kein REST-Controller?",
    "options": [
      "Weil Spring Boot mit gRPC nicht kompatibel ist",
      "Weil gRPC direkt über generierte Stubs und Services arbeitet",
      "Weil Controller nur bei GraphQL nötig sind",
      "Weil Maven-Plugins die Controller automatisch entfernen"
    ],
    "correct": 1,
    "explanation": "✅ Richtig: gRPC nutzt generierte Stubs und Service-Implementierungen statt REST-Controller – die Kommunikation läuft über binäre Protobuf-Messages.",
    "xp": 12,
    "tags": ["uebung", "woche7"]
  },
  {
    "difficulty": 1,
    "type": "multiple",
    "question": "Wozu dient die Klasse GrpcUsersMapper?",
    "options": [
      "Sie verwaltet die Datenbankverbindungen",
      "Sie mappt zwischen UserProto und der Java-Entität User",
      "Sie startet den gRPC-Server",
      "Sie verarbeitet HTTP/2-Frames"
    ],
    "correct": 1,
    "explanation": "✅ Richtig: GrpcUsersMapper konvertiert zwischen Protobuf-Messages (UserProto) und Domain-Objekten (User-Entität).",
    "xp": 12,
    "tags": ["uebung", "woche7"]
  },
  {
    "difficulty": 1,
    "type": "multiple",
    "question": "Welche Annotation markiert eine gRPC-Service-Implementierung in Spring Boot?",
    "options": [
      "@RestController",
      "@GrpcClient",
      "@GrpcService",
      "@Service"
    ],
    "correct": 2,
    "explanation": "✅ Richtig: @GrpcService registriert die Klasse als gRPC-Service-Implementierung im Spring-Boot-Kontext.",
    "xp": 12,
    "tags": ["uebung", "woche7"]
  },
  {
    "difficulty": 1,
    "type": "multiple",
    "question": "Welche Konfiguration stellt im Server sicher, dass gRPC auf Port 9000 lauscht?",
    "options": [
      "server.port=9000",
      "grpc.port=9000",
      "grpc.server.port=9000",
      "grpc.http2.port=9000"
    ],
    "correct": 2,
    "explanation": "✅ Richtig: Die Property 'grpc.server.port=9000' konfiguriert den Port für den gRPC-Server.",
    "xp": 12,
    "tags": ["uebung", "woche7"]
  },
  {
    "difficulty": 1,
    "type": "multiple",
    "question": "Warum wird google.protobuf.Int64Value in der proto-Datei verwendet?",
    "options": [
      "Um Strings zu kapseln",
      "Um boolesche Werte darzustellen",
      "Um optionale 64-Bit-Ganzzahlen zu kapseln",
      "Um Listen von IDs abzubilden"
    ],
    "correct": 2,
    "explanation": "✅ Richtig: google.protobuf.Int64Value ist ein Wrapper-Typ, der optionale 64-Bit-Ganzzahlen darstellt (kann null sein).",
    "xp": 12,
    "tags": ["uebung", "woche7"]
  },
  {
    "difficulty": 1,
    "type": "multiple",
    "question": "Warum kann der Browser nicht direkt mit gRPC sprechen?",
    "options": [
      "Weil gRPC nur über UDP funktioniert",
      "Weil Browser nur HTTP/1.0 sprechen",
      "Weil gRPC binäres HTTP/2 mit Protobuf nutzt und keine native Browser-API existiert",
      "Weil gRPC TLS erzwingt"
    ],
    "correct": 2,
    "explanation": "✅ Richtig: Browser haben keine native Unterstützung für binäres HTTP/2 mit Protobuf – gRPC-Web oder Proxies sind nötig.",
    "xp": 12,
    "tags": ["uebung", "woche7"]
  },
  {
    "difficulty": 1,
    "type": "multiple",
    "question": "Wozu dient das Tool grpcui in der Übung?",
    "options": [
      "Zum Generieren von Protobuf-Dateien",
      "Zum Starten des gRPC-Servers",
      "Zum Testen der gRPC-Methoden über eine Weboberfläche",
      "Zum Monitoring von HTTP/2-Traffic"
    ],
    "correct": 2,
    "explanation": "✅ Richtig: grpcui bietet eine interaktive Weboberfläche zum Testen von gRPC-Services.",
    "xp": 12,
    "tags": ["uebung", "woche7"]
  },
  {
    "difficulty": 1,
    "type": "multiple",
    "question": "Welche Adresse wird im Client für die Verbindung zum gRPC-Server konfiguriert?",
    "options": [
      "http://localhost:8080",
      "static://localhost:9000",
      "tcp://localhost:9000",
      "grpc://localhost:9000"
    ],
    "correct": 1,
    "explanation": "✅ Richtig: Der Spring-Boot-gRPC-Client nutzt 'static://localhost:9000' als Adresse.",
    "xp": 12,
    "tags": ["uebung", "woche7"]
  },
  {
    "difficulty": 1,
    "type": "multiple",
    "question": "Welche Einstellung beschreibt im Client, dass keine TLS-Verschlüsselung verwendet wird?",
    "options": [
      "grpc.client.mode=plain",
      "grpc.client.users-service-server.security=none",
      "grpc.client.users-service-server.negotiation-type=plaintext",
      "grpc.client.tls.enabled=false"
    ],
    "correct": 2,
    "explanation": "✅ Richtig: 'negotiation-type=plaintext' deaktiviert TLS für die Verbindung.",
    "xp": 12,
    "tags": ["uebung", "woche7"]
  },
  {
    "difficulty": 1,
    "type": "multiple",
    "question": "In welcher Datei wird die gRPC-Schnittstelle (Messages und Service) definiert?",
    "options": [
      "application.properties",
      "UserService.proto",
      "UsersServiceGrpc.java",
      "pom.xml"
    ],
    "correct": 1,
    "explanation": "✅ Richtig: .proto-Dateien (z.B. UserService.proto) definieren Messages und Services für gRPC.",
    "xp": 12,
    "tags": ["uebung", "woche7"]
  },
  {
    "difficulty": 1,
    "type": "multiple",
    "question": "Welche Maven-Extension sorgt für OS-abhängige Builds des Protobuf-Compilers?",
    "options": [
      "protobuf-maven-plugin",
      "os-maven-plugin",
      "spring-boot-maven-plugin",
      "grpc-java-maven-plugin"
    ],
    "correct": 1,
    "explanation": "✅ Richtig: Das os-maven-plugin erkennt das Betriebssystem und wählt die passende Protobuf-Compiler-Version.",
    "xp": 12,
    "tags": ["uebung", "woche7"]
  },
  {
    "difficulty": 1,
    "type": "multiple",
    "question": "Welches Transportprotokoll wird für gRPC in der Übung letztlich genutzt?",
    "options": [
      "HTTP/1.1",
      "HTTP/2",
      "WebSocket",
      "QUIC"
    ],
    "correct": 1,
    "explanation": "✅ Richtig: gRPC nutzt HTTP/2 als Transportprotokoll – mit Multiplexing, Streaming und binärer Kodierung.",
    "xp": 12,
    "tags": ["uebung", "woche7"]
  },
  {
    "difficulty": 1,
    "type": "multiple",
    "question": "Welche Aussage zu den User Stories des Dienstes ist korrekt?",
    "options": [
      "Es gibt nur eine Story zum Lesen aller Nutzer",
      "Es gibt nur Create und Read",
      "Es gibt Stories für Erstellen, Bearbeiten, Löschen, Suchen und Auflisten von Nutzern",
      "Es gibt ausschließlich Schreiboperationen"
    ],
    "correct": 2,
    "explanation": "✅ Richtig: Der Service deckt CRUD-Operationen ab: Create, Read (list/find), Update, Delete.",
    "xp": 12,
    "tags": ["uebung", "woche7"]
  },
  {
    "difficulty": 2,
    "type": "multiselect",
    "question": "Welche Maven-Dependencies sind direkt für gRPC und Protobuf relevant? (Mehrere richtig)",
    "options": [
      "io.grpc:grpc-stub",
      "io.grpc:grpc-protobuf",
      "io.grpc:grpc-netty-shaded",
      "org.springframework.boot:spring-boot-starter-thymeleaf"
    ],
    "correct": [0, 1, 2],
    "explanation": "✅ Richtig: grpc-stub, grpc-protobuf und grpc-netty-shaded sind essentiell für gRPC-Projekte. Thymeleaf ist für Web-Templates.",
    "xp": 15,
    "tags": ["uebung", "woche7"]
  },
  {
    "difficulty": 2,
    "type": "multiselect",
    "question": "Welche Message-Typen sind in der Datei UserService.proto definiert? (Mehrere richtig)",
    "options": [
      "UsersRequest",
      "UserProto",
      "UsersResponse",
      "UserLoginRequest"
    ],
    "correct": [0, 1, 2],
    "explanation": "✅ Richtig: UsersRequest, UserProto und UsersResponse sind in der proto-Datei definiert. UserLoginRequest nicht.",
    "xp": 15,
    "tags": ["uebung", "woche7"]
  },
  {
    "difficulty": 2,
    "type": "multiselect",
    "question": "Welche Fragen sollen Sie laut Übung in Bezug auf gRPC-Streaming beantworten? (Mehrere richtig)",
    "options": [
      "Warum können hier Nutzdaten in Streams ausgetauscht werden?",
      "Welches Protokoll dient bei gRPC zum Transport?",
      "Werden die Daten in Echtzeit ausgetauscht?",
      "Wie hoch ist die CPU-Auslastung des Servers in Prozent?"
    ],
    "correct": [0, 1, 2],
    "explanation": "✅ Richtig: Die ersten drei Fragen beziehen sich auf Streaming-Konzepte und Protokolle. CPU-Auslastung ist kein Thema der Übung.",
    "xp": 15,
    "tags": ["uebung", "woche7"]
  },
  {
    "difficulty": 2,
    "type": "multiselect",
    "question": "Welche Tools oder Komponenten kommen in der HTTP/2-/Wireshark-Zusatzübung vor? (Mehrere richtig)",
    "options": [
      "Wireshark",
      "Anzeigefilter http2",
      "curl mit HTTP/1.0-only",
      "gRPC-Server und -Client"
    ],
    "correct": [0, 1, 3],
    "explanation": "✅ Richtig: Wireshark mit http2-Filter und gRPC Server/Client werden genutzt. curl HTTP/1.0 ist nicht Teil der Übung.",
    "xp": 15,
    "tags": ["uebung", "woche7"]
  },
  {
    "difficulty": 2,
    "type": "matching",
    "question": "Ordne Protobuf-Typen den passenden Bedeutungen zu:",
    "pairs": [
      { "left": "int64", "right": "64-Bit-Ganzzahl" },
      { "left": "string", "right": "Zeichenkette" },
      { "left": "google.protobuf.BoolValue", "right": "Kapselt boolesche Werte" },
      { "left": "google.protobuf.Int64Value", "right": "Kapselt 64-Bit-Ganzzahlen (z.B. IDs)" }
    ],
    "explanation": "✅ Richtig: int64 = primitive Ganzzahl, string = Text, BoolValue = optionaler Boolean, Int64Value = optionale Ganzzahl.",
    "xp": 18,
    "tags": ["uebung", "woche7"]
  },
  {
    "difficulty": 2,
    "type": "matching",
    "question": "Ordne gRPC-Service-Methoden ihren Aufgaben zu (aus UsersService):",
    "pairs": [
      { "left": "listUsers", "right": "Alle Nutzer auflisten" },
      { "left": "findUserById", "right": "Nutzer anhand der ID finden" },
      { "left": "createUser", "right": "Neuen Nutzer anlegen" },
      { "left": "updateUser", "right": "Vorhandenen Nutzer bearbeiten" },
      { "left": "deleteUser", "right": "Nutzer löschen" }
    ],
    "explanation": "✅ Richtig: Jede Methode entspricht einer CRUD-Operation: Create, Read (list/find), Update, Delete.",
    "xp": 18,
    "tags": ["uebung", "woche7"]
  },
  {
    "difficulty": 2,
    "type": "matching",
    "question": "Ordne Konfigurationsschlüssel ihrer Bedeutung zu (Client-Konfiguration):",
    "pairs": [
      { "left": "grpc.client.users-service-server.address", "right": "Definiert, unter welcher Adresse der gRPC-Server erreichbar ist" },
      { "left": "grpc.client.users-service-server.negotiation-type", "right": "Legt fest, wie die Verbindung ausgehandelt wird (z.B. PLAINTEXT/TLS)" }
    ],
    "explanation": "✅ Richtig: 'address' gibt die Server-Adresse an, 'negotiation-type' steuert TLS/Plaintext.",
    "xp": 18,
    "tags": ["uebung", "woche7"]
  },
  {
    "difficulty": 2,
    "type": "matching",
    "question": "Ordne Bausteine dem Ort im Projekt zu:",
    "pairs": [
      { "left": "Schnittstellendefinition von Messages und Services", "right": "src/main/proto" },
      { "left": "Generierte gRPC-Stubs", "right": "src/main/java/edu/fra/uas/grpc" },
      { "left": "Java-Service-Implementierung mit Business-Logik", "right": "src/main/java/edu/fra/uas/service/grpc/UsersServiceGrpc" },
      { "left": "Mapping von Protobuf-Typ zu Domain-Typ", "right": "src/main/java/edu/fra/uas/service/grpc/GrpcUsersMapper" }
    ],
    "explanation": "✅ Richtig: .proto-Dateien in src/main/proto, Stubs generiert in grpc-Package, Service-Implementierung in UsersServiceGrpc, Mapper in GrpcUsersMapper.",
    "xp": 18,
    "tags": ["uebung", "woche7"]
  },
  {
    "difficulty": 2,
    "type": "order",
    "question": "Bringe die Schritte zum Starten des gRPC-Servers mit Test über grpcui in die richtige Reihenfolge:",
    "items": [
      "Maven-Lifecycle compile ausführen, damit Stubs generiert werden",
      "gRPC-Anwendung starten",
      "grpcui.exe -plaintext 127.0.0.1:9000 im Terminal aufrufen",
      "Browser-Fenster von grpcui öffnen und Invoke klicken"
    ],
    "correctOrder": [0, 1, 2, 3],
    "explanation": "✅ Richtig: Erst compile (Stubs generieren) → Server starten → grpcui starten → UI nutzen.",
    "xp": 18,
    "tags": ["uebung", "woche7"]
  },
  {
    "difficulty": 2,
    "type": "order",
    "question": "Sortiere die Schritte zur Nutzung von Wireshark in der HTTP/2-Zusatzübung:",
    "items": [
      "Wireshark installieren und starten",
      "Lokale Schnittstelle in Wireshark auswählen und Capture starten",
      "gRPC-Server und -Client starten",
      "Filter http2 in Wireshark setzen"
    ],
    "correctOrder": [0, 1, 2, 3],
    "explanation": "✅ Richtig: Installation → Capture starten → Anwendung starten → Filter setzen.",
    "xp": 18,
    "tags": ["uebung", "woche7"]
  },
  {
    "difficulty": 2,
    "type": "order",
    "question": "Sortiere konzeptionell den Weg von der API-Idee bis zur laufenden gRPC-Anwendung (am Beispiel der Übung & Hausaufgabe):",
    "items": [
      "Entwurf der API in einer .proto-Datei",
      "Generierung der Stubs mit Maven/Protobuf-Plugin",
      "Implementierung der Service-Klasse in Java",
      "Starten von Server und (optional) Client-Anwendungen"
    ],
    "correctOrder": [0, 1, 2, 3],
    "explanation": "✅ Richtig: API-Design (.proto) → Code-Generierung → Implementierung → Deployment.",
    "xp": 18,
    "tags": ["uebung", "woche7"]
  },
  {
    "difficulty": 2,
    "type": "order",
    "question": "Sortiere die Schritte, um einen gRPC-Client in Spring Boot mit dem Server zu verbinden:",
    "items": [
      "Client-spezifische gRPC-Dependencies in pom.xml ergänzen",
      "Proto-Datei dem Client-Projekt hinzufügen",
      "Codegenerierung (Maven compile) ausführen",
      "Client-Konfiguration in application.properties setzen (address, negotiation-type)",
      "@GrpcClient(users-service-server) im UserService verwenden"
    ],
    "correctOrder": [0, 1, 2, 3, 4],
    "explanation": "✅ Richtig: Dependencies → .proto hinzufügen → compile → Config → @GrpcClient nutzen.",
    "xp": 18,
    "tags": ["uebung", "woche7"]
  }
]