[
  {
    "difficulty": 1,
    "type": "multiple",
    "question": "Eine Spring-Boot-Anwendung kann eigenständig und ohne externe Laufzeitabhängigkeiten ausgeführt werden",
    "options": [
      "Wahr",
      "Falsch"
    ],
    "correct": 0,
    "explanation": "Spring Boot-Anwendungen sind als Fat JARs/Executable JARs lauffähig und benötigen keine externen Laufzeitabhängigkeiten.",
    "xp": 10,
    "tags": [
      "uebung",
      "neue-vorlesung",
      "offiziell"
    ]
  },
  {
    "difficulty": 1,
    "type": "multiple",
    "question": "Im Beispiel wird bei einer fehlenden URL-Parameterangabe (MissingServletRequestParameterException) automatisch support.html als View zurückgegeben.",
    "options": ["Falsch", "Wahr"],
    "correct": 1,
    "explanation": "Beispiel-Handler gibt bei MissingServletRequestParameterException die View support.html zurück (ModelAndView mit View-Namen).",
    "xp": 10,
    "tags": ["offiziell", "woche4"]
  },
  {
    "difficulty": 1,
    "type": "multiple",
    "question": "Der Controller leitet Model-Daten an die View weiter, um eine dynamische Anzeige zu generieren.",
    "options": ["Falsch", "Wahr"],
    "correct": 1,
    "explanation": "Controller füllt Model → View rendert dynamisch daraus.",
    "xp": 10,
    "tags": ["offiziell", "woche4"]
  },
  {
    "difficulty": 1,
    "type": "multiple",
    "question": "Fehlende Parameter in HTTP-Anfragen führen immer zu einem Server-Absturz.",
    "options": ["Falsch", "Wahr"],
    "correct": 0,
    "explanation": "Fehlende Pflicht-Parameter erzeugen Exceptions (z.B. MissingServletRequestParameterException), kein Absturz – Handler möglich.",
    "xp": 10,
    "tags": ["offiziell", "woche4"]
  },
  {
    "difficulty": 1,
    "type": "multiple",
    "question": "Was ist das Hauptziel des MVC-Entwurfsmusters?",
    "options": [
      "Die Beschleunigung der Web-Entwicklung",
      "Die Integration von Datenbanken",
      "Die Trennung von Präsentation, Logik und Daten",
      "Die Verbesserung der Sicherheit"
    ],
    "correct": 2,
    "explanation": "MVC sorgt für klare Trennung: Model (Daten/Logik), View (Darstellung), Controller (Steuerung).",
    "xp": 15,
    "tags": ["offiziell", "woche4"]
  },
  {
    "difficulty": 1,
    "type": "multiple",
    "question": "Das DispatcherServlet leitet Anfragen an den passenden Controller weiter.",
    "options": ["Falsch", "Wahr"],
    "correct": 1,
    "explanation": "DispatcherServlet = Front Controller: empfängt Request, delegiert an passenden Handler.",
    "xp": 10,
    "tags": ["offiziell", "woche4"]
  },
  {
    "difficulty": 1,
    "type": "multiple",
    "question": "Thymeleaf benötigt zwingend die Annotation @ThymeleafEnabled.",
    "options": ["Falsch", "Wahr"],
    "correct": 0,
    "explanation": "Es existiert keine Annotation @ThymeleafEnabled; Spring Boot autokonfiguriert Thymeleaf über Starter.",
    "xp": 10,
    "tags": ["offiziell", "woche4"]
  },
  {
    "difficulty": 1,
    "type": "multiple",
    "question": "Der Query String beginnt immer nach dem ersten Gleichheitszeichen in der URL.",
    "options": ["Falsch", "Wahr"],
    "correct": 0,
    "explanation": "Der Query-String beginnt nach '?' und enthält key=value Paare; '=' trennt Schlüssel und Wert.",
    "xp": 10,
    "tags": ["offiziell", "woche4"]
  },
  {
    "difficulty": 1,
    "type": "multiple",
    "question": "Eine MissingServletRequestParameterException tritt nur dann auf, wenn alle URL-Parameter fehlen.",
    "options": ["Falsch", "Wahr"],
    "correct": 0,
    "explanation": "Sie tritt auf, wenn EIN erforderlicher Parameter fehlt – nicht alle müssen fehlen.",
    "xp": 10,
    "tags": ["offiziell", "woche4"]
  },
  {
    "difficulty": 1,
    "type": "multiple",
    "question": "Im MVC-Pattern speichert der Controller die Anwendungsdaten.",
    "options": ["Falsch", "Wahr"],
    "correct": 0,
    "explanation": "Kontroller steuert Fluss; Daten & Logik liegen im Model.",
    "xp": 10,
    "tags": ["offiziell", "woche4"]
  },
  {
    "difficulty": 1,
    "type": "multiple",
    "question": "Welcher Ordner enthält statische Ressourcen wie CSS- und JavaScript-Dateien in Spring Boot?",
    "options": [
      "/static/resources",
      "/src/main/resources/static",
      "/resources/views",
      "/src/main/resources/templates"
    ],
    "correct": 1,
    "explanation": "Statische Dateien liegen unter src/main/resources/static (nicht templates).",
    "xp": 10,
    "tags": ["offiziell", "woche4"]
  },
  {
    "difficulty": 1,
    "type": "multiple",
    "question": "@ControllerAdvice kann mehrere unterschiedliche Exceptions behandeln, nicht nur eine einzige.",
    "options": ["Falsch", "Wahr"],
    "correct": 1,
    "explanation": "@ControllerAdvice + mehrere @ExceptionHandler Methoden für verschiedene Exception-Typen.",
    "xp": 10,
    "tags": ["offiziell", "woche4"]
  },
  {
    "difficulty": 2,
    "type": "multiple",
    "question": "Was ist die Funktion der Annotation @Autowired?",
    "options": [
      "Sie gibt an, dass eine Methode als Spring Bean registriert werden soll",
      "Sie markiert die Main-Methode des Programms",
      "Sie erstellt eine neue Bean im Spring Container",
      "Sie injiziert eine Bean in eine andere Klasse und stellt diese zur Verfügung"
    ],
    "correct": 3,
    "explanation": "@Autowired injiziert eine Bean in eine andere Klasse und stellt sie dort zur Verfügung.",
    "xp": 20,
    "tags": [
      "uebung",
      "neue-vorlesung",
      "offiziell"
    ]
  },
  {
    "difficulty": 2,
    "type": "multiple",
    "question": "In welcher Datei werden die Abhängigkeiten bei einem Spring Boot-Projekt verwaltet (Gradle)?",
    "options": [
      "pom.xml",
      "settings.gradle",
      "build.gradle",
      "application.properties"
    ],
    "correct": 2,
    "explanation": "Bei Gradle werden Dependencies in der build.gradle gepflegt. Die pom.xml ist für Maven-Projekte.",
    "xp": 15,
    "tags": [
      "uebung",
      "neue-vorlesung",
      "offiziell"
    ]
  },
  {
    "difficulty": 1,
    "type": "multiple",
    "question": "Welche Log-Level sind standardmäßig in Spring Boot aktiviert?",
    "options": [
      "TRACE, WARN, DEBUG",
      "DEBUG, INFO, ERROR",
      "ERROR, WARN, INFO",
      "ERROR, TRACE, INFO"
    ],
    "correct": 2,
    "explanation": "Standardmäßig sind ERROR, WARN und INFO in Spring Boot aktiviert. DEBUG und TRACE müssen explizit aktiviert werden.",
    "xp": 10,
    "tags": [
      "uebung",
      "neue-vorlesung",
      "offiziell"
    ]
  },
  {
    "difficulty": 1,
    "type": "multiple",
    "question": "Was macht die Methode setMessage() in der Klasse MessageService?",
    "options": [
      "Sie gibt den Wert der Variablen message zurück",
      "Sie initialisiert die Bean message",
      "Sie setzt den Wert der Variablen message",
      "Sie speichert eine Nachricht in einer Datenbank"
    ],
    "correct": 2,
    "explanation": "Die Methode setMessage() setzt den Wert der Variablen message in der Klasse MessageService.",
    "xp": 10,
    "tags": [
      "uebung",
      "neue-vorlesung",
      "offiziell"
    ]
  },
  {
    "difficulty": 3,
    "type": "multiple",
    "question": "Die Methode assertThat() wird nicht von JUnit nativ bereitgestellt.",
    "options": [
      "Wahr",
      "Falsch"
    ],
    "correct": 0,
    "explanation": "assertThat() stammt aus Bibliotheken wie AssertJ oder Hamcrest, nicht aus JUnit selbst.",
    "xp": 30,
    "tags": [
      "uebung",
      "neue-vorlesung",
      "offiziell"
    ]
  },
  {
    "difficulty": 4,
    "type": "multiple",
    "question": "Mit Maven können Abhängigkeiten eines Projekts automatisch aufgelöst werden.",
    "options": [
      "Wahr",
      "Falsch"
    ],
    "correct": 0,
    "explanation": "Maven löst Abhängigkeiten automatisch über die pom.xml auf und lädt sie aus Repositories herunter.",
    "xp": 40,
    "tags": [
      "uebung",
      "neue-vorlesung",
      "offiziell"
    ]
  },
  {
    "difficulty": 1,
    "type": "multiple",
    "question": "Wohin schreibt Spring Boot Logs standardmäßig ohne zusätzliche Konfiguration?",
    "options": [
      "In die Konsole (Standard Output)",
      "In eine Datei namens 'application.log'",
      "In eine Datenbank",
      "In das Windows Event Log"
    ],
    "correct": 0,
    "explanation": "Standardmäßig schreibt Spring Boot alle Logs in die Konsole (Standard Output). Für andere Ziele ist zusätzliche Konfiguration nötig.",
    "xp": 10,
    "tags": [
      "uebung"
    ]
  },
  {
    "difficulty": 1,
    "type": "checkbox",
    "question": "Welche Log-Level sind in Spring Boot standardmäßig verfügbar? (Mehrfachauswahl)",
    "options": [
      "ERROR",
      "WARN",
      "INFO",
      "DEBUG",
      "TRACE"
    ],
    "correct": [
      0,
      1,
      2,
      3,
      4
    ],
    "explanation": "Spring Boot unterstützt die Standard-Log-Level: ERROR (kritisch), WARN (Warnungen), INFO (Information), DEBUG (Entwicklung) und TRACE (detailliert).",
    "xp": 15,
    "tags": [
      "uebung"
    ]
  },
  {
    "difficulty": 1,
    "type": "multiple",
    "question": "Was ist das grundlegende Schema für User Stories?",
    "options": [
      "Als <Rolle> möchte ich <Ziel>, damit <Nutzen>",
      "Wenn <Bedingung> dann <Aktion>",
      "Gegeben <Zustand> wenn <Ereignis> dann <Ergebnis>",
      "Falls <Problem> soll <Lösung> implementiert werden"
    ],
    "correct": 0,
    "explanation": "User Stories folgen dem Schema: 'Als <Rolle> möchte ich <Ziel>, damit <Nutzen>'. Dies macht Anforderungen verständlich und nutzerorientiert.",
    "xp": 10,
    "tags": [
      "uebung"
    ]
  },
  {
    "difficulty": 2,
    "type": "matching",
    "question": "Ordne die Logging-Properties ihren Effekten zu:",
    "pairs": [
      {
        "left": "logging.file",
        "right": "Definiert eine spezifische Log-Datei"
      },
      {
        "left": "logging.path",
        "right": "Setzt das Verzeichnis für Log-Dateien"
      },
      {
        "left": "logging.level.*",
        "right": "Konfiguriert Log-Level für Packages"
      },
      {
        "left": "logging.pattern.console",
        "right": "Bestimmt das Format der Konsolenausgabe"
      }
    ],
    "explanation": "Die verschiedenen Logging-Properties steuern unterschiedliche Aspekte: Dateien, Pfade, Level und Ausgabeformat.",
    "xp": 25,
    "tags": [
      "uebung"
    ]
  },
  {
    "difficulty": 2,
    "type": "multiple",
    "question": "Was bewirkt logging.level.edu.fra.uas=debug in der Konfiguration?",
    "options": [
      "Setzt DEBUG-Level für das spezifische Package und Unterpackages",
      "Aktiviert Debugging für die gesamte Anwendung",
      "Loggt nur Fehler aus dem edu.fra.uas Package",
      "Deaktiviert Logging für andere Packages"
    ],
    "correct": 0,
    "explanation": "Diese Einstellung setzt das Log-Level DEBUG für das Package edu.fra.uas und alle seine Unterpackages. Andere Packages bleiben unberührt.",
    "xp": 20,
    "tags": [
      "uebung"
    ]
  },
  {
    "difficulty": 3,
    "type": "checkbox",
    "question": "Welche Vorteile bietet strukturiertes Logging (SLF4J/Logback) gegenüber System.out.println in Spring Boot? (Mehrfachauswahl)",
    "options": [
      "Konfigurierbare Log-Level und Filter",
      "Performance durch asynchrones Logging",
      "Standardisierte Formatierung",
      "Integration mit Spring Boot Actuator",
      "Automatische Dateirotation"
    ],
    "correct": [
      0,
      1,
      2,
      3,
      4
    ],
    "explanation": "Strukturiertes Logging bietet viele Vorteile: konfigurierbare Level, bessere Performance, einheitliche Formate, Monitoring-Integration und Dateiverwaltung.",
    "xp": 30,
    "tags": [
      "uebung"
    ]
  },
  {
    "difficulty": 3,
    "type": "multiple",
    "question": "Was passiert, wenn @Autowired an einer Feldstelle entfernt wird?",
    "options": [
      "Das Feld bleibt null und führt zu NullPointerException bei Verwendung",
      "Spring erstellt automatisch eine neue Instanz",
      "Die Anwendung startet nicht",
      "Es wird eine Warnung ausgegeben"
    ],
    "correct": 0,
    "explanation": "Ohne @Autowired erfolgt keine Dependency Injection. Das Feld bleibt null, was bei Verwendung zu einer NullPointerException führt.",
    "xp": 30,
    "tags": [
      "uebung"
    ]
  },
  {
    "difficulty": 4,
    "type": "matching",
    "question": "Ordne die Test-Konzepte ihren Haupteigenschaften zu:",
    "pairs": [
      {
        "left": "@SpringBootTest",
        "right": "Lädt den vollständigen Application Context"
      },
      {
        "left": "AssertJ",
        "right": "Bietet fluent assertions und bessere Fehlermeldungen"
      },
      {
        "left": "Slice Tests",
        "right": "Testet nur spezifische Schichten der Anwendung"
      },
      {
        "left": "Unit Tests",
        "right": "Testet isolierte Komponenten ohne Spring Context"
      }
    ],
    "explanation": "@SpringBootTest ist für Integrationstests mit vollem Context, AssertJ verbessert die Testlesbarkeit, Slice Tests fokussieren einzelne Schichten, Unit Tests sind am schnellsten.",
    "xp": 40,
    "tags": [
      "uebung"
    ]
  },
  {
    "difficulty": 4,
    "type": "multiple",
    "question": "Welche Funktion hat der <parent>-Eintrag in der pom.xml bei Spring Boot?",
    "options": [
      "Definiert Versionen, Dependencies und Plugins durch Vererbung",
      "Ist nur für Multi-Modul-Projekte erforderlich",
      "Dient ausschließlich der Dokumentation",
      "Wird nur für Test-Konfigurationen verwendet"
    ],
    "correct": 0,
    "explanation": "Der <parent>-Eintrag ermöglicht die Vererbung von Versionen, Dependencies und Plugin-Konfigurationen vom Spring Boot Parent POM, was die Projektkonfiguration vereinfacht.",
    "xp": 40,
    "tags": [
      "uebung"
    ]
  },
  {
    "difficulty": 4,
    "type": "checkbox",
    "question": "Was sind die Besonderheiten eines CommandLineRunner als @Bean? (Mehrfachauswahl)",
    "options": [
      "Wird nach Kontext-Initialisierung ausgeführt",
      "Kann mehrfach im Projekt definiert werden",
      "Hat Zugriff auf andere Beans",
      "Ermöglicht Start-up Logik",
      "Unterstützt Ordering mit @Order"
    ],
    "correct": [
      0,
      1,
      2,
      3,
      4
    ],
    "explanation": "CommandLineRunner als @Bean: läuft nach Kontext-Start, mehrfache Definition möglich, hat Bean-Zugriff, ideal für Start-up Logik, unterstützt Reihenfolge via @Order.",
    "xp": 45,
    "tags": [
      "uebung"
    ]
  },
  {
    "difficulty": 1,
    "type": "multiple",
    "question": "Was ist eine Bean im Spring-Container?",
    "options": [
      "Ein Java-Objekt, das von Spring verwaltet wird",
      "Eine Datenbankverbindung",
      "Ein UI-Element",
      "Eine Konfigurationsdatei"
    ],
    "correct": 0,
    "explanation": "Eine Bean ist ein Java-Objekt, das vom Spring Container verwaltet wird - inklusive Erstellung, Konfiguration und Lebenszyklus-Management.",
    "xp": 10,
    "tags": [
      "uebung"
    ]
  },
  {
    "difficulty": 1,
    "type": "multiple",
    "question": "Welches Log-Level zeigt die wichtigsten Fehler an?",
    "options": [
      "DEBUG",
      "INFO",
      "ERROR",
      "TRACE"
    ],
    "correct": 2,
    "explanation": "ERROR ist das Log-Level für die kritischsten Fehlermeldungen. Es zeigt schwerwiegende Probleme an, die sofortige Aufmerksamkeit erfordern.",
    "xp": 10,
    "tags": [
      "uebung"
    ]
  },
  {
    "difficulty": 1,
    "type": "multiple",
    "question": "Was ist ein Fork in GitHub?",
    "options": [
      "Eine Kopie eines Repositories unter deinem eigenen Account",
      "Ein Branch in einem Repository",
      "Ein Pull Request",
      "Ein Commit in der Historie"
    ],
    "correct": 0,
    "explanation": "Ein Fork ist eine persönliche Kopie eines fremden Repositories unter deinem GitHub-Account. Dies ermöglicht es dir, Änderungen vorzunehmen, ohne das Original zu beeinflussen.",
    "xp": 10,
    "tags": [
      "uebung",
      "neue-vorlesung",
      "offiziell"
    ]
  },
  {
    "difficulty": 2,
    "type": "matching",
    "question": "Ordne die Log-Level ihrer typischen Verwendung zu:",
    "pairs": [
      {
        "left": "ERROR",
        "right": "Kritische Fehler, die sofortige Aktion erfordern"
      },
      {
        "left": "WARN",
        "right": "Potenziell schädliche Situationen"
      },
      {
        "left": "INFO",
        "right": "Wichtige Geschäftsereignisse"
      },
      {
        "left": "DEBUG",
        "right": "Detaillierte Entwicklerinformationen"
      }
    ],
    "explanation": "Die Log-Level haben unterschiedliche Prioritäten und Verwendungszwecke: ERROR für kritische Fehler, WARN für Warnungen, INFO für wichtige Events, DEBUG für Entwicklerdetails.",
    "xp": 25,
    "tags": [
      "uebung"
    ]
  },
  {
    "difficulty": 2,
    "type": "checkbox",
    "question": "Welche Vorteile bietet strukturiertes Logging gegenüber System.out.println? (Mehrfachauswahl)",
    "options": [
      "Konfigurierbare Log-Level",
      "Bessere Filterbarkeit",
      "Mehrere Ausgabekanäle möglich",
      "Formatierte Zeitstempel",
      "Schnellere Ausführung"
    ],
    "correct": [
      0,
      1,
      2,
      3
    ],
    "explanation": "Strukturiertes Logging bietet viele Vorteile: konfigurierbare Level, Filterbarkeit, multiple Ausgabekanäle und automatische Zeitstempel. Die Ausführungsgeschwindigkeit ist nicht primär relevant.",
    "xp": 20,
    "tags": [
      "uebung"
    ]
  },
  {
    "difficulty": 2,
    "type": "multiple",
    "question": "Was ist die Hauptaufgabe des CommandLineRunner in Spring Boot?",
    "options": [
      "Datenbankverbindungen aufbauen",
      "Code beim Anwendungsstart ausführen",
      "REST-Endpunkte definieren",
      "Logging konfigurieren"
    ],
    "correct": 1,
    "explanation": "CommandLineRunner ist ein Interface, dessen run()-Methode nach der Initialisierung der Spring Boot App ausgeführt wird. Es eignet sich für Initialisierungscode beim Start.",
    "xp": 20,
    "tags": [
      "uebung"
    ]
  },
  {
    "difficulty": 3,
    "type": "multiple",
    "question": "Was bedeutet 'Inversion of Control' im Spring-Kontext?",
    "options": [
      "Die Umkehrung der Programmflusssteuerung",
      "Das manuelle Erstellen von Objekten",
      "Die direkte Objektreferenzierung",
      "Die Verwendung von statischen Methoden"
    ],
    "correct": 0,
    "explanation": "Inversion of Control bedeutet, dass die Kontrolle über Objekterstellung und -verwaltung an den Spring Container übertragen wird, statt sie selbst zu implementieren.",
    "xp": 30,
    "tags": [
      "uebung"
    ]
  },
  {
    "difficulty": 3,
    "type": "checkbox",
    "question": "Welche Aussagen über Konstruktor-Injektion sind korrekt? (Mehrfachauswahl)",
    "options": [
      "Garantiert vollständige Initialisierung",
      "Unterstützt Immutability",
      "Macht Abhängigkeiten explizit",
      "Ist flexibler als Setter-Injektion",
      "Erfordert weniger Code als Feld-Injektion"
    ],
    "correct": [
      0,
      1,
      2
    ],
    "explanation": "Konstruktor-Injektion wird bevorzugt, weil sie vollständige Initialisierung garantiert, Immutability ermöglicht und Abhängigkeiten explizit macht. Sie ist nicht flexibler und erfordert mehr Code.",
    "xp": 30,
    "tags": [
      "uebung"
    ]
  },
  {
    "difficulty": 3,
    "type": "matching",
    "question": "Ordne die Spring-Annotationen ihrer Hauptfunktion zu:",
    "pairs": [
      {
        "left": "@SpringBootApplication",
        "right": "Kombiniert mehrere Basis-Annotationen"
      },
      {
        "left": "@Component",
        "right": "Markiert Klasse als Spring-verwaltete Komponente"
      },
      {
        "left": "@Bean",
        "right": "Definiert Methode zur Bean-Erstellung"
      },
      {
        "left": "@Autowired",
        "right": "Injiziert Abhängigkeiten"
      }
    ],
    "explanation": "Die Annotationen haben unterschiedliche Zwecke: @SpringBootApplication für App-Konfiguration, @Component für Komponenten-Scanning, @Bean für explizite Bean-Definition, @Autowired für Dependency Injection.",
    "xp": 35,
    "tags": [
      "uebung"
    ]
  },
  {
    "difficulty": 4,
    "type": "checkbox",
    "question": "Welche Konzepte sind Teil der Spring Boot Auto-Konfiguration? (Mehrfachauswahl)",
    "options": [
      "Konvention vor Konfiguration",
      "Bedingte Bean-Registrierung",
      "Externe Konfigurationsdateien",
      "Starter Dependencies",
      "Metriken und Health-Checks"
    ],
    "correct": [
      0,
      1,
      3
    ],
    "explanation": "Spring Boot's Auto-Konfiguration basiert auf mehreren Konzepten: Konventionen, bedingter Bean-Registrierung und Starter Dependencies. Externe Konfigurationsdateien und Metriken sind separate Features.",
    "xp": 40,
    "tags": [
      "uebung"
    ]
  },
  {
    "difficulty": 4,
    "type": "matching",
    "question": "Ordne die Maven-Konzepte ihrer Bedeutung zu:",
    "pairs": [
      {
        "left": "groupId",
        "right": "Organisationsweiter, eindeutiger Identifier"
      },
      {
        "left": "artifactId",
        "right": "Name des Projekts/der Bibliothek"
      },
      {
        "left": "version",
        "right": "Spezifische Release-Kennung"
      },
      {
        "left": "parent",
        "right": "Vererbungshierarchie und gemeinsame Konfiguration"
      }
    ],
    "explanation": "Maven POM-Elemente haben spezifische Rollen: groupId für Organisation, artifactId für Projektname, version für Release-Identifikation, parent für Vererbung.",
    "xp": 40,
    "tags": [
      "uebung"
    ]
  },
  {
    "difficulty": 4,
    "type": "checkbox",
    "question": "Welche Aspekte unterscheiden Integration-Tests von Unit-Tests in Spring Boot? (Mehrfachauswahl)",
    "options": [
      "Vollständiger Spring Kontext wird geladen",
      "Testen mehrerer Komponenten zusammen",
      "Verwendung von @SpringBootTest",
      "Längere Ausführungszeit",
      "Externe Ressourcen können eingebunden sein"
    ],
    "correct": [
      0,
      1,
      2,
      3,
      4
    ],
    "explanation": "Integration-Tests unterscheiden sich durch: Laden des Spring Kontexts, Testing mehrerer Komponenten, @SpringBootTest Annotation, längere Laufzeit und mögliche externe Ressourcen.",
    "xp": 45,
    "tags": [
      "uebung"
    ]
  },
  {
    "difficulty": 1,
    "type": "multiple",
    "question": "Was ist GitHub?",
    "options": [
      "Ein Texteditor",
      "Eine Codehosting-Plattform für Versionskontrolle",
      "Eine Programmiersprache",
      "Ein Betriebssystem"
    ],
    "correct": 1,
    "explanation": "GitHub ist eine Codehosting-Plattform für die Versionskontrolle und Zusammenarbeit in Projekten.",
    "xp": 10,
    "tags": [
      "uebung",
      "offiziell"
    ]
  },
  {
    "difficulty": 2,
    "type": "multiple",
    "question": "Was ist eine Bean in Spring?",
    "options": [
      "Eine JavaScript-Bibliothek",
      "Eine Datenbank-Tabelle",
      "Ein verwaltetes Java-Objekt innerhalb des Spring Containers",
      "Ein Konfigurationsfile"
    ],
    "correct": 2,
    "explanation": "Eine Bean ist ein verwaltetes Java-Objekt innerhalb des Spring Containers. Die Bean wird erstellt, überwacht und gelöscht.",
    "xp": 20,
    "tags": [
      "uebung"
    ]
  },
  {
    "difficulty": 2,
    "type": "matching",
    "question": "Ordne die Spring-Annotationen ihrer Funktion zu:",
    "pairs": [
      {
        "left": "@SpringBootApplication",
        "right": "Kennzeichnet die Main-Klasse"
      },
      {
        "left": "@Component",
        "right": "Macht die Klasse zu einer Bean"
      },
      {
        "left": "@Autowired",
        "right": "Injiziert ein Bean-Objekt"
      },
      {
        "left": "@Bean",
        "right": "Definiert eine Bean-Methode"
      }
    ],
    "explanation": "@SpringBootApplication markiert die Main-Klasse, @Component macht Klassen zu Beans, @Autowired injiziert Dependencies, @Bean definiert Bean-Methoden.",
    "xp": 25,
    "tags": [
      "uebung"
    ]
  },
  {
    "difficulty": 2,
    "type": "fillblank",
    "question": "In Spring Boot wird die Konfiguration in der Datei _____ im Ordner _____ gespeichert.",
    "blanks": [
      "application.properties",
      "resources"
    ],
    "explanation": "Die Datei application.properties im Ordner resources enthält die Konfiguration für Spring Boot Anwendungen.",
    "xp": 20,
    "tags": [
      "uebung"
    ]
  },
  {
    "difficulty": 2,
    "type": "sort",
    "question": "Sortiere die Log-Level von niedrigster zu höchster Priorität:",
    "items": [
      "ERROR",
      "WARN",
      "INFO",
      "DEBUG",
      "TRACE"
    ],
    "correct": [
      "TRACE",
      "DEBUG",
      "INFO",
      "WARN",
      "ERROR"
    ],
  "explanation": "Die Log-Level von niedrigster zu höchster Priorität: TRACE (am detailliertesten) → DEBUG → INFO → WARN → ERROR (kritischste Fehler).\n✅ TRACE → DEBUG → INFO → WARN → ERROR",
    "xp": 25,
    "tags": [
      "uebung"
    ]
  },
  {
    "difficulty": 2,
    "type": "multiple",
    "question": "Was ist Maven?",
    "options": [
      "Ein Web-Framework",
      "Eine Datenbank",
      "Eine Programmiersprache",
      "Ein Build-Management-Tool für Java-Projekte"
    ],
    "correct": 3,
    "explanation": "Maven ist ein Build-Management-Tool, das den Software-Erstellungszyklus verwaltet. Konfiguration erfolgt in pom.xml.",
    "xp": 20,
    "tags": [
      "uebung"
    ]
  },
  {
    "difficulty": 2,
    "type": "fillblank",
    "question": "Um den Log-Level für ein Package auf DEBUG zu setzen, verwendet man in application.properties: logging.level.<Packagename>=_____",
    "blanks": [
      "DEBUG"
    ],
    "explanation": "Mit logging.level.<packagename>=DEBUG wird der Log-Level für ein Package auf DEBUG gesetzt.",
    "xp": 20,
    "tags": [
      "uebung"
    ]
  },
  {
    "difficulty": 3,
    "type": "sort",
    "question": "Sortiere die Schichten der 3-Tier-Architektur von oben nach unten:",
    "items": [
      "Datenhaltungsschicht",
      "Anwendungslogik-Schicht",
      "Präsentationsschicht"
    ],
    "correct": [
      "Präsentationsschicht",
      "Anwendungslogik-Schicht",
      "Datenhaltungsschicht"
    ],
  "explanation": "3-Tier-Architektur von oben: Präsentationsschicht (UI) → Anwendungslogik (Business Logic) → Datenhaltung (Datenbank).\n✅ Präsentationsschicht → Anwendungslogik-Schicht → Datenhaltungsschicht",
    "xp": 30,
    "tags": [
      "uebung"
    ]
  },
  {
    "difficulty": 3,
    "type": "matching",
    "question": "Ordne die REST-Prinzipien ihrer Beschreibung zu:",
    "pairs": [
      {
        "left": "Stateless",
        "right": "Zustandslosigkeit der Anfragen"
      },
      {
        "left": "Cacheability",
        "right": "Responses können gecacht werden"
      },
      {
        "left": "Uniform Interface",
        "right": "Einheitliche Schnittstelle"
      },
      {
        "left": "HATEOAS",
        "right": "Links zu verwandten Ressourcen"
      }
    ],
    "explanation": "REST-Prinzipien: Stateless (zustandslos), Cacheability (cachebar), Uniform Interface (einheitlich), HATEOAS (Hypermedia as Engine of Application State).",
    "xp": 35,
    "tags": [
      "uebung"
    ]
  },
  {
    "difficulty": 3,
    "type": "checkbox",
    "question": "Welche HTTP-Methoden sind 'safe' (sicher)? (Mehrfachauswahl)",
    "options": [
      "POST",
      "GET",
      "PUT",
      "HEAD",
      "DELETE"
    ],
    "correct": [
      1,
      3
    ],
    "explanation": "Safe (sicher) sind nur GET und HEAD - sie ändern keine Daten auf dem Server. POST, PUT und DELETE ändern Daten.",
    "xp": 30,
    "tags": [
      "uebung"
    ]
  },
  {
    "difficulty": 3,
    "type": "fillblank",
    "question": "Die Annotation _____ kennzeichnet Test-Methoden in JUnit, während _____ die Test-Klasse für Spring Boot markiert.",
    "blanks": [
      "@Test",
      "@SpringBootTest"
    ],
    "explanation": "@Test markiert einzelne Test-Methoden, @SpringBootTest kennzeichnet die Test-Klasse für Spring Boot.",
    "xp": 30,
    "tags": [
      "uebung"
    ]
  },
  {
    "difficulty": 3,
    "type": "multiple",
    "question": "Was passiert, wenn die @Autowired Annotation entfernt wird?",
    "options": [
      "Das Programm läuft schneller",
      "Die Bean wird nicht injiziert und es gibt eine NullPointerException",
      "Die Bean wird automatisch erstellt",
      "Das Programm kompiliert nicht"
    ],
    "correct": 1,
    "explanation": "Ohne @Autowired wird das Bean-Objekt nicht injiziert und bleibt null, was zu einer NullPointerException führt, wenn darauf zugegriffen wird.",
    "xp": 30,
    "tags": [
      "uebung"
    ]
  },
  {
    "difficulty": 3,
    "type": "multiple",
    "question": "Welche Operationen unterstützt GraphQL?",
    "options": [
      "SELECT, INSERT, UPDATE, DELETE",
      "GET, POST, PUT, DELETE",
      "Query, Mutation, Subscription",
      "READ, WRITE, UPDATE"
    ],
    "correct": 2,
    "explanation": "GraphQL unterstützt: Query (Abfragen), Mutation (Änderungen), Subscription (Echtzeit-Updates).",
    "xp": 30,
    "tags": [
      "uebung"
    ]
  },
  {
    "difficulty": 4,
    "type": "matching",
    "question": "Ordne die Komponenten des MVC-Patterns ihrer Rolle zu:",
    "pairs": [
      {
        "left": "Model",
        "right": "Datenmodell und Geschäftslogik"
      },
      {
        "left": "View",
        "right": "Darstellung der Benutzeroberfläche"
      },
      {
        "left": "Controller",
        "right": "Steuerung und Vermittlung"
      },
      {
        "left": "@RequestMapping",
        "right": "Verknüpfung von URLs mit Methoden"
      }
    ],
    "explanation": "MVC: Model (Daten/Logik), View (UI), Controller (Steuerung). @RequestMapping verbindet HTTP-Requests mit Handler-Methoden.",
    "xp": 40,
    "tags": [
      "uebung"
    ]
  },
  {
    "difficulty": 4,
    "type": "sort",
    "question": "Sortiere den Maven Build-Zyklus in der richtigen Reihenfolge:",
    "items": [
      "Installation",
      "Validierung",
      "Verifizierung",
      "Kompilierung",
      "Testen",
      "Paketieren"
    ],
    "correct": [
      "Validierung",
      "Kompilierung",
      "Testen",
      "Paketieren",
      "Verifizierung",
      "Installation"
    ],
  "explanation": "Maven Build-Zyklus: Validierung → Kompilierung → Testen → Paketieren → Verifizierung → Installation (Items-Reihenfolge; Integrationstests & Verteilung sind optionale weitere Phasen).\n✅ Validierung → Kompilierung → Testen → Paketieren → Verifizierung → Installation",
    "xp": 40,
    "tags": [
      "uebung"
    ]
  },
  {
    "difficulty": 2,
    "type": "multiple",
    "question": "Wo wird in einer Maven-basierten Spring-Boot-Anwendung die Spring Boot Version üblicherweise festgelegt?",
    "options": [
      "Im <dependencies>-Block der pom.xml",
      "Im <parent>-Tag der pom.xml mit artifactId 'spring-boot-starter-parent'",
      "In der application.properties",
      "In der Klasse mit @SpringBootApplication"
    ],
    "correct": 1,
    "explanation": "In Maven-Projekten wird die Spring Boot Version über den <parent>-Eintrag mit artifactId 'spring-boot-starter-parent' definiert. Die Version vererbt sich dann auf die Starter-Abhängigkeiten.",
    "xp": 20,
    "tags": [
      "uebung"
    ]
  },
  {
    "difficulty": 4,
    "type": "checkbox",
    "question": "Welche Eigenschaften hat Spring Boot? (Mehrfachauswahl)",
    "options": [
      "Benötigt externe War-Dateien",
      "Eingebettete Container (Tomcat, Jetty)",
      "Automatische Konfiguration soweit möglich",
      "Generierung von Code und Konfiguration",
      "Keine externen Laufzeitabhängigkeiten"
    ],
    "correct": [
      1,
      2,
      4
    ],
    "explanation": "Spring Boot: eingebettete Container, automatische Konfiguration, keine externen Laufzeitabhängigkeiten, KEINE War-Dateien nötig, KEINE Code-Generierung.",
    "xp": 40,
    "tags": [
      "uebung"
    ]
  },
  {
    "difficulty": 4,
    "type": "multiple",
    "question": "Welches Protokoll nutzt gRPC als Transportprotokoll und zu welcher OSI-Schicht gehört es?",
    "options": [
      "WebSocket, Schicht 6",
      "TCP, Schicht 4",
      "HTTP/2, Schicht 7",
      "HTTP/1.1, Schicht 7"
    ],
    "correct": 2,
    "explanation": "gRPC nutzt HTTP/2 als Transportprotokoll, welches zur OSI-Schicht 7 (Anwendungsschicht) gehört.",
    "xp": 40,
    "tags": [
      "uebung"
    ]
  },
  {
    "difficulty": 4,
    "type": "text",
    "question": "Was ist das besondere Feature von gRPC im Vergleich zu REST und GraphQL?",
    "correct": [
      "bidirektionales streaming",
      "bidirectional streaming",
      "streaming"
    ],
    "explanation": "gRPC unterstützt bidirektionales Streaming in verschiedenen Formen: Unary, Server-Streaming, Client-Streaming, Bidirectional-Streaming.",
    "xp": 40,
    "tags": [
      "uebung"
    ]
  },
  {
    "difficulty": 4,
    "type": "fillblank",
    "question": "Eine SPA (Single Page Application) lädt Inhalte dynamisch per _____ nach, ohne die Seite neu zu _____.",
    "blanks": [
      "ajax",
      "laden"
    ],
    "explanation": "Bei einer SPA läuft die Anwendung auf einer HTML-Seite. Inhalte werden dynamisch per AJAX nachgeladen, ohne Seitenneuladung.",
    "xp": 40,
    "tags": [
      "uebung"
    ]
  },
  {
    "difficulty": 4,
    "type": "checkbox",
    "question": "Welche sind serverseitige Technologien? (Mehrfachauswahl)",
    "options": [
      "JavaScript (Client)",
      "PHP",
      "Java Servlets",
      "CSS",
      "Node.js"
    ],
    "correct": [
      1,
      2,
      4
    ],
    "explanation": "Serverseitige Technologien: PHP, Java Servlets, Node.js, Python (Django), Ruby on Rails. JavaScript und CSS laufen primär clientseitig.",
    "xp": 40,
    "tags": [
      "uebung"
    ]
  },
  {
    "difficulty": 4,
    "type": "matching",
    "question": "Ordne die URL-Bestandteile dem Beispiel zu: http://fb2.fra-uas.de:8080/ebis/urls.html?prof=lehmann",
    "pairs": [
      {
        "left": "Scheme",
        "right": "http://"
      },
      {
        "left": "Hostname",
        "right": "fb2.fra-uas.de"
      },
      {
        "left": "Port",
        "right": ":8080"
      },
      {
        "left": "Query",
        "right": "?prof=lehmann"
      }
    ],
    "explanation": "URL-Struktur: Scheme (Protokoll) → Hostname (Domain) → Port → Path (Pfad) → Query (Parameter).",
    "xp": 45,
    "tags": [
      "uebung"
    ]
  },
  {
    "difficulty": 4,
    "type": "multiple",
    "question": "Wofür steht die Abkürzung PHP (rekursives Akronym)?",
    "options": [
      "Personal Home Page",
      "Private Hypertext Processor",
      "PHP: Hypertext Preprocessor",
      "Public HTML Protocol"
    ],
    "correct": 2,
    "explanation": "PHP steht für 'PHP: Hypertext Preprocessor' - ein rekursives Akronym. PHP ist eine serverseitige Skriptsprache.",
    "xp": 40,
    "tags": [
      "uebung"
    ]
  },
  {
    "difficulty": 3,
    "type": "multiple",
    "question": "Was ist HATEOAS im Kontext von REST?",
    "options": [
      "Ein HTTP-Header",
      "Eine Datenbank-Technologie",
      "Hypermedia as Engine of Application State - Links in Responses",
      "Ein JavaScript Framework"
    ],
    "correct": 2,
    "explanation": "HATEOAS (Hypermedia as the Engine of Application State): Der Server liefert in Responses Links zu verwandten Ressourcen mit.",
    "xp": 30,
    "tags": [
      "uebung"
    ]
  },
  {
    "difficulty": 3,
    "type": "fillblank",
    "question": "Um eine Datei für Logging anzugeben, verwendet man logging._____ und für ein Verzeichnis logging._____",
    "blanks": [
      "file",
      "path"
    ],
    "explanation": "Mit logging.file gibt man eine Datei an, mit logging.path ein Verzeichnis. Ohne Angabe wird in spring.log geschrieben.",
    "xp": 30,
    "tags": [
      "uebung"
    ]
  },
  {
    "difficulty": 2,
    "type": "multiple",
    "question": "Wofür steht AJAX?",
    "options": [
      "Advanced Java and XML",
      "Asynchronous JavaScript and XML",
      "Automatic JSON and XML",
      "Application JavaScript Architecture XML"
    ],
    "correct": 1,
    "explanation": "AJAX steht für Asynchronous JavaScript and XML - ermöglicht asynchrone Datenübertragung ohne Seitenneuladung.",
    "xp": 20,
    "tags": [
      "uebung"
    ]
  },
  {
    "difficulty": 1,
    "type": "multiple",
    "question": "Wer ist für die Standardisierung von HTML zuständig?",
    "options": [
      "W3C (World Wide Web Consortium)",
      "Microsoft",
      "Google",
      "ISO"
    ],
    "correct": 0,
    "explanation": "Das W3C (World Wide Web Consortium) ist für die Standardisierung von HTML zuständig.",
    "xp": 10,
    "tags": [
      "uebung"
    ]
  },
  {
    "difficulty": 3,
    "type": "multiple",
    "question": "Was ist das Ziel von Responsive Web Design?",
    "options": [
      "Automatische Updates",
      "Optimale Darstellung auf verschiedenen Bildschirmgrößen",
      "Schnellere Serverantworten",
      "Bessere Suchmaschinenoptimierung"
    ],
    "correct": 1,
    "explanation": "Responsive Web Design sorgt für optimale Darstellung und Bedienbarkeit auf verschiedenen Geräten und Bildschirmgrößen.",
    "xp": 30,
    "tags": [
      "uebung"
    ]
  },
  {
    "difficulty": 2,
    "type": "fillblank",
    "question": "Git wurde 2005 von _____ _____ entwickelt.",
    "blanks": [
      "Linus",
      "Torvalds"
    ],
    "explanation": "Git ist ein Open-Source-Versionskontrollsystem, das 2005 von Linus Torvalds entwickelt wurde.",
    "xp": 20,
    "tags": [
      "uebung"
    ]
  },
  {
    "difficulty": 4,
    "type": "multiple",
    "question": "Welche Java-Bibliothek wird in Spring Boot Tests für aussagekräftige Assertions verwendet?",
    "options": [
      "Hamcrest",
      "JUnit Basic",
      "AssertJ",
      "Mockito"
    ],
    "correct": 2,
    "explanation": "AssertJ wird verwendet. Tests werden mit verketteten Methodenaufrufen lesbarer und Fehlermeldungen sind detaillierter als bei Hamcrest.",
    "xp": 40,
    "tags": [
      "uebung"
    ]
  },
  {
    "difficulty": 1,
    "type": "multiple",
    "question": "Was war der erste Dienst des Internets?",
    "options": [
      "World Wide Web",
      "E-Mail (1972)",
      "FTP",
      "Telnet"
    ],
    "correct": 1,
    "explanation": "1972 wurde das E-Mail-Protokoll von Ray Tomlinson für das ARPANET entwickelt - der erste Dienst des Internets.",
    "xp": 10,
    "tags": [
      "uebung",
      "vl-offiziell"
    ]
  },
  {
    "difficulty": 3,
    "type": "checkbox",
    "question": "Welche Basiskonzepte gehören zum WWW? (Mehrfachauswahl)",
    "options": [
      "Client-Server Architektur",
      "Peer-to-Peer Netzwerk",
      "Hypermedia-Inhalte",
      "URIs (Links)",
      "Blockchain"
    ],
    "correct": [
      0,
      2,
      3
    ],
    "explanation": "WWW-Basiskonzepte: Client-Server Architektur, Hypermedia-Inhalte, URIs, HTML, HTTP. Peer-to-Peer und Blockchain gehören nicht dazu.",
    "xp": 30,
    "tags": [
      "uebung"
    ]
  },
  {
    "difficulty": 1,
    "type": "multiple",
    "question": "Was ist das Ziel von Logging in Spring Boot?",
    "options": [
      "Datenbankverwaltung",
      "Server-Überwachung",
      "Sicherheitsprüfung",
      "Fehlerbehebung und Programmverfolgung"
    ],
    "correct": 3,
    "explanation": "Logging dient in erster Linie dazu, die Ausführung der Anwendung nachzuvollziehen und Fehler schneller zu finden und zu beheben.",
    "xp": 10,
    "tags": [
      "uebung",
      "neue-vorlesung",
      "offiziell"
    ]
  },
  {
    "difficulty": 1,
    "type": "multiple",
    "question": "Die Mainklasse in einem Spring Boot ist nicht mit der Annotation @SpringBootApplication versehen",
    "options": [
      "Wahr",
      "Falsch"
    ],
    "correct": 1,
    "explanation": "Typischerweise ist die Main-Klasse mit @SpringBootApplication annotiert, was Auto-Konfiguration, Component-Scan und Konfiguration bündelt.",
    "xp": 10,
    "tags": [
      "uebung",
      "neue-vorlesung",
      "offiziell"
    ]
  },
  {
    "difficulty": 1,
    "type": "multiple",
    "question": "Was macht die Annotation @SpringBootApplication?",
    "options": [
      "Sie definiert eine REST-API",
      "Sie markiert die Main-Klasse einer Anwendung",
      "Sie erstellt ein Logging-Template",
      "Sie deaktiviert die automatische Konfiguration"
    ],
    "correct": 1,
    "explanation": "@SpringBootApplication kennzeichnet die Hauptanwendung und kombiniert @Configuration, @EnableAutoConfiguration und @ComponentScan.",
    "xp": 10,
    "tags": [
      "uebung",
      "neue-vorlesung",
      "offiziell"
    ]
  },
  {
    "difficulty": 1,
    "type": "multiple",
    "question": "Eine Bean wird durch den Spring Container nicht automatisch ausgeführt",
    "options": [
      "Wahr",
      "Falsch"
    ],
    "correct": 1,
    "explanation": "Falsch. Spring erstellt beim Start automatisch eine Instanz jeder registrierten Bean (@Component, @Service, @Bean, etc.), initialisiert sie, verwaltet ihren Lifecycle und injiziert Abhängigkeiten – die Bean wird also durchaus automatisch 'ausgeführt' (erzeugt und verdrahtet).",
    "xp": 10,
    "tags": [
      "uebung",
      "neue-vorlesung",
      "offiziell"
    ]
  },
  {
    "difficulty": 2,
    "type": "multiple",
    "question": "Die Annotation @SpringBootTest wird nicht verwendet, um anzugeben, dass ein JUnit-Test für die gesamte Spring-Anwendung ausgeführt wird",
    "options": [
      "Wahr",
      "Falsch"
    ],
    "correct": 1,
    "explanation": "@SpringBootTest lädt typischerweise den vollständigen Application Context für Integrationstests – die Aussage ist daher falsch.",
    "xp": 15,
    "tags": [
      "uebung",
      "neue-vorlesung",
      "offiziell"
    ]
  },
  {
    "difficulty": 1,
    "type": "multiple",
    "question": "System.out.println() sollte nicht in einer Produktionsumgebung verwendet werden, um Fehlerprotokolle auszugeben",
    "options": [
      "Wahr",
      "Falsch"
    ],
    "correct": 0,
    "explanation": "In Produktion sollten strukturierte Logs (z.B. SLF4J/Logback) verwendet werden – println ist unstrukturiert und schlecht zu verarbeiten.",
    "xp": 10,
    "tags": [
      "uebung",
      "neue-vorlesung",
      "offiziell"
    ]
  },
  {
    "difficulty": 1,
    "type": "multiple",
    "question": "Spring Boot basiert vollständig auf dem Spring Framework",
    "options": [
      "Wahr",
      "Falsch"
    ],
    "correct": 0,
    "explanation": "Spring Boot basiert vollständig auf dem Spring Framework und erweitert es um Auto-Konfiguration und eingebettete Server.",
    "xp": 10,
    "tags": [
      "uebung",
      "neue-vorlesung",
      "offiziell"
    ]
  },
  {
    "difficulty": 1,
    "type": "multiple",
    "question": "Beans können nur mit der Annotation @Service erstellt werden",
    "options": [
      "Wahr",
      "Falsch"
    ],
    "correct": 1,
    "explanation": "Beans können mit verschiedenen Annotationen erstellt werden: @Component, @Service, @Repository, @Controller, @Bean, etc.",
    "xp": 10,
    "tags": [
      "uebung",
      "neue-vorlesung",
      "offiziell"
    ]
  },
  {
    "difficulty": 1,
    "type": "multiple",
    "question": "Welche Maven-Datei enthält die Projektkonfiguration?",
    "options": [
      "pom.xml",
      "application.properties",
      "build.gradle",
      "config.yaml"
    ],
    "correct": 0,
    "explanation": "Die pom.xml (Project Object Model) enthält die gesamte Maven-Projektkonfiguration inkl. Dependencies, Plugins und Build-Einstellungen.",
    "xp": 10,
    "tags": [
      "uebung",
      "neue-vorlesung",
      "offiziell"
    ]
  },
  {
    "difficulty": 1,
    "type": "multiple",
    "question": "In welcher Datei werden die Abhängigkeiten bei einem Spring Boot-Projekt verwaltet (Maven)?",
    "options": [
      "mvnw.cmd",
      "application.properties",
      "pom.xml",
      "build.gradle"
    ],
    "correct": 2,
    "explanation": "Die pom.xml (Project Object Model) enthält die gesamte Maven-Projektkonfiguration inkl. Dependencies, Plugins und Build-Einstellungen.",
    "xp": 10,
    "tags": [
      "uebung",
      "neue-vorlesung",
      "offiziell"
    ]
  },
  {
    "difficulty": 2,
    "type": "matching",
    "question": "Ordnen Sie die einzelnen Log-Level den entsprechenden Meldungen zu",
    "pairs": [
      {
        "left": "ERROR",
        "right": "Fehler (wie behandelte Ausnahme oder zu analysierende Probleme)"
      },
      {
        "left": "WARN",
        "right": "Situation, die nicht erwartet werden und zu Fehler führen könnte"
      },
      {
        "left": "INFO",
        "right": "Informationen zu auftretenden Ereignissen (z.B. Start/Ende, DB-Verbindung)"
      },
      {
        "left": "DEBUG",
        "right": "Debugging inklusive Informationen zum Programmablauf"
      },
      {
        "left": "TRACE",
        "right": "Ausführlicheres Debugging inklusive detaillierter Informationen zum Ablauf"
      }
    ],
    "explanation": "ERROR = kritische Fehler, WARN = potenziell problematische Situationen, INFO = wichtige Ereignisse, DEBUG = Details für Entwickler, TRACE = sehr detaillierte Ablaufverfolgung.",
    "xp": 25,
    "tags": [
      "uebung",
      "neue-vorlesung"
    ]
  },
  {
    "difficulty": 2,
    "type": "multiple",
    "question": "Der Eintrag in der pom.xml-Datei <groupId>edu.fra.uas</groupId> nennt man auch …",
    "options": [
      "Gruppenkennung (package)",
      "Annotation",
      "Keines der oben genannten",
      "Projektversion"
    ],
    "correct": 0,
    "explanation": "Die groupId ist die Gruppenkennung (package), die organisationsweite, eindeutige Identifikation für Maven-Projekte.",
    "xp": 15,
    "tags": [
      "neue-vorlesung",
      "offiziell"
    ]
  },
  {
    "difficulty": 2,
    "type": "multiple",
    "question": "Was sind die Hauptverbesserungen von HTTP/2 gegenüber HTTP/1.1?",
    "options": [
      "Nur HTTPS-Unterstützung",
      "Multiplexing, Header-Kompression, Server Push und binäres Protokoll",
      "Bessere Sicherheit durch Verschlüsselung",
      "Kleinere Dateigrößen durch automatische Kompression"
    ],
    "correct": 1,
    "explanation": "HTTP/2 brachte wichtige Verbesserungen: Multiplexing (mehrere Anfragen parallel), Header-Kompression (HPACK), Server Push (proaktives Senden) und binäres statt textbasiertes Protokoll.",
    "xp": 20,
    "tags": [
      "neue-vorlesung"
    ]
  },
  {
    "difficulty": 3,
    "type": "sort",
    "question": "Sortiere die HTTP-Versionen nach ihrer Veröffentlichungsreihenfolge:",
    "items": [
      "HTTP/3",
      "HTTP/1.0",
      "HTTP/2",
      "HTTP/1.1"
    ],
    "correct": [
      "HTTP/1.0",
      "HTTP/1.1",
      "HTTP/2",
      "HTTP/3"
    ],
  "explanation": "HTTP-Versionen chronologisch: HTTP/1.0 (1996) → HTTP/1.1 (1997, Keep-Alive) → HTTP/2 (2015, Multiplexing) → HTTP/3 (2022, QUIC/UDP).\n✅ HTTP/1.0 → HTTP/1.1 → HTTP/2 → HTTP/3",
    "xp": 30,
    "tags": [
      "neue-vorlesung"
    ]
  },
  {
    "difficulty": 2,
    "type": "checkbox",
    "question": "Welche HTTP-Methoden sind 'safe' (sicher) und ändern keine Serverdaten? (Mehrfachauswahl)",
    "options": [
      "GET",
      "POST",
      "HEAD",
      "PUT",
      "OPTIONS"
    ],
    "correct": [
      0,
      2,
      4
    ],
    "explanation": "Safe HTTP-Methoden ändern keine Serverdaten: GET (Daten abrufen), HEAD (nur Header abrufen), OPTIONS (verfügbare Methoden abfragen). POST und PUT ändern Daten.",
    "xp": 25,
    "tags": [
      "neue-vorlesung"
    ]
  },
  {
    "difficulty": 1,
    "type": "multiple",
    "question": "System.out.println ist nicht zum produktiven Logging in Spring Boot geeignet",
    "options": [
      "Wahr",
      "Falsch"
    ],
    "correct": 0,
    "explanation": "System.out.println ist für produktive Anwendungen ungeeignet. Stattdessen sollte ein Logger (z.B. SLF4J) verwendet werden.",
    "xp": 10,
    "tags": [
      "neue-vorlesung"
    ]
  },
  {
    "type": "multiple",
    "question": "Was ist das Basisprotokoll des WWW?",
    "options": [
      "FTP - File Transfer Protocol",
      "HTTP - Hypertext Transfer Protocol",
      "SMTP - Simple Mail Transfer Protocol",
      "TCP - Transmission Control Protocol"
    ],
    "wrongAnswerPool": "protocols",
    "correct": 1,
    "explanation": "HTTP (Hypertext Transfer Protocol) ist das Basisprotokoll des WWW.",
    "xp": 10,
    "tags": [
      "vl-offiziell"
    ]
  },
  {
    "type": "text",
    "question": "Was ist eine Web-Anwendung? (Geben Sie die Definition ein)",
    "correct": [
      "web-anwendung",
      "client-server",
      "webbrowser",
      "web-technologien"
    ],
    "explanation": "Eine Web-Anwendung ist eine auf Web-Technologien basierende Client-Server-Anwendung. Bedienung erfolgt über Webbrowser oder dedizierte Clients, mit Webserver, Applikationsserver und Datenbanksystem serverseitig. Die Kommunikation erfolgt über HTTP, typischerweise unter Einsatz von Webframeworks.",
    "xp": 10,
    "tags": [
      "vl-offiziell"
    ]
  },
  {
    "type": "checkbox",
    "question": "Welche Vorteile bietet eine web-basierte Anwendung? (Wählen Sie mindestens 5)",
    "options": [
      "Parallele Nutzung",
      "Informationsaustausch in Echtzeit",
      "Zugriff von überall",
      "Nutzung durch Thin-Clients/kleine Geräte",
      "Einfacher Datenaustausch über standardisierte Schnittstellen",
      "Keine Nutzer-Updates nötig",
      "Skalierbarkeit",
      "Modularisierung (Microservices/Web Services)"
    ],
    "correct": [
      0,
      1,
      2,
      3,
      4,
      5,
      6,
      7
    ],
    "explanation": "Web-basierte Anwendungen bieten zahlreiche Vorteile: Parallele Nutzung, Echtzeit-Informationsaustausch, universeller Zugriff, Thin-Client-Nutzung, standardisierte Schnittstellen, automatische Updates, Skalierbarkeit und Modularisierung.",
    "xp": 15,
    "tags": [
      "vl-offiziell"
    ]
  },
  {
    "type": "checkbox",
    "question": "Welche HTTP-Methoden gehören zu Version 1.1?",
    "options": [
      "GET",
      "HEAD",
      "POST",
      "PUT",
      "DELETE",
      "CONNECT",
      "OPTIONS",
      "TRACE",
      "PATCH"
    ],
    "correct": [
      0,
      1,
      2,
      3,
      4,
      5,
      6,
      7,
      8
    ],
    "explanation": "HTTP 1.1 umfasst die Methoden: GET, HEAD, POST, PUT, DELETE, CONNECT, OPTIONS, TRACE und PATCH.",
    "xp": 15,
    "tags": [
      "vl-offiziell"
    ]
  },
  {
    "type": "multiple",
    "question": "Wozu dient das Keep-Alive Header-Feld in HTTP?",
    "options": [
      "Zum dauerhaften Speichern von Cookies",
      "Zur Wiederverwendung der TCP-Verbindung für mehrere Anfragen",
      "Zum Caching von Webseitendaten",
      "Zur Authentifizierung von Benutzern"
    ],
    "correct": 1,
    "explanation": "Keep-Alive hält die TCP-Verbindung zwischen Client und Server offen, damit mehrere HTTP-Anfragen über dieselbe Verbindung möglich sind. Dies ermöglicht auch Pipelining.",
    "xp": 10,
    "tags": [
      "vl-offiziell"
    ]
  },
  {
    "type": "fillblank",
    "question": "HTTP-Nachrichten bestehen aus: _____ → _____ → Leerzeile → Body",
    "blanks": [
      "Start-Zeile",
      "Header-Felder"
    ],
    "explanation": "HTTP-Nachrichten bestehen aus: Start-Zeile (Request-Line oder Status-Line) → Header-Felder → Leerzeile → Body (Nutzdaten).",
    "xp": 10,
    "tags": [
      "vl-offiziell"
    ]
  },
  {
    "type": "multiple",
    "question": "Was ist der Unterschied zwischen HTTP-Anfrage und HTTP-Statusinformation in der Start-Zeile?",
    "options": [
      "Request: Method SP Request-URI SP HTTP-Version CRLF; Response: HTTP-Version SP Status-Code SP Reason-Phrase CRLF",
      "Kein Unterschied, beide haben das gleiche Format",
      "Request verwendet GET, Response verwendet POST",
      "Request enthält immer einen Body, Response nie"
    ],
    "correct": 0,
    "explanation": "Request-Start-Line: Method SP Request-URI SP HTTP-Version CRLF; Response-Start-Line: HTTP-Version SP Status-Code SP Reason-Phrase CRLF",
    "xp": 15,
    "tags": [
      "vl-offiziell"
    ]
  },
  {
    "type": "checkbox",
    "question": "Welche Verbesserungen wurden durch HTTP 1.1 eingeführt?",
    "options": [
      "Verbindung wird standardmäßig nicht sofort getrennt",
      "Unterstützung für mehrere Anfragen über dieselbe Verbindung",
      "Pipelining",
      "Effizientere Nutzung der TCP-Verbindung"
    ],
    "correct": [
      0,
      1,
      2,
      3
    ],
    "explanation": "HTTP 1.1 brachte folgende Verbesserungen: persistente Verbindungen, Multiplexing von Anfragen, Pipelining und effizientere TCP-Nutzung.",
    "xp": 15,
    "tags": [
      "vl-offiziell"
    ]
  },
  {
    "type": "checkbox",
    "question": "Welche Neuerungen brachte HTTP/2?",
    "options": [
      "Nur noch eine TCP-Verbindung nötig",
      "Kompression der Header",
      "Binäres statt textbasiertes Protokoll",
      "Server Push möglich",
      "Unterteilung in Streams und Frames"
    ],
    "wrongAnswerPool": "protocols",
    "additionalWrongAnswers": [
      "Ausschließlich verschlüsselte Verbindungen",
      "Unterstützung nur für mobile Geräte",
      "Automatische Übersetzung von Inhalten",
      "Integrierte Firewall-Funktionen",
      "Direkte Datenbankanbindung"
    ],
    "correct": [
      0,
      1,
      2,
      3,
      4
    ],
    "explanation": "HTTP/2 führte ein: Single TCP Connection, Header-Kompression, binäres Protokoll, Server Push und Stream/Frame-Struktur.",
    "xp": 15,
    "tags": [
      "vl-offiziell"
    ]
  },
  {
    "difficulty": 1,
    "type": "multiple",
    "question": "Was ist der Unterschied zwischen Internet und World Wide Web (WWW)?",
    "options": [
      "Das Internet ist neuer als das WWW",
      "WWW und Internet sind dasselbe",
      "Internet ist die physikalische Verbindung; WWW ist die Aufteilung in Web-Client und Web-Server",
      "Internet ist nur für E-Mails, WWW nur für Webseiten"
    ],
    "correct": 2,
    "explanation": "Internet ist die Verbindung unzähliger Subnetze (Interconnected Network, physikalische Verbindung). World Wide Web ist die Aufteilung der Kommunikation in Web-Client und Web-Server zur gezielten Adressierung von Dateien.",
    "xp": 10,
    "tags": [
      "vl-offiziell"
    ]
  },
  {
    "difficulty": 1,
    "type": "multiple",
    "question": "Wie hieß der Vorläufer des Internet und was waren dessen Ziele?",
    "options": [
      "ARPANET; Ziel war ein ausfallsicheres, weltweites Rechnernetz",
      "BITNET; Ziel war E-Mail-Kommunikation",
      "NSFNET; Ziel war wissenschaftlicher Austausch",
      "CSNET; Ziel war Verbindung von Universitäten"
    ],
    "correct": 0,
    "explanation": "ARPANET war der Vorläufer. Ziele: Ein Netz, in dem weltweit Rechner verbunden sind, das auch funktioniert, wenn Teile ausgefallen sind.",
    "xp": 10,
    "tags": [
      "vl-offiziell"
    ]
  },
  {
    "difficulty": 1,
    "type": "multiple",
    "question": "Wie waren die Rechner des ARPANET untergliedert?",
    "options": [
      "Nur Server und Clients",
      "Hosts (Benutzerrechner), IMPs (Netzrechner), TIPs (Terminal-Zugang)",
      "Mainframes und Terminals",
      "Workstations und Peripheriegeräte"
    ],
    "correct": 1,
    "explanation": "Die Rechner waren untergliedert in: Hosts (Benutzerrechner), Interface Message Processor (IMP, Netzrechner zur Nachrichtenzerlegung und Paketvermittlung), Terminal IMP (TIP, spezielle IMPs für direkten Terminalzugang)",
    "xp": 10,
    "tags": [
      "vl-offiziell"
    ]
  },
  {
    "difficulty": 1,
    "type": "multiple",
    "question": "Wozu dienten die Interface Message Processors (IMP)?",
    "options": [
      "Zur Benutzerauthentifizierung",
      "Zur Nachrichtenzerlegung und Paketvermittlung",
      "Zur Datenspeicherung",
      "Zur Grafikverarbeitung"
    ],
    "correct": 1,
    "explanation": "Die Interface Message Processors (IMPs) waren Netzrechner zur Nachrichtenzerlegung und Paketvermittlung.",
    "xp": 10,
    "tags": [
      "vl-offiziell"
    ]
  },
  {
    "difficulty": 1,
    "type": "multiple",
    "question": "Was versteht man unter Paketvermittlung?",
    "options": [
      "Versenden von Bytes durch elektromagnetische Signale",
      "Physische Zustellung von Paketen",
      "Speicherung von Daten in Paketen",
      "Verwaltung von Netzwerkprotokollen"
    ],
    "correct": 0,
    "explanation": "Unter Paketvermittlung versteht man das Versenden von Bytes durch elektromagnetische Signale.",
    "xp": 10,
    "tags": [
      "vl-offiziell"
    ]
  },
  {
    "difficulty": 1,
    "type": "checkbox",
    "question": "Welche sind die grundlegenden Protokolle des Internet?",
    "options": [
      "TCP",
      "IP",
      "HTTP",
      "FTP"
    ],
    "correct": [
      0,
      1
    ],
    "explanation": "Die grundlegenden Protokolle des Internet sind TCP und IP.",
    "xp": 10,
    "tags": [
      "vl-offiziell"
    ]
  },
  {
    "difficulty": 1,
    "type": "multiple",
    "question": "Wer erfand das WWW?",
    "options": [
      "Tim Berners-Lee",
      "Vint Cerf",
      "Larry Page",
      "Bill Gates"
    ],
    "correct": 0,
    "explanation": "Tim Berners-Lee erfand das World Wide Web (zusammen mit Robert Cailliau).",
    "xp": 10,
    "tags": [
      "vl-offiziell"
    ]
  },
  {
    "difficulty": 1,
    "type": "checkbox",
    "question": "Was sind die Basiskonzepte des WWW?",
    "options": [
      "Client-Server-Architektur",
      "Hypermedia-Inhalte",
      "Links auf Objekte im Netz (URIs)",
      "Textauszeichnungssprache HTML",
      "Übertragungsprotokoll HTTP"
    ],
    "correct": [
      0,
      1,
      2,
      3,
      4
    ],
    "explanation": "Die Basiskonzepte des WWW sind: Client-Server-Architektur, Hypermedia-Inhalte, Links auf Objekte im Netz (URIs), Textauszeichnungssprache HTML und das Übertragungsprotokoll HTTP.",
    "xp": 10,
    "tags": [
      "vl-offiziell"
    ]
  },
  {
    "difficulty": 1,
    "type": "multiple",
    "question": "Was ist eine Bean in Spring Boot?",
    "options": [
      "Eine Java-Datei",
      "Ein verwaltetes Java-Objekt im Spring Container",
      "Eine Logging-Konfiguration",
      "Eine Datenbankverbindung"
    ],
    "correct": 1,
    "explanation": "Eine Bean ist ein verwaltetes Java-Objekt im Spring Container, das von Spring verwaltet wird - inklusive Erstellung, Konfiguration und Lebenszyklus-Management.",
    "xp": 10,
    "tags": [
      "offiziell"
    ]
  },
  {
    "difficulty": 2,
    "type": "multiple",
    "question": "Die Methode init() ist ohne die Annotation @Bean immer noch automatisch ausführbar.",
    "options": [
      "Wahr",
      "Falsch"
    ],
    "correct": 1,
    "explanation": "Ohne @Bean wird init() nicht automatisch als Bean registriert und auch nicht ausgeführt.",
    "xp": 15,
    "tags": [
      "offiziell"
    ]
  },
  {
    "difficulty": 1,
    "type": "multiple",
    "question": "Spring Boot kann mit eingebetteten Servern wie Tomcat oder Jetty arbeiten.",
    "options": [
      "Wahr",
      "Falsch"
    ],
    "correct": 0,
    "explanation": "Spring Boot kommt mit eingebetteten Servern wie Tomcat, Jetty oder Undertow und erfordert keine externe Server-Installation.",
    "xp": 10,
    "tags": [
      "offiziell"
    ]
  },
  {
    "difficulty": 1,
    "type": "multiple",
    "question": "Die Annotation @Test markiert eine Methode als zu testender Code.",
    "options": [
      "Wahr",
      "Falsch"
    ],
    "correct": 0,
    "explanation": "@Test markiert eine Methode als Test-Methode, die vom Testing-Framework ausgeführt wird, nicht als zu testenden Code.",
    "xp": 10,
    "tags": [
      "offiziell"
    ]
  },
  {
    "difficulty": 1,
    "type": "multiple",
    "question": "Welche Annotation wird verwendet, um eine Klasse als Bean verfügbar zu machen?",
    "options": [
      "@Override",
      "@Service",
      "@Component",
      "@Autowired"
    ],
    "correct": 2,
    "explanation": "@Component markiert eine Klasse als Spring-Bean. @Service und andere sind spezialisierte Varianten von @Component.",
    "xp": 10,
    "tags": [
      "offiziell"
    ]
  },
  {
    "difficulty": 2,
    "type": "multiple",
    "question": "Logging in Spring Boot kann ausschließlich in die Konsole ausgegeben werden.",
    "options": [
      "Wahr",
      "Falsch"
    ],
    "correct": 1,
    "explanation": "Spring Boot kann auch in Dateien, externe Logging-Systeme, Datenbanken und viele andere Ziele loggen, nicht nur in die Konsole.",
    "xp": 15,
    "tags": [
      "offiziell"
    ]
  },
  {
    "difficulty": 2,
    "type": "multiple",
    "question": "Was beschreibt das Hollywood-Prinzip (\"Don't call us, we'll call you\") im Kontext von Spring?",
    "options": [
      "Jede Klasse erstellt ihre Abhängigkeiten selbst per new",
      "Das Framework ruft Komponenten auf und verkabelt Abhängigkeiten für uns",
      "Alle Services laufen immer im eigenen Thread",
      "Methoden werden automatisch parallel ausgeführt"
    ],
    "correct": 1,
    "explanation": "Das Hollywood-Prinzip bedeutet Inversion of Control (IoC): Das Framework übernimmt die Kontrolle und ruft unseren Code auf, statt umgekehrt.",
    "xp": 20,
    "tags": [
      "uebung",
      "neue-vorlesung",
      "woche3"
    ]
  },
  {
    "difficulty": 2,
    "type": "multiple",
    "question": "Welches Problem löst Dependency Injection?",
    "options": [
      "Man kann Java-Code ohne Klassen schreiben",
      "Man braucht keine Interfaces mehr",
      "Klassen müssen ihre Abhängigkeiten nicht mehr selbst instanziieren",
      "Exceptions werden unterdrückt"
    ],
    "correct": 2,
    "explanation": "Dependency Injection ermöglicht es, dass Abhängigkeiten von außen injiziert werden, statt sie per 'new' selbst zu erstellen. Das führt zu loser Kopplung.",
    "xp": 20,
    "tags": [
      "uebung",
      "neue-vorlesung",
      "woche3"
    ]
  },
  {
    "difficulty": 2,
    "type": "multiple",
    "question": "Wofür ist der IoC Container in Spring zuständig?",
    "options": [
      "Für die Übersetzung von Java in Bytecode",
      "Für das automatische Deployen auf Tomcat",
      "Für das Instanziieren, Konfigurieren und Injizieren von Beans",
      "Für das Speichern der Logs in einer Datenbank"
    ],
    "correct": 2,
    "explanation": "Der IoC (Inversion of Control) Container verwaltet den Lebenszyklus von Beans: Er erstellt, konfiguriert und injiziert sie automatisch.",
    "xp": 20,
    "tags": [
      "uebung",
      "neue-vorlesung",
      "woche3"
    ]
  },
  {
    "difficulty": 1,
    "type": "multiple",
    "question": "Was ist eine Bean im Sinne von Spring?",
    "options": [
      "Eine lokale Variable innerhalb von main()",
      "Ein Objekt, das vom Spring Container verwaltet wird",
      "Eine Datei in application.properties",
      "Ein HTTP Request"
    ],
    "correct": 1,
    "explanation": "Eine Bean ist ein Objekt, das vom Spring Container instanziiert, verwaltet und injiziert wird.",
    "xp": 10,
    "tags": [
      "uebung",
      "neue-vorlesung",
      "woche3"
    ]
  },
  {
    "difficulty": 2,
    "type": "multiple",
    "question": "Welche Aussage über lose Kopplung durch DI ist korrekt?",
    "options": [
      "Klassen hängen weniger hart voneinander ab",
      "Klassen reden nur noch über statische Methoden miteinander",
      "Man braucht kein Interface mehr",
      "Getter/Setter werden überflüssig"
    ],
    "correct": 0,
    "explanation": "Dependency Injection fördert lose Kopplung, da Klassen ihre Abhängigkeiten nicht selbst erstellen und dadurch weniger stark voneinander abhängen.",
    "xp": 20,
    "tags": [
      "uebung",
      "neue-vorlesung",
      "woche3"
    ]
  },
  {
    "difficulty": 1,
    "type": "multiple",
    "question": "Die Annotation @Autowired dient dazu, Abhängigkeiten automatisch zu injizieren",
    "options": [
      "Wahr",
      "Falsch"
    ],
    "correct": 0,
    "explanation": "@Autowired markiert Stellen, an denen Spring automatisch passende Beans injizieren soll.",
    "xp": 10,
    "tags": [
      "uebung",
      "neue-vorlesung",
      "woche3"
    ]
  },
  {
    "difficulty": 2,
    "type": "multiple",
    "question": "Welche Rolle hat @Qualifier?",
    "options": [
      "Startet die Spring Boot Anwendung",
      "Legt fest, welche konkrete Bean injiziert werden soll, wenn mehrere möglich sind",
      "Aktiviert das Logging",
      "Deaktiviert Autowiring"
    ],
    "correct": 1,
    "explanation": "@Qualifier hilft Spring zu entscheiden, welche Bean injiziert werden soll, wenn mehrere Beans vom gleichen Typ existieren.",
    "xp": 20,
    "tags": [
      "uebung",
      "neue-vorlesung",
      "woche3"
    ]
  },
  {
    "difficulty": 2,
    "type": "multiple",
    "question": "Warum kann es ohne @Qualifier bei mehreren Implementierungen eines Interfaces zu einem Fehler kommen?",
    "options": [
      "Spring injiziert immer die falsche Klasse absichtlich",
      "Spring kann nicht entscheiden, welche konkrete Bean gemeint ist",
      "Interfaces sind in Spring verboten",
      "Die Anwendung darf dann nicht mehr loggen"
    ],
    "correct": 1,
    "explanation": "Wenn mehrere Beans den gleichen Typ haben, kann Spring ohne @Qualifier nicht automatisch entscheiden, welche injiziert werden soll.",
    "xp": 20,
    "tags": [
      "uebung",
      "neue-vorlesung",
      "woche3"
    ]
  },
  {
    "difficulty": 2,
    "type": "multiple",
    "question": "Was macht @Primary?",
    "options": [
      "Markiert eine Bean als bevorzugte Wahl, falls mehrere Kandidaten existieren",
      "Startet den Garbage Collector",
      "Erzwingt Singleton Scope",
      "Aktiviert HTTPS"
    ],
    "correct": 0,
    "explanation": "@Primary markiert eine Bean als bevorzugte Standard-Wahl, wenn mehrere Beans vom gleichen Typ verfügbar sind.",
    "xp": 20,
    "tags": [
      "uebung",
      "neue-vorlesung",
      "woche3"
    ]
  },
  {
    "difficulty": 2,
    "type": "multiple",
    "question": "Was fasst @SpringBootApplication zusammen?",
    "options": [
      "@Controller, @Repository, @Service",
      "@PostConstruct, @PreDestroy, @Bean",
      "@Configuration, @EnableAutoConfiguration, @ComponentScan",
      "@Autowired, @Qualifier, @Primary"
    ],
    "correct": 2,
    "explanation": "@SpringBootApplication kombiniert @Configuration, @EnableAutoConfiguration und @ComponentScan in einer Annotation.",
    "xp": 20,
    "tags": [
      "uebung",
      "neue-vorlesung",
      "woche3"
    ]
  },
  {
    "difficulty": 2,
    "type": "multiple",
    "question": "Welche Aufgabe hat @EnableAutoConfiguration innerhalb von @SpringBootApplication?",
    "options": [
      "Sie deaktiviert alle Beans",
      "Sie sorgt dafür, dass Spring versucht, anhand des Classpaths passende Konfigurationen und Beans automatisch zu erstellen",
      "Sie startet die Datenbank",
      "Sie erzeugt automatisch Controller für alle Services"
    ],
    "correct": 1,
    "explanation": "@EnableAutoConfiguration analysiert den Classpath und konfiguriert Spring Boot automatisch basierend auf den gefundenen Abhängigkeiten.",
    "xp": 20,
    "tags": [
      "uebung",
      "neue-vorlesung",
      "woche3"
    ]
  },
  {
    "difficulty": 2,
    "type": "multiple",
    "question": "Was bewirkt @ComponentScan?",
    "options": [
      "Es kompiliert das Projekt",
      "Es durchsucht bestimmte Pakete nach Komponenten/Beans",
      "Es löscht unbenutzte Beans",
      "Es erzeugt HTTP Endpunkte für alle Klassen"
    ],
    "correct": 1,
    "explanation": "@ComponentScan durchsucht angegebene Pakete nach mit @Component (oder @Service, @Repository, etc.) annotierten Klassen und registriert sie als Beans.",
    "xp": 20,
    "tags": [
      "uebung",
      "neue-vorlesung",
      "woche3"
    ]
  },
  {
    "difficulty": 2,
    "type": "multiple",
    "question": "Was unterscheidet eine Klasse mit @Configuration von einer Klasse mit @Component?",
    "options": [
      "@Configuration-Klassen dürfen keinen Code enthalten",
      "@Configuration-Klassen sind nur für Logging zuständig",
      "@Configuration-Klassen enthalten Methoden mit @Bean, deren Rückgabewerte als Beans registriert werden",
      "Es gibt keinen Unterschied"
    ],
    "correct": 2,
    "explanation": "@Configuration-Klassen dienen als Bean-Definitionen und enthalten typischerweise @Bean-Methoden, die Objekte als Beans im Container registrieren.",
    "xp": 20,
    "tags": [
      "uebung",
      "neue-vorlesung",
      "woche3"
    ]
  },
  {
    "difficulty": 1,
    "type": "multiple",
    "question": "Die Methode, die mit @Bean annotiert ist, liefert ein Objekt zurück, das in den ApplicationContext als Bean gelegt wird",
    "options": [
      "Wahr",
      "Falsch"
    ],
    "correct": 0,
    "explanation": "Eine @Bean-Methode gibt ein Objekt zurück, das Spring als Bean im ApplicationContext registriert und verwaltet.",
    "xp": 10,
    "tags": [
      "uebung",
      "neue-vorlesung",
      "woche3"
    ]
  },
  {
    "difficulty": 2,
    "type": "multiple",
    "question": "Welche Aussage über ApplicationContext ist korrekt?",
    "options": [
      "ApplicationContext ist nur in Desktop-Anwendungen verfügbar",
      "ApplicationContext ist der zentrale Spring-Container, der Beans verwaltet",
      "ApplicationContext ersetzt den Java Compiler",
      "ApplicationContext ist nur für Datenbankverbindungen zuständig"
    ],
    "correct": 1,
    "explanation": "Der ApplicationContext ist der zentrale Spring IoC Container, der alle Beans verwaltet, konfiguriert und deren Lebenszyklus steuert.",
    "xp": 20,
    "tags": [
      "uebung",
      "neue-vorlesung",
      "woche3"
    ]
  },
  {
    "difficulty": 2,
    "type": "multiple",
    "question": "Was ist der WebApplicationContext?",
    "options": [
      "Ein spezieller Context für Web-spezifische Beans (Controller etc.)",
      "Ein JDBC-Treiber",
      "Ein Logging-Adapter",
      "Ein Maven-Plugin"
    ],
    "correct": 0,
    "explanation": "Der WebApplicationContext ist eine Spezialisierung des ApplicationContext für Webanwendungen mit zusätzlichen Features für Web-Komponenten.",
    "xp": 20,
    "tags": [
      "uebung",
      "neue-vorlesung",
      "woche3"
    ]
  },
  {
    "difficulty": 3,
    "type": "multiple",
    "question": "Welche Aufgabe hat das DispatcherServlet in einer Spring Web-Anwendung?",
    "options": [
      "Es kompiliert Java in Bytecode",
      "Es mapped HTTP-Requests auf Controller und nutzt den WebApplicationContext",
      "Es erzeugt Docker Images",
      "Es verwaltet die Gradle-Dependencies"
    ],
    "correct": 1,
    "explanation": "Das DispatcherServlet ist das zentrale Servlet in Spring MVC, das eingehende HTTP-Requests auf die passenden Controller-Methoden verteilt.",
    "xp": 30,
    "tags": [
      "uebung",
      "neue-vorlesung",
      "woche3"
    ]
  },
  {
    "difficulty": 2,
    "type": "multiple",
    "question": "Welche Aussage über den Bean-Lifecycle ist sinnvoll?",
    "options": [
      "Beans entstehen zufällig zur Laufzeit ohne Reihenfolge",
      "Beans haben einen definierten Lebenszyklus, in dem Initialisierung und Zerstörung gehookt werden können",
      "Beans werden nie zerstört",
      "Der Lifecycle gilt nur für Datenbank-Beans, nicht für Controller"
    ],
    "correct": 1,
    "explanation": "Beans durchlaufen einen definierten Lebenszyklus mit Phasen wie Instanziierung, Dependency Injection, Initialisierung (@PostConstruct) und Zerstörung (@PreDestroy).",
    "xp": 20,
    "tags": [
      "uebung",
      "neue-vorlesung",
      "woche3"
    ]
  },
  {
    "difficulty": 2,
    "type": "multiple",
    "question": "Wozu dient @PostConstruct?",
    "options": [
      "Läuft nach der Bean-Initialisierung und kann Startwerte setzen / initialisieren",
      "Läuft vor dem Kompilieren",
      "Läuft nach dem Shutdown der JVM",
      "Läuft nur bei HTTP-GET-Requests"
    ],
    "correct": 0,
    "explanation": "@PostConstruct markiert eine Methode, die nach der Dependency Injection ausgeführt wird, um Initialisierungslogik durchzuführen.",
    "xp": 20,
    "tags": [
      "uebung",
      "neue-vorlesung",
      "woche3"
    ]
  },
  {
    "difficulty": 2,
    "type": "multiple",
    "question": "Wozu dient @PreDestroy?",
    "options": [
      "Zum automatischen Deployment in die Cloud",
      "Wird vor dem Entfernen/Shutdown der Bean ausgeführt, um aufzuräumen",
      "Zum Generieren von Swagger-Dokumentation",
      "Zum Erstellen von neuen Threads"
    ],
    "correct": 1,
    "explanation": "@PreDestroy markiert eine Methode, die vor der Zerstörung einer Bean ausgeführt wird, um Ressourcen freizugeben oder aufzuräumen.",
    "xp": 20,
    "tags": [
      "uebung",
      "neue-vorlesung",
      "woche3"
    ]
  },
  {
    "difficulty": 2,
    "type": "multiple",
    "question": "Welche Injektionsarten gibt es in Spring?",
    "options": [
      "Field Injection, Constructor Injection, Setter Injection",
      "Main Injection, Log Injection, Thread Injection",
      "Heap Injection, Stack Injection, Pool Injection",
      "Static Injection, Dynamic Injection, Hybrid Injection"
    ],
    "correct": 0,
    "explanation": "Spring unterstützt drei Arten von Dependency Injection: Field Injection (@Autowired am Feld), Constructor Injection und Setter Injection.",
    "xp": 20,
    "tags": [
      "uebung",
      "neue-vorlesung",
      "woche3"
    ]
  },
  {
    "difficulty": 2,
    "type": "multiple",
    "question": "Was ist ein möglicher Nachteil von Constructor Injection bei sehr vielen Abhängigkeiten?",
    "options": [
      "Konstruktor wird privat und ist nicht mehr aufrufbar",
      "Code wird extrem aufgebläht (viele Parameter, unübersichtlich)",
      "Spring kann dann nicht mehr starten",
      "Es ist nicht mehr möglich, Unit-Tests zu schreiben"
    ],
    "correct": 1,
    "explanation": "Bei zu vielen Abhängigkeiten wird der Konstruktor unübersichtlich mit vielen Parametern. Dies kann ein Hinweis darauf sein, dass die Klasse zu viele Verantwortlichkeiten hat.",
    "xp": 20,
    "tags": [
      "uebung",
      "neue-vorlesung",
      "woche3"
    ]
  },
  {
    "difficulty": 2,
    "type": "multiple",
    "question": "Was passiert, wenn du versuchst, eine Bean zu nutzen, die nie injiziert wurde (z. B. weil Autowiring fehlt)?",
    "options": [
      "Spring kompensiert das automatisch",
      "Das Objekt wird durch Reflection konstruiert",
      "Du landest bei Runtime in einer NullPointerException",
      "Das Projekt baut nicht mehr unter Maven"
    ],
    "correct": 2,
    "explanation": "Ohne Dependency Injection bleibt das Feld null und führt zu einer NullPointerException beim Zugriff.",
    "xp": 20,
    "tags": [
      "uebung",
      "neue-vorlesung",
      "woche3"
    ]
  },
  {
    "difficulty": 1,
    "type": "multiple",
    "question": "Standardmäßig erstellt Spring pro Bean …",
    "options": [
      "unendlich viele Objekte pro Request",
      "genau ein Objekt pro Container (Singleton)",
      "ein Objekt pro Thread immer neu",
      "gar keine Objekte, bis man sie manuell newt"
    ],
    "correct": 1,
    "explanation": "Der Standard-Scope in Spring ist 'singleton', d.h. es gibt genau eine Instanz pro Bean im ApplicationContext.",
    "xp": 10,
    "tags": [
      "uebung",
      "neue-vorlesung",
      "woche3"
    ]
  },
  {
    "difficulty": 2,
    "type": "multiple",
    "question": "Warum sind die meisten Services in Spring zustandslos (stateless)?",
    "options": [
      "Weil Spring keine Felder unterstützt",
      "Weil ein Singleton-Bean sonst unerwartete alte Zustände zwischen Aufrufen durchschleppen würde",
      "Weil Java Verbote für Membervariablen hat",
      "Weil das im HTTP-Standard vorgeschrieben ist"
    ],
    "correct": 1,
    "explanation": "Da Singleton-Beans für alle Anfragen wiederverwendet werden, würden Zustandsvariablen zu unerwarteten Nebenwirkungen zwischen verschiedenen Aufrufen führen.",
    "xp": 20,
    "tags": [
      "uebung",
      "neue-vorlesung",
      "woche3"
    ]
  },
  {
    "difficulty": 1,
    "type": "multiple",
    "question": "Welcher Scope erzeugt standardmäßig genau eine Instanz pro Spring Container?",
    "options": [
      "prototype",
      "session",
      "singleton",
      "request"
    ],
    "correct": 2,
    "explanation": "Der Singleton-Scope ist der Standard in Spring und erstellt genau eine Bean-Instanz pro ApplicationContext.",
    "xp": 10,
    "tags": [
      "uebung",
      "neue-vorlesung",
      "woche3"
    ]
  },
  {
    "difficulty": 2,
    "type": "multiple",
    "question": "Welcher Scope erstellt eine neue Bean-Instanz bei jedem neuen HTTP Request?",
    "options": [
      "singleton",
      "prototype",
      "request",
      "session"
    ],
    "correct": 2,
    "explanation": "Der Request-Scope erstellt für jeden HTTP-Request eine neue Bean-Instanz, die nach dem Request wieder verworfen wird.",
    "xp": 20,
    "tags": [
      "uebung",
      "neue-vorlesung",
      "woche3"
    ]
  },
  {
    "difficulty": 2,
    "type": "multiple",
    "question": "Welcher Scope sorgt dafür, dass eine Bean während einer einzelnen HTTP-Session gleich bleibt (also pro User-Session eine Instanz)?",
    "options": [
      "session",
      "request",
      "prototype",
      "singleton"
    ],
    "correct": 0,
    "explanation": "Der Session-Scope erstellt eine Bean-Instanz pro HTTP-Session, die für die Dauer der Session erhalten bleibt.",
    "xp": 20,
    "tags": [
      "uebung",
      "neue-vorlesung",
      "woche3"
    ]
  },
  {
    "difficulty": 2,
    "type": "multiple",
    "question": "Welcher Scope ist sinnvoll, wenn man pro Instanz einen eigenen Zustand halten will (z. B. einen eigenen Warenkorb), statt immer dieselbe Singleton-Instanz zu teilen?",
    "options": [
      "prototype",
      "singleton",
      "static",
      "compiled"
    ],
    "correct": 0,
    "explanation": "Der Prototype-Scope erstellt bei jeder Anforderung eine neue Bean-Instanz, sodass jede Instanz ihren eigenen Zustand haben kann.",
    "xp": 20,
    "tags": [
      "uebung",
      "neue-vorlesung",
      "woche3"
    ]
  },
  {
    "difficulty": 2,
    "type": "multiple",
    "question": "Was passiert im Fehlerfall, wenn mehrere Beans das gleiche Interface implementieren und Spring ohne Qualifier injizieren soll?",
    "options": [
      "Spring nimmt zufällig die alphabetisch erste Bean",
      "Spring startet trotzdem normal durch",
      "Spring bricht den Start ab und meldet, dass mehrere passende Beans gefunden wurden",
      "Spring merged beide Beans automatisch"
    ],
    "correct": 2,
    "explanation": "Spring kann ohne zusätzliche Informationen (@Qualifier oder @Primary) nicht entscheiden, welche Bean injiziert werden soll, und wirft einen Fehler beim Start.",
    "xp": 20,
    "tags": [
      "uebung",
      "neue-vorlesung",
      "woche3"
    ]
  },
  {
    "difficulty": 2,
    "type": "checkbox",
    "question": "Welche Verbesserungen wurden durch HTTP 1.1 eingeführt? (Mehrfachauswahl)",
    "options": [
      "Wiederverwendung der Verbindung (Keep-Alive)",
      "Mehrere Anfragen über die gleiche Verbindung",
      "Pipelining - mehrere Anfragen hintereinander",
      "Header-Kompression",
      "Binäres Protokoll"
    ],
    "correct": [
      0,
      1,
      2
    ],
    "explanation": "HTTP 1.1 führte wichtige Verbesserungen ein: Connection Keep-Alive ermöglicht die Wiederverwendung von TCP-Verbindungen, mehrere Anfragen können über dieselbe Verbindung gesendet werden und Pipelining erlaubt das Senden mehrerer Anfragen hintereinander ohne auf die Antworten zu warten. Header-Kompression und binäres Protokoll kamen erst mit HTTP/2.",
    "xp": 20,
    "tags": [
      "woche3",
      "vl-offiziell",
      "gemischt"
    ]
  },
  {
    "difficulty": 2,
    "type": "checkbox",
    "question": "Welche Neuerungen bringt HTTP/2 mit sich? (Mehrfachauswahl)",
    "options": [
      "Zusammenfassung mehrerer Requests und Priorisierung",
      "Multiplexing über eine TCP-Verbindung",
      "Header-Kompression (HPACK)",
      "Server Push",
      "Binäres statt textbasiertes Protokoll"
    ],
    "correct": [
      0,
      1,
      2,
      3,
      4
    ],
    "explanation": "HTTP/2 revolutionierte die Web-Kommunikation: Zusammenfassung und Priorisierung mehrerer Requests, Multiplexing (parallele Streams über eine Verbindung), Header-Kompression mit HPACK, Server Push (proaktives Senden von Ressourcen) und ein effizienteres binäres Protokoll statt textbasiert.",
    "xp": 25,
    "tags": [
      "woche3",
      "vl-offiziell",
      "gemischt"
    ]
  },
  {
    "difficulty": 1,
    "type": "multiple",
    "question": "Welcher Doctype ist in HTML5 korrekt?",
    "options": [
      "<!DOCTYPE HTML PUBLIC \"-//W3C//DTD HTML 4.01//EN\">",
      "<!DOCTYPE html>",
      "<!DOCTYPE XHTML 1.0 Strict>",
      "<?doctype html?>"
    ],
    "correct": 1,
    "explanation": "HTML5 vereinfachte die Doctype-Deklaration drastisch auf <!DOCTYPE html> - keine DTD-Referenzierung mehr nötig wie in HTML4.",
    "xp": 10,
    "tags": [
      "woche3"
    ]
  },
  {
    "difficulty": 1,
    "type": "multiple",
    "question": "Welches Element bettet Videos standardkonform in HTML5 ein?",
    "options": [
      "<media>",
      "<object>",
      "<video>",
      "<movie>"
    ],
    "correct": 2,
    "explanation": "HTML5 führte das native <video>-Element ein, das Videos ohne Plugins einbetten kann. Früher war <object> für Plugins wie Flash nötig.",
    "xp": 10,
    "tags": [
      "woche3"
    ]
  },
  {
    "difficulty": 2,
    "type": "multiple",
    "question": "Welches Verfahren ermöglicht plugin-freie Vektorgrafik im Browser (HTML5-Kontext)?",
    "options": [
      "Flash",
      "Silverlight",
      "SVG",
      "ActiveX"
    ],
    "correct": 2,
    "explanation": "SVG (Scalable Vector Graphics) ist der HTML5-Standard für Vektorgrafiken im Browser - ohne Plugins. Flash, Silverlight und ActiveX sind veraltete Plugin-Technologien.",
    "xp": 15,
    "tags": [
      "woche3"
    ]
  },
  {
    "difficulty": 1,
    "type": "multiple",
    "question": "Welche Angabe setzt die Zeichenkodierung im HTML5-Head minimal korrekt?",
    "options": [
      "<meta http-equiv=\"content-type\" content=\"text/html; charset=UTF-8\">",
      "<meta charset=\"UTF-8\">",
      "<charset=UTF-8>",
      "<meta encoding=\"UTF-8\">"
    ],
    "correct": 1,
    "explanation": "HTML5 vereinfachte die Charset-Deklaration auf <meta charset=\"UTF-8\">. Die lange http-equiv-Variante ist HTML4-Syntax.",
    "xp": 10,
    "tags": [
      "woche3"
    ]
  },
  {
    "difficulty": 1,
    "type": "multiple",
    "question": "Laut den Folien: Wer standardisiert HTML?",
    "options": [
      "ISO",
      "IETF",
      "W3C",
      "ECMA"
    ],
    "correct": 2,
    "explanation": "Das W3C (World Wide Web Consortium) ist die Organisation, die HTML standardisiert. IETF kümmert sich um Internet-Protokolle, ISO um allgemeine Standards, ECMA um JavaScript.",
    "xp": 10,
    "tags": [
      "woche3"
    ]
  },
  {
    "difficulty": 2,
    "type": "multiple",
    "question": "Welche Schicht ist in der 3-Tier-Architektur für die Geschäftslogik zuständig?",
    "options": [
      "Präsentation",
      "Verarbeitung",
      "Datenhaltung",
      "Netzwerk"
    ],
    "correct": 1,
    "explanation": "Die Verarbeitungsschicht (auch Anwendungslogik-Schicht) ist für die Geschäftslogik zuständig. Präsentation zeigt die UI, Datenhaltung speichert Daten.",
    "xp": 15,
    "tags": [
      "woche3"
    ]
  },
  {
    "difficulty": 2,
    "type": "checkbox",
    "question": "Welche der folgenden Neuerungen sind Teil von HTML5 (im Vergleich zu HTML4)? (Mehrfachauswahl)",
    "options": [
      "<video>",
      "<canvas>",
      "WebSockets (JavaScript-API)",
      "Web Storage (z.B. localStorage)",
      "<frameset>",
      "<center>"
    ],
    "correct": [
      0,
      1,
      2,
      3
    ],
    "explanation": "HTML5 führte viele neue Features ein: <video> und <audio> für Medien, <canvas> für Grafiken, WebSockets-API für bidirektionale Kommunikation und Web Storage für clientseitige Datenspeicherung. <frameset> und <center> sind deprecated/obsolet.",
    "xp": 20,
    "tags": [
      "woche3"
    ]
  },
  {
    "difficulty": 1,
    "type": "checkbox",
    "question": "Welche Zeilen gehören zum minimalen HTML5-Grundgerüst? (Mehrfachauswahl)",
    "options": [
      "<!DOCTYPE html>",
      "<meta charset=\"UTF-8\">",
      "<title>...</title>",
      "<!DOCTYPE HTML PUBLIC \"-//W3C//DTD HTML 4.01//EN\">",
      "<meta http-equiv=\"Content-Type\" content=\"text/html; charset=UTF-8\">"
    ],
    "correct": [
      0,
      1,
      2
    ],
    "explanation": "Ein minimales HTML5-Dokument benötigt: <!DOCTYPE html>, <meta charset=\"UTF-8\"> und <title>. Die HTML4-Doctype-Deklaration und die alte charset-Syntax sind veraltet.",
    "xp": 15,
    "tags": [
      "woche3"
    ]
  },
  {
    "difficulty": 2,
    "type": "checkbox",
    "question": "Wählen Sie alle Aussagen, die HTML4 korrekt beschreiben. (Mehrfachauswahl)",
    "options": [
      "Native Audio/Video-Elemente sind enthalten",
      "Vektorgrafik ist nur über Plugins üblich",
      "Eine ausführliche DTD-basierte Doctype-Deklaration wird verwendet",
      "Es existiert eine JavaScript-API für WebSockets"
    ],
    "correct": [
      1,
      2
    ],
    "explanation": "HTML4 hatte keine nativen Audio/Video-Elemente (benötigte Plugins wie Flash), Vektorgrafiken erforderten Plugins, die Doctype-Deklaration war lang und DTD-basiert. WebSockets kamen erst mit HTML5.",
    "xp": 20,
    "tags": [
      "woche3"
    ]
  },
  {
    "difficulty": 1,
    "type": "multiple",
    "question": "HTML5 integriert <audio> und <video> als Standard-Elemente.",
    "options": [
      "Richtig",
      "Falsch"
    ],
    "correct": 0,
    "explanation": "Richtig. HTML5 führte native <audio> und <video> Elemente ein, die Medien ohne Plugins abspielen können - ein Hauptunterschied zu HTML4.",
    "xp": 10,
    "tags": [
      "woche3"
    ]
  },
  {
    "difficulty": 1,
    "type": "multiple",
    "question": "In HTML5 muss der Doctype eine konkrete DTD referenzieren.",
    "options": [
      "Richtig",
      "Falsch"
    ],
    "correct": 1,
    "explanation": "Falsch. HTML5 vereinfachte die Doctype-Deklaration auf <!DOCTYPE html> - keine DTD-Referenz mehr nötig wie in HTML4.",
    "xp": 10,
    "tags": [
      "woche3"
    ]
  },
  {
    "difficulty": 1,
    "type": "multiple",
    "question": "HTML5 ermöglicht Zeichnungen über <canvas> ohne zusätzliche Plugins.",
    "options": [
      "Richtig",
      "Falsch"
    ],
    "correct": 0,
    "explanation": "Richtig. Das <canvas>-Element ermöglicht dynamische Grafiken und Animationen per JavaScript - direkt im Browser ohne Plugins.",
    "xp": 10,
    "tags": [
      "woche3"
    ]
  },
  {
    "difficulty": 2,
    "type": "matching",
    "question": "Ordnen Sie Schicht ↔ Aufgabe in der 3-Tier-Architektur zu:",
    "pairs": [
      {
        "left": "Präsentation",
        "right": "Darstellung/Interaktion im Client bzw. serverseitige Präsentation"
      },
      {
        "left": "Verarbeitung",
        "right": "Geschäftslogik/Anwendungslogik"
      },
      {
        "left": "Datenhaltung",
        "right": "Persistenz/Datenbankzugriff"
      }
    ],
    "explanation": "Die 3-Tier-Architektur teilt Webanwendungen in drei Schichten: Präsentation (UI/Darstellung), Verarbeitung (Business Logic), Datenhaltung (Datenbank/Persistenz).",
    "xp": 20,
    "tags": [
      "woche3"
    ]
  },
  {
    "difficulty": 2,
    "type": "matching",
    "question": "Ordnen Sie Komponente ↔ Schicht in der 3-Tier-Architektur zu:",
    "pairs": [
      {
        "left": "Browser / HTML-Seite",
        "right": "Präsentationsschicht"
      },
      {
        "left": "Anwendungsserver",
        "right": "Verarbeitungsschicht"
      },
      {
        "left": "Datenbankserver",
        "right": "Datenhaltungsschicht"
      }
    ],
    "explanation": "Typische Komponenten-Zuordnung: Browser zeigt die Präsentation, Anwendungsserver führt Geschäftslogik aus, Datenbankserver speichert Daten.",
    "xp": 20,
    "tags": [
      "woche3"
    ]
  },
  {
    "difficulty": 2,
    "type": "sort",
    "question": "Bringen Sie den typischen Ablauf einer Web-Anfrage in die richtige Reihenfolge:",
    "items": [
      "Antwort wird über Web-Server an den Browser zurückgegeben",
      "Anwendungsserver führt Geschäftslogik aus",
      "Datenbankserver liefert Daten",
      "Browser stellt Anfrage",
      "Web-Server/Präsentationsschicht nimmt Request an und leitet weiter"
    ],
    "correct": [
      "Browser stellt Anfrage",
      "Web-Server/Präsentationsschicht nimmt Request an und leitet weiter",
      "Anwendungsserver führt Geschäftslogik aus",
      "Datenbankserver liefert Daten",
      "Antwort wird über Web-Server an den Browser zurückgegeben"
    ],
  "explanation": "Typischer Request-Flow: 1) Browser sendet Request, 2) Web-Server empfängt, 3) Anwendungsserver verarbeitet Business Logic, 4) Datenbank liefert Daten, 5) Response zurück an Browser.\n✅ Browser stellt Anfrage → Web-Server/Präsentationsschicht nimmt Request an und leitet weiter → Anwendungsserver führt Geschäftslogik aus → Datenbankserver liefert Daten → Antwort wird über Web-Server an den Browser zurückgegeben",
    "xp": 25,
    "tags": [
      "woche3"
    ]
  },
  {
    "difficulty": 2,
    "type": "fillblank",
    "question": "Ergänzen Sie das HTML5-Grundgerüst: _____ <html> <head> _____ <title>_____ </title> </head> <body> ... </body> </html>",
    "blanks": [
      "<!DOCTYPE html>",
      "<meta charset=\"UTF-8\">",
      "Seitentitel"
    ],
    "explanation": "Ein minimales HTML5-Dokument beginnt mit <!DOCTYPE html>, enthält <meta charset=\"UTF-8\"> im Head für die Zeichenkodierung und einen <title> für den Seitentitel.",
    "xp": 20,
    "tags": [
      "woche3"
    ]
  },
  {
    "difficulty": 2,
    "type": "fillblank",
    "question": "Benennen Sie die drei Schichten der 3-Tier-Architektur (in beliebiger Reihenfolge): _____, _____, _____",
    "blanks": [
      "Präsentation",
      "Verarbeitung",
      "Datenhaltung"
    ],
    "explanation": "Die 3-Tier-Architektur besteht aus drei Schichten: Präsentationsschicht (UI), Verarbeitungsschicht (Business Logic) und Datenhaltungsschicht (Persistenz).",
    "xp": 15,
    "tags": [
      "woche3"
    ]
  },
  {
    "difficulty": 2,
    "type": "multiple",
    "question": "Sie sollen bidirektionale Echtzeit-Kommunikation zwischen Browser und Server bereitstellen (z.B. Live-Chat). Welche Technologie aus dem HTML5-Umfeld ist passend?",
    "options": [
      "Long Polling",
      "WebSockets (JS-API)",
      "Meta-Refresh",
      "iFrame-Streaming"
    ],
    "correct": 1,
    "explanation": "WebSockets ermöglichen echte bidirektionale Echtzeit-Kommunikation über eine persistente Verbindung. Long Polling, Meta-Refresh und iFrames sind Workarounds aus der Pre-HTML5-Ära.",
    "xp": 20,
    "tags": [
      "woche3"
    ]
  },
  {
    "difficulty": 2,
    "type": "multiple",
    "question": "Eine Anwendung soll kleine, persistente Key/Value-Daten im Client speichern – ohne Cookies. Welche HTML5-Funktion ist dafür gedacht?",
    "options": [
      "HTTP-Cache",
      "Web Storage",
      "DNS-Cache",
      "MIME-Sniffing"
    ],
    "correct": 1,
    "explanation": "Web Storage (localStorage/sessionStorage) ermöglicht clientseitige Key-Value-Speicherung mit mehr Kapazität als Cookies und ohne diese bei jedem Request mitzusenden.",
    "xp": 20,
    "tags": [
      "woche3"
    ]
  },
  {
    "difficulty": 2,
    "type": "checkbox",
    "question": "Welche Vorteile bietet Field Injection? (Mehrfachauswahl)",
    "options": [
      "Sehr kurz und unkompliziert zu schreiben",
      "Wenig Boilerplate-Code",
      "Abhängigkeiten sind final und unveränderbar",
      "Ideal für Unit Tests",
      "Einfach zu lesen"
    ],
    "correct": [
      0,
      1,
      4
    ],
    "explanation": "Field Injection ist sehr kurz, unkompliziert und einfach zu lesen - erfordert minimal Code. Aber: Abhängigkeiten sind nicht final und es ist schwerer zu testen (keine Konstruktor-/Setter-Zugriff).",
    "xp": 20,
    "tags": [
      "uebung",
      "gemischt",
      "woche3"
    ]
  },
  {
    "difficulty": 2,
    "type": "checkbox",
    "question": "Welche Nachteile hat Field Injection? (Mehrfachauswahl)",
    "options": [
      "Schwerer zu testen (kein Konstruktor/Setter verfügbar)",
      "Nicht ideal für Clean Code",
      "Nicht ideal für Unit Tests",
      "Abhängigkeiten sind explizit sichtbar",
      "Zu viel Boilerplate-Code"
    ],
    "correct": [
      0,
      1,
      2
    ],
    "explanation": "Field Injection macht Tests schwieriger, da man die Abhängigkeiten nicht über Konstruktor oder Setter setzen kann. Es gilt als weniger 'clean' und ist nicht ideal für Unit Tests. Die Abhängigkeiten sind versteckt (nicht explizit).",
    "xp": 20,
    "tags": [
      "uebung",
      "gemischt",
      "woche3"
    ]
  },
  {
    "difficulty": 2,
    "type": "checkbox",
    "question": "Welche Vorteile bietet Setter Injection? (Mehrfachauswahl)",
    "options": [
      "Gut geeignet für optionale Abhängigkeiten",
      "Unterstützt Lazy Loading",
      "Abhängigkeiten sind unveränderbar (final)",
      "Flexibel - Abhängigkeiten können nach Erstellung geändert werden",
      "Stabilste Injection-Methode"
    ],
    "correct": [
      0,
      1,
      3
    ],
    "explanation": "Setter Injection eignet sich besonders für optionale Abhängigkeiten und Lazy Loading. Die Flexibilität (Abhängigkeiten können geändert werden) ist Vor- und Nachteil zugleich. Abhängigkeiten sind nicht final und es ist weniger stabil als Constructor Injection.",
    "xp": 20,
    "tags": [
      "uebung",
      "gemischt",
      "woche3"
    ]
  },
  {
    "difficulty": 2,
    "type": "checkbox",
    "question": "Welche Nachteile hat Setter Injection? (Mehrfachauswahl)",
    "options": [
      "Abhängigkeiten können nach der Erstellung geändert werden (nicht final)",
      "Weniger stabil als Constructor Injection",
      "Keine Möglichkeit für optionale Abhängigkeiten",
      "Objekt kann in inkonsistentem Zustand existieren",
      "Zu viel Code erforderlich"
    ],
    "correct": [
      0,
      1,
      3
    ],
    "explanation": "Bei Setter Injection sind Abhängigkeiten nicht final (können geändert werden), was weniger stabil ist als Constructor Injection. Das Objekt kann nach Konstruktor-Aufruf in einem inkonsistenten Zustand sein, bis alle Setter aufgerufen wurden.",
    "xp": 20,
    "tags": [
      "uebung",
      "gemischt",
      "woche3"
    ]
  },
  {
    "difficulty": 2,
    "type": "checkbox",
    "question": "Welche Vorteile bietet Constructor Injection? (Mehrfachauswahl)",
    "options": [
      "Abhängigkeiten sind final (können nicht verändert werden)",
      "Testfreundlich - Objekte im Test leicht manuell übergeben",
      "Empfohlene Standard-Methode in modernen Spring-Projekten",
      "Garantiert vollständige Initialisierung",
      "Weniger Code als Field Injection"
    ],
    "correct": [
      0,
      1,
      2,
      3
    ],
    "explanation": "Constructor Injection ist die empfohlene Methode: Abhängigkeiten sind final (Immutability), sehr testfreundlich, garantiert vollständige Initialisierung. Nachteil: Etwas mehr Code als Field Injection, besonders bei vielen Abhängigkeiten.",
    "xp": 25,
    "tags": [
      "uebung",
      "gemischt",
      "woche3"
    ]
  },
  {
    "difficulty": 2,
    "type": "matching",
    "question": "Ordne die Injection-Typen ihrem Hauptvorteil zu:",
    "pairs": [
      {
        "left": "Field Injection",
        "right": "Sehr kurz und unkompliziert"
      },
      {
        "left": "Setter Injection",
        "right": "Gut für optionale Abhängigkeiten"
      },
      {
        "left": "Constructor Injection",
        "right": "Abhängigkeiten sind final und testfreundlich"
      }
    ],
    "explanation": "Jeder Injection-Typ hat seine Stärke: Field (minimaler Code), Setter (Flexibilität für optionale Dependencies), Constructor (Immutability und beste Testbarkeit).",
    "xp": 20,
    "tags": [
      "uebung",
      "gemischt",
      "woche3"
    ]
  },
  {
    "difficulty": 2,
    "type": "matching",
    "question": "Ordne die Injection-Typen ihrem Hauptnachteil zu:",
    "pairs": [
      {
        "left": "Field Injection",
        "right": "Schwer zu testen, nicht ideal für Unit Tests"
      },
      {
        "left": "Setter Injection",
        "right": "Weniger stabil, Abhängigkeiten nicht final"
      },
      {
        "left": "Constructor Injection",
        "right": "Mehr Code bei vielen Abhängigkeiten"
      }
    ],
    "explanation": "Jeder Typ hat Nachteile: Field (Testbarkeit), Setter (Stabilität/Immutability), Constructor (Code-Menge bei vielen Dependencies).",
    "xp": 20,
    "tags": [
      "uebung",
      "gemischt",
      "woche3"
    ]
  },
  {
    "difficulty": 3,
    "type": "multiple",
    "question": "Welche Injection-Methode ist die empfohlene Standard-Methode in modernen Spring-Projekten?",
    "options": [
      "Field Injection",
      "Setter Injection",
      "Constructor Injection",
      "Method Injection"
    ],
    "correct": 2,
    "explanation": "Constructor Injection ist die empfohlene Standard-Methode in modernen Spring-Projekten, da sie Immutability garantiert, testfreundlich ist und vollständige Initialisierung sicherstellt.",
    "xp": 25,
    "tags": [
      "uebung",
      "gemischt",
      "woche3"
    ]
  },
  {
    "difficulty": 2,
    "type": "multiple",
    "question": "Wann ist Setter Injection besonders sinnvoll?",
    "options": [
      "Wenn alle Abhängigkeiten zwingend erforderlich sind",
      "Wenn Abhängigkeiten final sein müssen",
      "Für optionale Abhängigkeiten oder Lazy Loading",
      "Wenn minimaler Code gewünscht ist"
    ],
    "correct": 2,
    "explanation": "Setter Injection eignet sich besonders für optionale Abhängigkeiten und Lazy Loading, da nicht alle Setter aufgerufen werden müssen und sie nach der Konstruktion gesetzt werden können.",
    "xp": 20,
    "tags": [
      "uebung",
      "gemischt",
      "woche3"
    ]
  },
  {
    "difficulty": 3,
    "type": "multiple",
    "question": "Warum ist Field Injection nicht ideal für Unit Tests?",
    "options": [
      "Weil Spring nicht in Unit Tests funktioniert",
      "Weil man die Abhängigkeiten nicht über Konstruktor oder Setter setzen kann",
      "Weil @Autowired in Tests verboten ist",
      "Weil Tests immer Constructor Injection erfordern"
    ],
    "correct": 1,
    "explanation": "Bei Field Injection gibt es keinen Konstruktor oder Setter, über den man Test-Doubles (Mocks/Stubs) einfach injizieren kann. Man ist auf Reflection oder Spring-Test-Context angewiesen.",
    "xp": 30,
    "tags": [
      "uebung",
      "gemischt",
      "woche3"
    ]
  },
  {
    "difficulty": 2,
    "type": "fillblank",
    "question": "Bei Field Injection wird @Autowired direkt am _____ platziert, bei Constructor Injection am _____, bei Setter Injection an der _____-Methode.",
    "blanks": [
      "Feld",
      "Konstruktor",
      "Setter"
    ],
    "explanation": "Die drei Injection-Typen unterscheiden sich in der Position von @Autowired: Field (am Feld), Constructor (am Konstruktor), Setter (an der Setter-Methode).",
    "xp": 15,
    "tags": [
      "uebung",
      "gemischt",
      "woche3"
    ]
  },
  {
    "difficulty": 3,
    "type": "multiple",
    "question": "Was bedeutet 'Abhängigkeiten sind final' bei Constructor Injection?",
    "options": [
      "Die Klasse kann nicht vererbt werden",
      "Die injizierten Abhängigkeiten können nach Konstruktor-Aufruf nicht mehr geändert werden",
      "Der Konstruktor kann nicht überschrieben werden",
      "Die Bean kann nur einmal erstellt werden"
    ],
    "correct": 1,
    "explanation": "Bei Constructor Injection können die Felder als 'final' deklariert werden, was bedeutet, dass sie nach der Zuweisung im Konstruktor nicht mehr geändert werden können (Immutability).",
    "xp": 30,
    "tags": [
      "uebung",
      "gemischt",
      "woche3"
    ]
  },
  {
    "difficulty": 2,
    "type": "sort",
    "question": "Sortiere die Injection-Methoden von 'am wenigsten Code' zu 'am meisten Code':",
    "items": [
      "Constructor Injection (bei vielen Dependencies)",
      "Field Injection",
      "Setter Injection"
    ],
    "correct": [
      "Field Injection",
      "Setter Injection",
      "Constructor Injection (bei vielen Dependencies)"
    ],
  "explanation": "Field Injection erfordert am wenigsten Code (nur @Autowired am Feld), Setter Injection braucht Setter-Methoden, Constructor Injection erfordert den meisten Code bei vielen Abhängigkeiten (alle Parameter im Konstruktor).\n✅ Field Injection → Setter Injection → Constructor Injection (bei vielen Dependencies)",
    "xp": 20,
    "tags": [
      "uebung",
      "gemischt",
      "woche3"
    ]
  },
  {
    "difficulty": 3,
    "type": "checkbox",
    "question": "Welche Aussagen über die Testbarkeit der Injection-Typen sind korrekt? (Mehrfachauswahl)",
    "options": [
      "Constructor Injection ist am testfreundlichsten",
      "Field Injection ist schwer zu testen ohne Spring-Context",
      "Bei Setter Injection kann man Test-Doubles über Setter setzen",
      "Field Injection erfordert Reflection für Tests",
      "Constructor Injection ermöglicht einfaches manuelles Injizieren im Test"
    ],
    "correct": [
      0,
      1,
      2,
      3,
      4
    ],
    "explanation": "Constructor Injection ist am testfreundlichsten (einfaches manuelles Injizieren). Field Injection ist schwer zu testen (braucht Reflection oder Spring-Context). Setter Injection erlaubt setzen über Setter-Methoden.",
    "xp": 35,
    "tags": [
      "uebung",
      "gemischt",
      "woche3"
    ]
  },
  {
    "difficulty": 2,
    "type": "multiple",
    "question": "Bei Constructor Injection mit Spring Boot ist @Autowired am Konstruktor seit Spring 4.3...",
    "options": [
      "zwingend erforderlich",
      "optional, wenn es nur einen Konstruktor gibt",
      "verboten und führt zu Fehlern",
      "nur bei mehreren Konstruktoren optional"
    ],
    "correct": 1,
    "explanation": "Seit Spring 4.3 ist @Autowired am Konstruktor optional, wenn die Klasse nur einen Konstruktor hat. Spring injiziert automatisch. Bei mehreren Konstruktoren muss @Autowired explizit angegeben werden.",
    "xp": 20,
    "tags": [
      "uebung",
      "gemischt",
      "woche3"
    ]
  },
  {
    "difficulty": 3,
    "type": "multiple",
    "question": "Was ist ein Indikator dafür, dass Constructor Injection mit zu vielen Parametern ein Design-Problem aufzeigt?",
    "options": [
      "Die Klasse hat wahrscheinlich zu viele Verantwortlichkeiten (Single Responsibility Principle verletzt)",
      "Spring kann maximal 5 Parameter injizieren",
      "Der Code wird zu langsam",
      "Man sollte immer Field Injection verwenden"
    ],
    "correct": 0,
    "explanation": "Ein Konstruktor mit sehr vielen Parametern deutet oft darauf hin, dass die Klasse zu viele Verantwortlichkeiten hat und gegen das Single Responsibility Principle verstößt. Dies sollte durch Refactoring behoben werden.",
    "xp": 30,
    "tags": [
      "uebung",
      "gemischt",
      "woche3"
    ]
  }
  ,
  {
    "difficulty": 1,
    "type": "multiple",
    "question": "Der WebApplicationContext ist eine spezialisierte Form des ApplicationContext, die speziell für Web-Anwendungen verwendet wird.",
    "options": [
      "Wahr",
      "Falsch"
    ],
    "correct": 0,
    "explanation": "Richtig. Der WebApplicationContext erweitert den ApplicationContext um Web-spezifische Komponenten (z. B. Controller, ViewResolver).",
    "xp": 10,
    "tags": [
      "offiziell",
      "woche3"
    ]
  },
  {
    "difficulty": 1,
    "type": "multiple",
    "question": "Welches Tool wird verwendet, um Beans in Spring zu verwalten?",
    "options": [
      "BeanFactory und ApplicationContext",
      "BeanInjector",
      "BeanManager",
      "SpringService"
    ],
    "correct": 0,
    "explanation": "Spring verwaltet Beans über BeanFactory (Basis) und ApplicationContext (erweitert, praxisüblich).",
    "xp": 10,
    "tags": [
      "offiziell",
      "woche3"
    ]
  },
  {
    "difficulty": 1,
    "type": "multiple",
    "question": "Die Annotation @Repository wird für die Präsentationsebene verwendet.",
    "options": [
      "Wahr",
      "Falsch"
    ],
    "correct": 1,
    "explanation": "Falsch. @Repository gehört zur Persistenzschicht (Datenzugriff).",
    "xp": 10,
    "tags": [
      "offiziell",
      "woche3"
    ]
  },
  {
    "difficulty": 1,
    "type": "multiple",
    "question": "In Spring übernimmt der IoC-Container das Instanziieren von Objekten und deren Abhängigkeiten.",
    "options": [
      "Wahr",
      "Falsch"
    ],
    "correct": 0,
    "explanation": "Richtig. Der Inversion-of-Control-Container erstellt, konfiguriert und verkabelt Beans automatisch.",
    "xp": 10,
    "tags": [
      "offiziell",
      "woche3"
    ]
  },
  {
    "difficulty": 3,
    "type": "multiple",
    "question": "Was ist die Hauptfunktion des DispatcherServlet in einer Spring-Webanwendung?",
    "options": [
      "Es registriert XML-Dateien im ApplicationContext",
      "Es erstellt eine Verbindung zur BeanFactory",
      "Es verwaltet Web-spezifische Beans wie Controller und ViewResolver",
      "Es startet die Datenbank"
    ],
    "correct": 2,
    "explanation": "Das DispatcherServlet ist das zentrale Front-Controller-Servlet in Spring MVC und verteilt Requests an Controller und Views.",
    "xp": 30,
    "tags": [
      "offiziell",
      "woche3"
    ]
  },
  {
    "difficulty": 1,
    "type": "multiple",
    "question": "Mit @Qualifier kann eine spezifische Bean-Implementierung ausgewählt werden.",
    "options": [
      "Wahr",
      "Falsch"
    ],
    "correct": 0,
    "explanation": "Richtig. @Qualifier grenzt bei mehreren Kandidaten die zu injizierende Bean ein.",
    "xp": 10,
    "tags": [
      "offiziell",
      "woche3"
    ]
  },
  {
    "difficulty": 1,
    "type": "multiple",
    "question": "Was ist ein Vorteil des Prototype-Scopes?",
    "options": [
      "Beans können verschiedene Zustände speichern",
      "Beans können nicht injiziert werden",
      "Beans speichern keine Zustände",
      "Beans werden nur einmal erstellt"
    ],
    "correct": 0,
    "explanation": "Prototype-Beans werden bei jeder Anforderung neu erstellt und können so je Instanz eigenen Zustand halten.",
    "xp": 10,
    "tags": [
      "offiziell",
      "woche3"
    ]
  },
  {
    "difficulty": 2,
    "type": "checkbox",
    "question": "Welche Aussagen sind korrekt bezüglich der Bean-Erstellung im IoC-Container?",
    "options": [
      "@Configuration-Klassen können Methoden mit @Bean annotieren",
      "@EnableAutoConfiguration startet automatische Konfiguration",
      "@Repository erzeugt automatisch Entities und Datenbanktabellen",
      "@ComponentScan deaktiviert die Auto-Konfiguration",
      "@Bean ersetzt @Component in allen Fällen"
    ],
    "correct": [
      0,
      1
    ],
    "explanation": "Korrekt sind @Bean-Methoden in @Configuration und die Auto-Konfiguration. Die übrigen Aussagen sind falsch: @Repository erstellt keine Entities/Tabellen, @ComponentScan deaktiviert nichts und @Bean ersetzt @Component nicht generell.",
    "xp": 25,
    "tags": [
      "offiziell",
      "woche3"
    ]
  },
  {
    "difficulty": 1,
    "type": "multiple",
    "question": "Welche Annotation wird verwendet, um Abhängigkeiten zu injizieren?",
    "options": [
      "@InjectObject",
      "@Bean",
      "@Autowired",
      "@Component"
    ],
    "correct": 2,
    "explanation": "@Autowired markiert Punkte, an denen Spring passende Beans injiziert (Feld, Konstruktor, Setter).",
    "xp": 10,
    "tags": [
      "offiziell",
      "woche3"
    ]
  },
  {
    "difficulty": 2,
    "type": "multiple",
    "question": "Welche Methode ist NICHT für Dependency Injection geeignet?",
    "options": [
      "Static Injection",
      "Field Injection",
      "Setter Injection",
      "Constructor Injection"
    ],
    "correct": 0,
    "explanation": "'Static Injection' ist kein gängiges DI-Verfahren in Spring; empfohlen ist i. d. R. Constructor Injection.",
    "xp": 15,
    "tags": [
      "offiziell",
      "woche3"
    ]
  },
  {
    "difficulty": 1,
    "type": "multiple",
    "question": "Das Hollywood-Prinzip (IoC) in Spring bedeutet, dass der Container den Objekten mitteilt, wann und wie sie aufgerufen werden.",
    "options": [
      "Wahr",
      "Falsch"
    ],
    "correct": 0,
    "explanation": "Richtig. 'Don't call us, we'll call you' – der Container steuert den Ablauf und ruft unseren Code auf.",
    "xp": 10,
    "tags": [
      "offiziell",
      "woche3"
    ]
  },
  {
    "difficulty": 1,
    "type": "multiple",
    "question": "Was ist ein Vorteil des Prototype-Scopes? (Variante)",
    "options": [
      "Beans können verschiedene Zustände speichern",
      "Beans sollten immer Singletons sein"
    ],
    "correct": 0,
    "explanation": "Auch hier: Prototype erlaubt je Instanz eigenen Zustand; sinnvoll bei zustandstragenden Objekten.",
    "xp": 10,
    "tags": [
      "offiziell",
      "woche3"
    ]
  },
  {
    "difficulty": 1,
    "type": "multiple",
    "question": "Wie wird eine Methode für die Initialisierung einer Bean gekennzeichnet?",
    "options": [
      "@InitBean",
      "@PreDestroy",
      "@PostConstruct",
      "@PostStart"
    ],
    "correct": 2,
    "explanation": "@PostConstruct markiert eine Methode, die nach der Konstruktion/Injection für Initialisierungscode ausgeführt wird.",
    "xp": 10,
    "tags": [
      "offiziell",
      "woche3"
    ]
  },
  {
    "difficulty": 1,
    "type": "multiple",
    "question": "Dependency Injection führt zu einer stärkeren Kopplung der Komponenten.",
    "options": [
      "Wahr",
      "Falsch"
    ],
    "correct": 1,
    "explanation": "Falsch. DI reduziert die Kopplung, da Abhängigkeiten von außen bereitgestellt werden und austauschbar sind.",
    "xp": 10,
    "tags": [
      "offiziell",
      "woche3"
    ]
  },
  {
    "difficulty": 2,
    "type": "multiple",
    "question": "Welches Problem kann auftreten, wenn mehrere Implementierungen eines Interfaces existieren?",
    "options": [
      "Der IoC-Container weiß nicht, welche Implementierung zu injizieren ist",
      "Der Code wird fehlerhaft kompiliert",
      "Die Anwendung startet nicht",
      "Keine Auswirkungen"
    ],
    "correct": 0,
    "explanation": "Ohne @Qualifier oder @Primary ist unklar, welche Bean injiziert werden soll – es kommt zu einem Startfehler.",
    "xp": 15,
    "tags": [
      "offiziell",
      "woche3"
    ]
  },
  {
    "difficulty": 1,
    "type": "multiple",
    "question": "Die Annotation @Service dient ausschließlich zum Injizieren von Datenbankobjekten.",
    "options": [
      "Wahr",
      "Falsch"
    ],
    "correct": 1,
    "explanation": "Falsch. @Service markiert Service-Klassen; Datenzugriff gehört typischerweise zu @Repository.",
    "xp": 10,
    "tags": [
      "offiziell",
      "woche3"
    ]
  },
  {
    "difficulty": 2,
    "type": "multiple",
    "question": "Was ist der Unterschied zwischen @Configuration und @Component?",
    "options": [
      "@Configuration markiert REST-Controller, @Component Daten-Repositories",
      "@Configuration ist veraltet, @Component ist aktuell",
      "@Configuration enthält @Bean-Methoden für spezifische Beans",
      "Es gibt keinen Unterschied – vollständig identisch"
    ],
    "correct": 2,
    "explanation": "@Configuration-Klassen definieren Beans explizit über @Bean-Methoden; @Component kennzeichnet allgemeine Komponenten für den Component-Scan.",
    "xp": 20,
    "tags": [
      "offiziell",
      "woche3"
    ]
  },
  {
    "difficulty": 1,
    "type": "multiple",
    "question": "Der ApplicationContext baut auf der BeanFactory auf.",
    "options": [
      "Wahr",
      "Falsch"
    ],
    "correct": 0,
    "explanation": "Richtig. ApplicationContext erweitert BeanFactory um u. a. Internationalisierung, Ereignisse, AOP-Integration.",
    "xp": 10,
    "tags": [
      "offiziell",
      "woche3"
    ]
  },
  {
    "difficulty": 1,
    "type": "multiple",
    "question": "Der IoC-Container ist für den Lebenszyklus der Beans verantwortlich.",
    "options": [
      "Wahr",
      "Falsch"
    ],
    "correct": 0,
    "explanation": "Richtig. Der Container steuert Lebenszyklus-Hooks wie @PostConstruct und @PreDestroy und verwaltet Beans insgesamt.",
    "xp": 10,
    "tags": [
      "offiziell",
      "woche3"
    ]
  }
  ,
  {
    "difficulty": 2,
    "type": "matching",
    "question": "Ordnen Sie die Arten des ApplicationContext den passenden Beschreibungen zu:",
    "pairs": [
      { "left": "AnnotationConfigApplicationContext", "right": "verwendet Annotationen, um Komponenten als Beans zu registrieren" },
      { "left": "FileSystemXmlApplicationContext", "right": "Beans werden durch eine XML-Datei registriert, die über eine URL zugänglich ist" },
      { "left": "ClassPathXmlApplicationContext", "right": "verwendet XML-Dateien im Classpath, um Beans zu registrieren" }
    ],
    "explanation": "Die verschiedenen ApplicationContext-Typen unterscheiden sich in der Art, wie und woher sie Beans laden: Annotationen, XML im Dateisystem oder XML im Classpath.",
    "xp": 20,
    "tags": ["offiziell", "woche3"]
  },
  {
    "difficulty": 2,
    "type": "checkbox",
    "question": "Welche Methoden kennzeichnen den Lebenszyklus von Beans? (Mehrfachauswahl)",
    "options": ["@PostConstruct", "@PreDestroy", "@Bean", "@Autowired"],
    "correct": [0,1],
    "explanation": "@PostConstruct und @PreDestroy markieren Methoden, die beim Initialisieren bzw. vor der Zerstörung einer Bean ausgeführt werden.",
    "xp": 15,
    "tags": ["offiziell", "woche3"]
  },
  {
    "difficulty": 2,
    "type": "multiple",
    "question": "Im Spring IoC Container wird die Zerstörung einer Bean unmittelbar nach der Bean-Initialisierung automatisch ausgelöst, es sei denn, die Bean wird explizit durch den Entwickler zur Zerstörung freigegeben.",
    "options": [
      "Wahr",
      "Falsch"
    ],
    "correct": 0,
    "explanation": "Wahr. Beans durchlaufen einen definierten Lebenszyklus: Instanziierung → Dependency Injection → Initialisierung (@PostConstruct) → Nutzung → Zerstörung (@PreDestroy). Die Zerstörung erfolgt beim Container-Shutdown, es sei denn, der Entwickler steuert dies explizit.",
    "xp": 20,
    "tags": ["offiziell", "woche3"]
  },
  {
    "difficulty": 1,
    "type": "multiple",
    "question": "Der ApplicationContext erweitert nicht die Funktionalität der BeanFactory.",
    "options": [
      "Wahr",
      "Falsch"
    ],
    "correct": 1,
    "explanation": "Falsch. Der ApplicationContext erweitert die BeanFactory um zusätzliche Enterprise-Features wie Internationalisierung, Event-Handling, AOP-Integration und deklarative Mechanismen.",
    "xp": 10,
    "tags": ["offiziell", "woche3"]
  },
  {
    "difficulty": 1,
    "type": "multiple",
    "question": "Der Model-Teil im MVC hält die Daten der Anwendung, die View generiert die Darstellung, der Controller verarbeitet eingehende HTTP-Requests.",
    "options": ["Wahr", "Falsch"],
    "correct": 0,
    "explanation": "Wahr. MVC trennt die Anwendung in Model (Daten/Geschäftslogik), View (Darstellung) und Controller (Request-Verarbeitung und Steuerung).",
    "xp": 10,
    "tags": ["uebung", "gemischt", "woche4"]
  },
  {
    "difficulty": 2,
    "type": "multiple",
    "question": "Welche Rolle leitet Model-Objekte an die View weiter?",
    "options": ["Model", "View", "Controller", "Template Engine"],
    "correct": 2,
    "explanation": "Der Controller verarbeitet Requests, füllt das Model mit Daten und gibt es an die View weiter zur Darstellung.",
    "xp": 15,
    "tags": ["uebung", "gemischt", "woche4"]
  },
  {
    "difficulty": 1,
    "type": "multiple",
    "question": "Ziel des MVC-Patterns ist eine möglichst große Unabhängigkeit der Softwarekomponenten.",
    "options": ["Wahr", "Falsch"],
    "correct": 0,
    "explanation": "Wahr. MVC trennt Darstellung, Logik und Daten, um die Komponenten voneinander unabhängig zu machen und die Wartbarkeit zu erhöhen.",
    "xp": 10,
    "tags": ["uebung", "gemischt", "woche4"]
  },
  {
    "difficulty": 1,
    "type": "multiple",
    "question": "In der Beispielstruktur liegen Controller-Klassen in welchem Ordner?",
    "options": ["/service", "/controller", "/repository", "/config"],
    "correct": 1,
    "explanation": "Controller-Klassen befinden sich konventionsgemäß im /controller-Ordner der Package-Struktur.",
    "xp": 10,
    "tags": ["uebung", "gemischt", "woche4"]
  },
  {
    "difficulty": 2,
    "type": "multiple",
    "question": "Welche Aussage zu Entity-/Model-Klassen trifft zu?",
    "options": [
      "Müssen ein Spring-Interface implementieren",
      "Müssen von einer Spring-Basisklasse erben",
      "Benötigen nur einen Default-Konstruktor",
      "Dürfen keine Felder besitzen"
    ],
    "correct": 2,
    "explanation": "Entity-/Model-Klassen benötigen einen parameterlosen Default-Konstruktor für die Instanziierung durch Frameworks. Sie müssen keine Spring-spezifischen Interfaces implementieren.",
    "xp": 15,
    "tags": ["uebung", "gemischt", "woche4"]
  },
  {
    "difficulty": 1,
    "type": "multiple",
    "question": "Das Beispiel-Repository erweitert lediglich eine HashMap als Speicher.",
    "options": ["Wahr", "Falsch"],
    "correct": 0,
    "explanation": "Wahr. In einfachen Beispielen wird oft eine HashMap als In-Memory-Speicher verwendet, bevor eine echte Datenbank angebunden wird.",
    "xp": 10,
    "tags": ["uebung", "gemischt", "woche4"]
  },
  {
    "difficulty": 2,
    "type": "multiple",
    "question": "Wofür steht der Ordner /config im Beispielprojekt?",
    "options": [
      "Thymeleaf-Vorlagen",
      "Initiale Datenkonfiguration (InitData)",
      "Statische Ressourcen",
      "Datenbankmigrationen"
    ],
    "correct": 1,
    "explanation": "Der /config-Ordner enthält Konfigurationsklassen wie InitData für die initiale Dateninitialisierung beim Anwendungsstart.",
    "xp": 15,
    "tags": ["uebung", "gemischt", "woche4"]
  },
  {
    "difficulty": 1,
    "type": "multiple",
    "question": "Welche Annotation macht eine Klasse zum Web-Controller?",
    "options": ["@Service", "@Controller", "@Repository", "@RestClient"],
    "correct": 1,
    "explanation": "@Controller markiert eine Klasse als Spring MVC Controller, der HTTP-Requests verarbeitet und Views zurückgibt.",
    "xp": 10,
    "tags": ["uebung", "gemischt", "woche4"]
  },
  {
    "difficulty": 2,
    "type": "multiple",
    "question": "Welche Mapping-Annotation wird im Beispiel für GET auf '/add' verwendet?",
    "options": [
      "@Get",
      "@GetMapping(\"/add\")",
      "@RequestMapping(value={\"/add\"}, method=GET)",
      "@Route(\"/add\")"
    ],
    "correct": 2,
    "explanation": "@RequestMapping mit method=GET ist die klassische Form. @GetMapping ist eine kürzere Alternative für GET-Requests.",
    "xp": 15,
    "tags": ["uebung", "gemischt", "woche4"]
  },
  {
    "difficulty": 2,
    "type": "multiple",
    "question": "Der HandlerMapping bestimmt anhand der URL den passenden Controller und die Methode.",
    "options": ["Wahr", "Falsch"],
    "correct": 0,
    "explanation": "Wahr. Das HandlerMapping ist für das URL-Routing zuständig und findet die passende Controller-Methode für einen Request.",
    "xp": 15,
    "tags": ["uebung", "gemischt", "woche4"]
  },
  {
    "difficulty": 2,
    "type": "multiple",
    "question": "Welche Klasse verarbeitet eingehende Requests zentral?",
    "options": ["ViewResolver", "DispatcherServlet", "ResourceHandler", "ModelFactory"],
    "correct": 1,
    "explanation": "Das DispatcherServlet ist das zentrale Front-Controller-Servlet, das alle Requests empfängt und an die passenden Handler weiterleitet.",
    "xp": 15,
    "tags": ["uebung", "gemischt", "woche4"]
  },
  {
    "difficulty": 2,
    "type": "checkbox",
    "question": "Welche Schritte gehören zum Ablauf einer Request-Verarbeitung in Spring MVC? (Mehrfachauswahl)",
    "options": [
      "DispatcherServlet empfängt Request",
      "HandlerMapping findet Controller/Methode",
      "ViewResolver ermittelt Ressource",
      "Model-Daten werden in Template integriert"
    ],
    "correct": [0, 1, 2, 3],
    "explanation": "Alle vier Schritte sind Teil des Spring MVC Request-Flows: DispatcherServlet → HandlerMapping → Controller → ViewResolver → View-Rendering.",
    "xp": 20,
    "tags": ["uebung", "gemischt", "woche4"]
  },
  {
    "difficulty": 2,
    "type": "multiple",
    "question": "Welche Parameterquelle nutzt @RequestParam?",
    "options": ["Header", "Path Variable", "Query-String/Form", "Cookie"],
    "correct": 2,
    "explanation": "@RequestParam bindet Parameter aus dem Query-String (URL ?key=value) oder aus Formulardaten.",
    "xp": 15,
    "tags": ["uebung", "gemischt", "woche4"]
  },
  {
    "difficulty": 2,
    "type": "matching",
    "question": "Ordne URL-Bestandteile zu:",
    "pairs": [
      {"left": "Host", "right": "example.com"},
      {"left": "Pfad", "right": "/path"},
      {"left": "Query String", "right": "Teil nach '?'"},
      {"left": "Parameter/Wert", "right": "name=value"},
      {"left": "Mehrere Parameter", "right": "mit '&' verbinden"}
    ],
    "explanation": "URL-Struktur: http://host/pfad?param1=wert1&param2=wert2",
    "xp": 20,
    "tags": ["uebung", "gemischt", "woche4"]
  },
  {
    "difficulty": 1,
    "type": "multiple",
    "question": "Im Controller kann per model.addAttribute(...) ein Objekt für die View bereitgestellt werden.",
    "options": ["Wahr", "Falsch"],
    "correct": 0,
    "explanation": "Wahr. Mit model.addAttribute(key, value) fügt man Daten zum Model hinzu, die dann in der View verfügbar sind.",
    "xp": 10,
    "tags": ["uebung", "gemischt", "woche4"]
  },
  {
    "difficulty": 2,
    "type": "multiple",
    "question": "Was liefert die Beispielmethode add(...) zurück?",
    "options": [
      "Ein JSON-Objekt",
      "Den Namen einer View (z. B. 'add.html') als String",
      "Eine ResponseEntity",
      "Eine Model-Instanz"
    ],
    "correct": 1,
    "explanation": "Controller-Methoden geben typischerweise einen View-Namen als String zurück, den der ViewResolver zur entsprechenden Template-Datei auflöst.",
    "xp": 15,
    "tags": ["uebung", "gemischt", "woche4"]
  },
  {
    "difficulty": 1,
    "type": "multiple",
    "question": "Thymeleaf verarbeitet Model-Daten zur Laufzeit im Template.",
    "options": ["Wahr", "Falsch"],
    "correct": 0,
    "explanation": "Wahr. Thymeleaf ist eine serverseitige Template Engine, die zur Laufzeit Model-Daten in HTML einbettet.",
    "xp": 10,
    "tags": ["uebung", "gemischt", "woche4"]
  },
  {
    "difficulty": 2,
    "type": "multiple",
    "question": "Welches Namespace-Attribut aktiviert Thymeleaf-Attribute in HTML?",
    "options": [
      "xmlns:tl",
      "xmlns:th=\"http://www.thymeleaf.org\"",
      "xmlns:spring",
      "th:xmlns"
    ],
    "correct": 1,
    "explanation": "xmlns:th=\"http://www.thymeleaf.org\" im <html>-Tag aktiviert Thymeleaf-Syntax wie th:text, th:if etc.",
    "xp": 15,
    "tags": ["uebung", "gemischt", "woche4"]
  },
  {
    "difficulty": 1,
    "type": "multiple",
    "question": "Wo liegen dynamische HTML-Templates?",
    "options": [
      "src/main/resources/templates",
      "src/main/webapp",
      "src/main/resources/static",
      "templates/ außerhalb von resources"
    ],
    "correct": 0,
    "explanation": "Templates liegen standardmäßig in src/main/resources/templates und werden von Thymeleaf verarbeitet.",
    "xp": 10,
    "tags": ["uebung", "gemischt", "woche4"]
  },
  {
    "difficulty": 1,
    "type": "multiple",
    "question": "Wo liegen statische Ressourcen (CSS, Bilder, JS)?",
    "options": [
      "/public",
      "src/main/resources/static",
      "/templates/static",
      "/assets/root"
    ],
    "correct": 1,
    "explanation": "Statische Ressourcen wie CSS, JavaScript und Bilder liegen in src/main/resources/static.",
    "xp": 10,
    "tags": ["uebung", "gemischt", "woche4"]
  },
  {
    "difficulty": 1,
    "type": "multiple",
    "question": "Alle Ressourcen, die Spring Boot finden soll, müssen unterhalb von /resources liegen.",
    "options": ["Wahr", "Falsch"],
    "correct": 0,
    "explanation": "Wahr. Spring Boot sucht Ressourcen (Templates, statische Dateien, Properties) in src/main/resources und Unterordnern.",
    "xp": 10,
    "tags": ["uebung", "gemischt", "woche4"]
  },
  {
    "difficulty": 1,
    "type": "multiple",
    "question": "Welcher Thymeleaf-Ausdruck setzt Textinhalt aus dem Model?",
    "options": ["th:if", "th:text", "th:src", "th:class"],
    "correct": 1,
    "explanation": "th:text=\"${variable}\" setzt den Textinhalt eines HTML-Elements mit einem Wert aus dem Model.",
    "xp": 10,
    "tags": ["uebung", "gemischt", "woche4"]
  },
  {
    "difficulty": 1,
    "type": "multiple",
    "question": "Läuft eine Standard‑Spring‑Boot‑App ohne Portkonfiguration unter http://localhost:8080/?",
    "options": ["Wahr", "Falsch"],
    "correct": 0,
    "explanation": "Wahr. Spring Boot nutzt standardmäßig Port 8080, sofern kein anderer Port konfiguriert ist.",
    "xp": 10,
    "tags": ["uebung", "gemischt", "woche4"]
  },
  {
    "difficulty": 1,
    "type": "multiple",
    "question": "Welche HTTP‑Methode wird typischerweise zum Abrufen von HTML‑Seiten verwendet?",
    "options": ["POST", "GET", "PUT", "PATCH"],
    "correct": 1,
    "explanation": "GET dient dem Abruf von Ressourcen wie HTML‑Seiten, ohne deren Zustand serverseitig zu verändern.",
    "xp": 10,
    "tags": ["uebung", "gemischt", "woche4"]
  },
  {
    "difficulty": 2,
    "type": "checkbox",
    "question": "Welche Prüfungen sind sinnvoll, um eine HTML‑Antwort zu validieren? (Mehrfachauswahl)",
    "options": [
      "HTTP-Response-Status",
      "Response-Inhalt vs. list.html",
      "Cookies mit CSRF-Token",
      "Request-Headers (User-Agent)"
    ],
    "correct": [0, 1],
    "explanation": "Wichtige Prüfungen sind u. a. der Status‑Code und der Response‑Body im Vergleich zur erwarteten Vorlage (Template).",
    "xp": 20,
    "tags": ["uebung", "gemischt", "woche4"]
  },
  {
    "difficulty": 2,
    "type": "multiple",
    "question": "Welcher Pfad fügt im Beispiel einen Nutzer per GET hinzu (inkl. URL-Encoding)?",
    "options": [
      "/add?firstName=John&lastName=Doe&email=jd@gmx.de&password=abc",
      "/add?firstName=John&lastName=Doe&email=jd%40gmx.de&password=abc",
      "/add/John/Doe",
      "/user/add?json"
    ],
    "correct": 1,
    "explanation": "Das @-Zeichen wird URL-encoded als %40. Die korrekte URL ist /add?firstName=John&lastName=Doe&email=jd%40gmx.de&password=abc",
    "xp": 20,
    "tags": ["uebung", "gemischt", "woche4"]
  },
  {
    "difficulty": 1,
    "type": "multiple",
    "question": "Ein Sequenzdiagramm stellt den Nachrichtenfluss zwischen Client, Server und Komponenten dar.",
    "options": ["Wahr", "Falsch"],
    "correct": 0,
    "explanation": "Wahr. Sequenzdiagramme visualisieren den zeitlichen Ablauf von Nachrichten/Methodenaufrufen zwischen beteiligten Instanzen.",
    "xp": 10,
    "tags": ["uebung", "gemischt", "woche4"]
  },
  {
    "difficulty": 2,
    "type": "multiple",
    "question": "Was passiert bei /add?firstName=John&lastName=Doe (fehlende Parameter)?",
    "options": [
      "Success-Seite",
      "Silent-Ignore",
      "Exception, die zentral behandelt werden kann",
      "301 Redirect"
    ],
    "correct": 2,
    "explanation": "Fehlende @RequestParam-Parameter führen zu einer MissingServletRequestParameterException, die zentral behandelt werden kann.",
    "xp": 20,
    "tags": ["uebung", "gemischt", "woche4"]
  },
  {
    "difficulty": 2,
    "type": "multiple",
    "question": "@ControllerAdvice ermöglicht eine globale Exception-Behandlung für alle Controller.",
    "options": ["Wahr", "Falsch"],
    "correct": 0,
    "explanation": "Wahr. @ControllerAdvice definiert eine Klasse, die Exceptions für alle Controller zentral behandelt.",
    "xp": 15,
    "tags": ["uebung", "gemischt", "woche4"]
  },
  {
    "difficulty": 2,
    "type": "multiple",
    "question": "Welche Exception reicht die Methode add(...) bei fehlenden Parametern weiter?",
    "options": [
      "MethodArgumentNotValidException",
      "MissingServletRequestParameterException",
      "HttpMessageNotReadableException",
      "IllegalArgumentException"
    ],
    "correct": 1,
    "explanation": "MissingServletRequestParameterException wird geworfen, wenn ein erforderlicher @RequestParam fehlt.",
    "xp": 20,
    "tags": ["uebung", "gemischt", "woche4"]
  },
  {
    "difficulty": 2,
    "type": "multiple",
    "question": "Welche Annotation markiert in einem Advice die Methode, die eine bestimmte Exception verarbeitet?",
    "options": ["@Handle", "@ExceptionHandler", "@Catch", "@OnError"],
    "correct": 1,
    "explanation": "@ExceptionHandler(ExceptionType.class) markiert Methoden in @ControllerAdvice zur Exception-Behandlung.",
    "xp": 15,
    "tags": ["uebung", "gemischt", "woche4"]
  },
  {
    "difficulty": 2,
    "type": "multiple",
    "question": "Welches Rückgabeobjekt wird im Beispiel zur Fehlerdarstellung verwendet?",
    "options": [
      "ResponseEntity<String>",
      "ModelAndView",
      "String (View-Name)",
      "Optional<Model>"
    ],
    "correct": 1,
    "explanation": "ModelAndView kombiniert View-Name und Model-Daten und ist ideal für Exception-Handler.",
    "xp": 20,
    "tags": ["uebung", "gemischt", "woche4"]
  },
  {
    "difficulty": 2,
    "type": "multiple",
    "question": "Welche View-Datei rendert die zentrale Fehlerausgabe im Beispiel?",
    "options": ["error.html", "support.html", "exception.html", "fault.html"],
    "correct": 1,
    "explanation": "Die support.html-Datei wird im Beispiel für die nutzerfreundliche Fehlerdarstellung verwendet.",
    "xp": 15,
    "tags": ["uebung", "gemischt", "woche4"]
  },
  {
    "difficulty": 2,
    "type": "multiple",
    "question": "Welche Exception tritt auf, wenn ein Request‑Parameter nicht in den erwarteten Typ konvertiert werden kann?",
    "options": [
      "MethodArgumentTypeMismatchException",
      "MissingServletRequestParameterException",
      "HttpMessageNotReadableException",
      "ConstraintViolationException"
    ],
    "correct": 0,
    "explanation": "Fehltypisierte Parameter (z. B. 'id=abc' statt Zahl) führen zu MethodArgumentTypeMismatchException.",
    "xp": 15,
    "tags": ["uebung", "gemischt", "woche4"]
  },
  {
    "difficulty": 2,
    "type": "matching",
    "question": "Ordne Ordner → Zweck zu:",
    "pairs": [
      {"left": "controller", "right": "Nutzerschnittstelle/Controller"},
      {"left": "model", "right": "Entity-Klassen"},
      {"left": "repository", "right": "Zugriff auf persistente Daten"},
      {"left": "service", "right": "Dienstlogik"},
      {"left": "config", "right": "Initiale Datenkonfiguration"}
    ],
    "explanation": "Standard Spring Boot Package-Struktur trennt Verantwortlichkeiten nach Schichten.",
    "xp": 20,
    "tags": ["uebung", "gemischt", "woche4"]
  },
  {
    "difficulty": 2,
    "type": "checkbox",
    "question": "Welche Vorteile bieten MVC/Schichten? (Mehrfachauswahl)",
    "options": [
      "Trennung von Darstellung und Logik",
      "Leichtere Änderbarkeit/Wartbarkeit",
      "Zwang zu Monolithen",
      "Bessere Testbarkeit"
    ],
    "correct": [0, 1, 3],
    "explanation": "MVC trennt Concerns, verbessert Wartbarkeit und Testbarkeit; es erzwingt keine monolithische Architektur.",
    "xp": 20,
    "tags": ["uebung", "gemischt", "woche4"]
  },
  {
    "difficulty": 1,
    "type": "multiple",
    "question": "Mit welcher Thymeleaf‑Anweisung iterierst du über eine Liste im Model?",
    "options": ["th:if", "th:each", "th:text", "th:src"],
    "correct": 1,
    "explanation": "th:each durchläuft Sammlungen und rendert für jedes Element ein Fragment.",
    "xp": 10,
    "tags": ["uebung", "gemischt", "woche4"]
  },
  {
    "difficulty": 1,
    "type": "multiple",
    "question": "Thymeleaf kann Variablen, Befehle und Fragmente in Templates verwenden.",
    "options": ["Wahr", "Falsch"],
    "correct": 0,
    "explanation": "Wahr. Thymeleaf unterstützt Variablen (${...}), Befehle (th:if, th:each) und wiederverwendbare Fragmente (th:fragment).",
    "xp": 10,
    "tags": ["uebung", "gemischt", "woche4"]
  },
  {
    "difficulty": 3,
    "type": "matching",
    "question": "Ordne Akteur → Aufgabe im MVC-Requestflow zu:",
    "pairs": [
      {"left": "DispatcherServlet", "right": "empfängt Request & orchestriert"},
      {"left": "HandlerMapping", "right": "ermittelt Ziel-Controller"},
      {"left": "Controller", "right": "verarbeitet & füllt Model"},
      {"left": "ViewResolver", "right": "findet Template"},
      {"left": "View", "right": "rendert HTML mit Model"}
    ],
    "explanation": "Der Spring MVC Request-Flow durchläuft diese Komponenten in dieser Reihenfolge.",
    "xp": 30,
    "tags": ["uebung", "gemischt", "woche4"]
  },
  {
    "difficulty": 1,
    "type": "multiple",
    "question": "Wo muss sich eine repräsentierbare Ressource befinden, damit Spring Boot sie findet?",
    "options": [
      "Irgendwo im Projekt",
      "/opt/resources",
      "Unterhalb von src/main/resources",
      "Nur im Klassenpfad META-INF/resources"
    ],
    "correct": 2,
    "explanation": "Spring Boot sucht Ressourcen standardmäßig in src/main/resources und dessen Unterordnern (static, templates, etc.).",
    "xp": 10,
    "tags": ["uebung", "gemischt", "woche4"]
  }
  ,
  {
    "difficulty": 2,
    "type": "checkbox",
    "question": "Welche Aussagen unterscheiden HTML5 von HTML4? (Mehrfachauswahl)",
    "options": [
      "Einfachere Doctype-Deklaration: <!DOCTYPE html>",
      "Semantische Elemente wie <header>, <nav>, <section>, <footer>",
      "Native Medien-Elemente (<audio>, <video>) ohne Plugins",
      "Framesets sind die empfohlene Layout-Technik"
    ],
    "correct": [0, 1, 2],
    "explanation": "HTML5 vereinfacht den Doctype, führt neue semantische Elemente ein und bringt native Audio-/Video-Tags; Framesets gelten als veraltet.",
    "xp": 20,
  "tags": ["woche4", "gemischt", "vl-offiziell"]
  },
  {
    "difficulty": 2,
    "type": "matching",
    "question": "Ordne typische HTML5-Boilerplate-Elemente ihrem Zweck zu:",
    "pairs": [
      {"left": "<!DOCTYPE html>", "right": "Aktiviert Standards-Modus/HTML5"},
      {"left": "<meta charset=\"utf-8\">", "right": "Zeichensatz festlegen"},
      {"left": "<meta name=\"viewport\" content=\"width=device-width, initial-scale=1\">", "right": "Responsive Skalierung auf Mobilgeräten"},
      {"left": "<link rel=\"stylesheet\" href=\"style.css\">", "right": "Externe CSS-Datei einbinden"},
      {"left": "<script defer src=\"app.js\"></script>", "right": "JavaScript nicht-blockierend laden"}
    ],
    "explanation": "Diese Elemente bilden die Basis einer modernen HTML5-Seite für korrekte Darstellung und Performance.",
    "xp": 20,
  "tags": ["woche4", "gemischt", "vl-offiziell"]
  },
  {
    "difficulty": 2,
    "type": "matching",
    "question": "Ordne Sitzungs-/Zustands-Management-Methoden ihrem Merkmal zu:",
    "pairs": [
      {"left": "Cookies", "right": "ID clientseitig gespeichert, an jede Anfrage gesendet"},
      {"left": "URL-Rewriting", "right": "Session-ID in der URL (z. B. ;jsessionid=...)"},
      {"left": "Hidden Fields", "right": "Daten nur bei Formular-Submit gesendet"},
      {"left": "HttpSession", "right": "Serverseitiger Zustand, via Cookie/URL referenziert"},
      {"left": "Local/SessionStorage", "right": "Persistenz im Browser, nicht automatisch an Server gesendet"}
    ],
    "explanation": "Web-Apps kombinieren häufig serverseitige Sessions mit clientseitigen Speichern und Cookies zur Wiedererkennung.",
    "xp": 25,
  "tags": ["woche4", "gemischt", "vl-offiziell"]
  },
  {
    "difficulty": 1,
    "type": "multiple",
    "question": "Wer pflegt den aktuellen HTML-Standard (Living Standard)?",
    "options": ["W3C", "WHATWG", "ECMA", "ISO"],
    "correct": 1,
    "explanation": "Die WHATWG pflegt das HTML Living Standard. Das W3C hat frühere HTML-Versionen standardisiert.",
    "xp": 15,
  "tags": ["woche4", "gemischt", "vl-offiziell"]
  },
  {
    "difficulty": 1,
    "type": "matching",
    "question": "Wie kann CSS eingebunden werden? Ordne Methode → Beispiel zu:",
    "pairs": [
      {"left": "Inline-Stile", "right": "<h1 style=\"color:red\">..."},
      {"left": "Interne Styles", "right": "<style> h1{color:red} </style>"},
      {"left": "Externe Datei", "right": "<link rel=\"stylesheet\" href=\"style.css\">"},
      {"left": "@import", "right": "@import url('theme.css');"}
    ],
    "explanation": "CSS kann inline, im <style>-Block, per <link> oder mit @import geladen werden.",
    "xp": 15,
  "tags": ["woche4", "gemischt", "vl-offiziell"]
  },
  {
    "difficulty": 2,
    "type": "matching",
    "question": "Ordne Selektor-Typ → Beispiel zu:",
    "pairs": [
      {"left": "Typselektor", "right": "p"},
      {"left": "Klassenselektor", "right": ".btn"},
      {"left": "ID-Selektor", "right": "#main"},
      {"left": "Attributselektor", "right": "input[type=\"text\"]"},
      {"left": "Pseudoklasse", "right": "a:hover"}
    ],
    "explanation": "Die wichtigsten CSS-Selektoren adressieren Elemente nach Typ, Klasse, ID, Attributen oder Zustand.",
    "xp": 20,
  "tags": ["woche4", "gemischt", "vl-offiziell"]
  },
  {
    "difficulty": 1,
    "type": "matching",
    "question": "Ordne Box-Model-Schicht → Beschreibung zu:",
    "pairs": [
      {"left": "content", "right": "Eigentlicher Inhalt (z. B. Text, Bild)"},
      {"left": "padding", "right": "Innenabstand zwischen Inhalt und Rahmen"},
      {"left": "border", "right": "Rahmenlinie um das Element"},
      {"left": "margin", "right": "Außenabstand zum nächsten Element"}
    ],
    "explanation": "Das CSS-Box-Modell besteht aus content, padding, border und margin in dieser Reihenfolge von innen nach außen.",
    "xp": 15,
  "tags": ["woche4", "gemischt", "vl-offiziell"]
  },
  {
    "difficulty": 2,
    "type": "checkbox",
    "question": "Warum wird JavaScript überwiegend clientseitig eingesetzt? (Mehrfachauswahl)",
    "options": [
      "Interaktive UI ohne Server-Roundtrip",
      "Direkter Zugriff auf DOM und Browser-Events",
      "Weil Browser kein HTML rendern können",
      "Geringere Latenz und unmittelbares Feedback"
    ],
    "correct": [0, 1, 3],
    "explanation": "JS reagiert im Browser direkt auf Nutzeraktionen, manipuliert das DOM und liefert schnelles Feedback; HTML wird natürlich weiterhin nativ gerendert.",
    "xp": 20,
  "tags": ["woche4", "gemischt", "vl-offiziell"]
  },
  {
    "difficulty": 2,
    "type": "checkbox",
    "question": "Typische Anwendungsfälle für JavaScript im Browser sind … (Mehrfachauswahl)",
    "options": [
      "Formularvalidierung im Client",
      "DOM- und Style-Manipulation",
      "SPA-Routing und Navigation",
      "SSL-Verschlüsselung auf Transportebene",
      "Asynchrone Requests per fetch/AJAX"
    ],
    "correct": [0, 1, 2, 4],
    "explanation": "JavaScript validiert Formulare, steuert SPAs, manipuliert DOM/CSS und ruft Daten asynchron ab; SSL erledigt die Transportebene (TLS), nicht JS.",
    "xp": 25,
  "tags": ["woche4", "gemischt", "vl-offiziell"]
  },
  {
    "difficulty": 1,
    "type": "multiple",
    "question": "Was beschreibt das Document Object Model (DOM) korrekt?",
    "options": [
      "Baumstruktur aus Knoten, die ein Dokument repräsentiert",
      "JSON-Format zur Browserkonfiguration",
      "Netzwerkprotokoll zur Datenübertragung",
      "CSS-Spezifikation für Layout"
    ],
    "correct": 0,
    "explanation": "Das DOM bildet HTML/XML als Baum von Knoten ab, den Skripte lesen und verändern können.",
    "xp": 15,
  "tags": ["woche4", "gemischt", "vl-offiziell"]
  }
  ,
  {
    "difficulty": 1,
    "type": "multiple",
    "question": "Das MVC-Pattern fördert lose Kopplung zwischen Komponenten.",
    "options": ["Falsch", "Wahr"],
    "correct": 1,
    "explanation": "Durch Trennung von Model, View und Controller entsteht geringere Abhängigkeit zwischen Schichten.",
    "xp": 10,
    "tags": ["offiziell", "woche4"]
  },
  {
    "difficulty": 1,
    "type": "multiple",
    "question": "Welche Annotation wird für HTTP Request Mappings verwendet?",
    "options": ["@ControllerAdvice", "@RequestMapping", "@Service", "@ModelAttribute"],
    "correct": 1,
    "explanation": "@RequestMapping (bzw. @GetMapping/@PostMapping etc.) verknüpft URL-Pfade mit Controller-Methoden.",
    "xp": 10,
    "tags": ["offiziell", "woche4"]
  },
  {
    "difficulty": 2,
    "type": "multiple",
    "question": "@ExceptionHandler in Kombination mit @ControllerAdvice ermöglicht zentrale Behandlung einer Exception.",
    "options": ["Falsch", "Wahr"],
    "correct": 1,
    "explanation": "@ControllerAdvice + @ExceptionHandler erlaubt globale Fehlerbehandlung für definierte Exception-Typen.",
    "xp": 15,
    "tags": ["offiziell", "woche4"]
  },
  {
    "difficulty": 2,
    "type": "multiple",
    "question": "Was passiert, wenn eine HTTP-Anfrage mit fehlenden Parametern gesendet wird?",
    "options": [
      "Anfrage wird normal verarbeitet",
      "MissingServletRequestParameterException wird ausgelöst",
      "Server ignoriert die Anfrage",
      "Controller erstellt Parameter automatisch"
    ],
    "correct": 1,
    "explanation": "✅ Richtig: MissingServletRequestParameterException – Fehlende Pflicht-Parameter führen zu dieser Exception.",
    "xp": 15,
    "tags": ["offiziell", "woche4"]
  },
  {
    "difficulty": 1,
    "type": "multiple",
    "question": "Die View leitet Model-Daten an den Controller weiter, um eine dynamische Anzeige zu generieren.",
    "options": ["Falsch", "Wahr"],
    "correct": 0,
    "explanation": "✅ Richtig: Falsch – Im MVC-Pattern stellt der Controller dem Model Daten bereit und übergibt diese an die View zum Rendern, nicht umgekehrt.",
    "xp": 10,
    "tags": ["offiziell", "woche4"]
  },
  {
    "difficulty": 1,
    "type": "multiple",
    "question": "Im Beispiel /add?firstName=Celine&lastName=Clever ist lastName der Name eines Parameters.",
    "options": ["Falsch", "Wahr"],
    "correct": 1,
    "explanation": "✅ Richtig: Wahr – Im Query-String sind firstName und lastName die Parameternamen.",
    "xp": 10,
    "tags": ["offiziell", "woche4"]
  },
  {
    "difficulty": 2,
    "type": "matching",
    "question": "Ordne MVC-Komponente → Beschreibung zu:",
    "pairs": [
      {"left": "Model", "right": "Enthält Daten und Geschäftslogik"},
      {"left": "View", "right": "Darstellung für den Benutzer"},
      {"left": "Controller", "right": "Verarbeitet Anfragen und verbindet Model & View"}
    ],
    "explanation": "✅ Richtige Zuordnungen: Model = Daten & Geschäftslogik | View = Darstellung für den Benutzer | Controller = Verarbeitet Anfragen und verbindet Model & View.",
    "xp": 15,
    "tags": ["offiziell", "woche4"]
  },
  {
    "difficulty": 1,
    "type": "multiple",
    "question": "Welches Muster trennt Daten, Logik und Darstellung?",
    "options": ["Factory", "MVC", "Decorator", "Singleton"],
    "correct": 1,
    "explanation": "✅ Richtig: MVC (Model-View-Controller) trennt Daten, Logik und Darstellung in drei separate Komponenten.",
    "xp": 10,
    "tags": ["offiziell", "woche4"]
  },
  {
    "difficulty": 2,
    "type": "multiple",
    "question": "Was passiert, wenn ein Parameter in einer HTTP-Anfrage fehlt?",
    "options": ["Ignorieren", "MissingServletRequestParameterException", "Normal verarbeitet", "Automatische Ergänzung"],
    "correct": 1,
    "explanation": "✅ Richtig: MissingServletRequestParameterException – Fehlende Pflicht-Parameter führen zu dieser Exception.",
    "xp": 15,
    "tags": ["offiziell", "woche4"]
  },
  {
    "difficulty": 1,
    "type": "multiple",
    "question": "Welche Komponente löst den View-Namen auf und sucht passende Ressource?",
    "options": ["DispatcherServlet", "Controller", "ViewResolver", "TemplateEngine"],
    "correct": 2,
    "explanation": "✅ Richtig: ViewResolver – Diese Komponente mappt View-Namen zu den entsprechenden Template-Dateien.",
    "xp": 10,
    "tags": ["offiziell", "woche4"]
  },
  {
    "difficulty": 1,
    "type": "multiple",
    "question": "Welche Annotation wird verwendet, um Exception-Handler global bereitzustellen?",
    "options": ["@ResponseStatus", "@ControllerAdvice", "@RestController", "@ExceptionHandler"],
    "correct": 1,
    "explanation": "✅ Richtig: @ControllerAdvice – Diese Annotation ermöglicht globale Exception-Handler für die gesamte Anwendung.",
    "xp": 10,
    "tags": ["offiziell", "woche4"]
  },
  {
    "difficulty": 1,
    "type": "multiple",
    "question": "Welche Annotation markiert eine Methode, die Exceptions behandelt?",
    "options": ["@ErrorMapping", "@Handle", "@ExceptionHandler", "@Catch"],
    "correct": 2,
    "explanation": "✅ Richtig: @ExceptionHandler – Diese Annotation markiert Methoden, die spezifische Exception-Typen behandeln.",
    "xp": 10,
    "tags": ["offiziell", "woche4"]
  },
  {
    "difficulty": 1,
    "type": "multiple",
    "question": "Was passiert mit einer Anfrage ohne passende Controller-Methode?",
    "options": ["302 Redirect", "404 Fehler", "204 Leerantwort", "500 Fehler"],
    "correct": 1,
    "explanation": "✅ Richtig: 404 Fehler – Ohne passendes Mapping wird ein 404 Not Found zurückgegeben.",
    "xp": 10,
    "tags": ["offiziell", "woche4"]
  },
  {
    "difficulty": 1,
    "type": "multiple",
    "question": "Welche Annotation dient der Darstellung von Views in Spring Boot?",
    "options": ["@Repository", "@Service", "@Controller", "@Component"],
    "correct": 2,
    "explanation": "✅ Richtig: @Controller – Diese Annotation kennzeichnet eine MVC-Controller-Klasse zur View-Darstellung.",
    "xp": 10,
    "tags": ["offiziell", "woche4"]
  },
  {
    "difficulty": 1,
    "type": "multiple",
    "question": "Welche Annotation wird verwendet, um Controller-Methoden mit URL-Pfaden zu verbinden?",
    "options": ["@Qualifier", "@RequestMapping", "@Autowired", "@Resource"],
    "correct": 1,
    "explanation": "✅ Richtig: @RequestMapping – Diese Annotation (und ihre Spezialisierungen wie @GetMapping, @PostMapping) verbindet URL-Pfade mit Controller-Methoden.",
    "xp": 10,
    "tags": ["offiziell", "woche4"]
  },
  {
    "difficulty": 1,
    "type": "multiple",
    "question": "Was ist die Hauptaufgabe des Controllers im MVC-Muster?",
    "options": ["Persistenz-Schicht verwalten", "Datenhaltung", "Rendering", "Verarbeitung von Anfragen und Übergabe der Daten an die View"],
    "correct": 3,
    "explanation": "✅ Richtig: Verarbeitung von Anfragen und Übergabe der Daten an die View – Der Controller vermittelt zwischen Anfrage und Darstellung.",
    "xp": 10,
    "tags": ["offiziell", "woche4"]
  },
  {
    "difficulty": 1,
    "type": "multiple",
    "question": "Was ist die Hauptaufgabe des Models im MVC-Muster?",
    "options": ["Routing", "Styling", "Geschäftslogik & Daten verwalten", "HTML erzeugen"],
    "correct": 2,
    "explanation": "✅ Richtig: Geschäftslogik & Daten verwalten – Das Model kapselt die Geschäftslogik und verwaltet die Daten der Anwendung.",
    "xp": 10,
    "tags": ["offiziell", "woche4"]
  },
  {
    "difficulty": 1,
    "type": "multiple",
    "question": "Was ist die Hauptaufgabe der View im MVC-Muster?",
    "options": ["Persistenz", "Darstellung der Daten", "Business-Logik", "Request-Routing"],
    "correct": 1,
    "explanation": "✅ Richtig: Darstellung der Daten – Die View rendert die Inhalte für den Benutzer.",
    "xp": 10,
    "tags": ["offiziell", "woche4"]
  },
  {
    "difficulty": 2,
    "type": "multiple",
    "question": "Welche Annotation verbindet HTTP-Parameter mit Methodenparametern?",
    "options": ["@PathVariable", "@RequestParam", "@Param", "@BindParam"],
    "correct": 1,
    "explanation": "✅ Richtig: @RequestParam – Diese Annotation bindet HTTP Query-Parameter an Methodenparameter.",
    "xp": 15,
    "tags": ["offiziell", "woche4"]
  },
  {
    "difficulty": 1,
    "type": "multiple",
    "question": "Welche Spring-Komponente ist für das Rendern von HTML-Seiten zuständig?",
    "options": ["Controller", "HandlerMapping", "View", "Model"],
    "correct": 2,
    "explanation": "✅ Richtig: View – Die View-Komponente generiert die HTML-Ausgabe für den Benutzer.",
    "xp": 10,
    "tags": ["offiziell", "woche4"]
  },
  {
    "difficulty": 2,
    "type": "sort",
    "question": "In welcher Reihenfolge erfolgt die Verarbeitung eines HTTP-Requests im MVC-Framework?",
    "items": ["Client", "DispatcherServlet", "Controller", "Model", "ViewResolver", "View", "Client"],
    "correct": ["Client", "DispatcherServlet", "Controller", "Model", "ViewResolver", "View", "Client"],
    "explanation": "Standardfluss einer Anfrage.\n✅ Client → DispatcherServlet → Controller → Model → ViewResolver → View → Client",
    "xp": 15,
    "tags": ["offiziell", "woche4"]
  },
  {
    "difficulty": 1,
    "type": "multiple",
    "question": "Welcher Vorteil ergibt sich durch das MVC-Muster?",
    "options": ["Weniger Modularität", "Bessere Wartbarkeit durch klare Trennung", "Mehr Serverlast", "Höhere Kopplung"],
    "correct": 1,
    "explanation": "✅ Richtig: Bessere Wartbarkeit durch klare Trennung – Die Trennung der Komponenten erhöht Wartbarkeit und Testbarkeit.",
    "xp": 10,
    "tags": ["offiziell", "woche4"]
  },
  {
    "difficulty": 1,
    "type": "multiple",
    "question": "Welche Datei-Struktur nutzt Spring Boot für statische Ressourcen wie CSS oder JS?",
    "options": ["/src/main/resources/templates", "/public", "/src/main/resources/static", "/static/assets"],
    "correct": 2,
    "explanation": "✅ Richtig: /src/main/resources/static – Statische Ressourcen wie CSS, JS und Bilder werden in diesem Ordner abgelegt.",
    "xp": 10,
    "tags": ["offiziell", "woche4"]
  },
  {
    "difficulty": 1,
    "type": "multiple",
    "question": "Wie werden dynamische Werte aus dem Model in Thymeleaf angezeigt?",
    "options": ["th:model", "th:attr", "th:text", "th:data"],
    "correct": 2,
    "explanation": "✅ Richtig: th:text – Das Attribut th:text=\"${variable}\" bindet einen Model-Wert als Textinhalt im HTML-Element.",
    "xp": 10,
    "tags": ["offiziell", "woche4"]
  },
  {
    "difficulty": 2,
    "type": "multiple",
    "question": "Welches Verhalten zeigt Spring Boot, wenn eine Exception nicht abgefangen wird?",
    "options": ["Silent Ignoring", "Automatische Wiederholung", "Standard-Error-Controller zeigt Fehlerseite", "Server stoppt"],
    "correct": 2,
    "explanation": "✅ Richtig: Standard-Error-Controller zeigt Fehlerseite – Unbehandelte Exceptions werden vom ErrorController abgefangen und als Fehlerseite dargestellt.",
    "xp": 15,
    "tags": ["offiziell", "woche4"]
  },
  {
    "difficulty": 2,
    "type": "multiple",
    "question": "Welche Methode ruft das DispatcherServlet nach der Auflösung des Controllers auf?",
    "options": ["Filter-Kette", "Passende Handler-Methode gemäß Mapping", "Destroy-Methode", "Init-Methode"],
    "correct": 1,
    "explanation": "✅ Richtig: Passende Handler-Methode gemäß Mapping – Das DispatcherServlet führt die Controller-Methode aus, die dem URL-Mapping entspricht.",
    "xp": 15,
    "tags": ["offiziell", "woche4"]
  },
  {
    "difficulty": 2,
    "type": "multiple",
    "question": "Welche Komponente übernimmt das Mapping zwischen URL und Controller-Methode?",
    "options": ["ErrorController", "ViewResolver", "HandlerMapping", "BeanFactory"],
    "correct": 2,
    "explanation": "✅ Richtig: HandlerMapping – Diese Komponente bestimmt die passende Controller-Methode für eine eingehende URL.",
    "xp": 15,
    "tags": ["offiziell", "woche4"]
  },
  {
    "difficulty": 2,
    "type": "multiple",
    "question": "Wofür wird @ModelAttribute verwendet?",
    "options": ["Validierung erzwingen", "Logging aktivieren", "Bean registrieren", "Model-Daten binden oder bereitstellen"],
    "correct": 3,
    "explanation": "✅ Richtig: Model-Daten binden oder bereitstellen – @ModelAttribute bindet Formular-/Request-Daten und stellt sie der View bereit.",
    "xp": 15,
    "tags": ["offiziell", "woche4"]
  },
  {
    "difficulty": 2,
    "type": "multiple",
    "question": "Was passiert, wenn ein Controller eine View zurückgibt, aber kein Model bereitstellt?",
    "options": ["Automatische Dummy-Daten", "Leere View ohne dynamische Daten", "Fehler 500", "Endlosschleife"],
    "correct": 1,
    "explanation": "✅ Richtig: Leere View ohne dynamische Daten – Ohne Model-Inhalte wird nur das statische Template ohne dynamische Werte gerendert.",
    "xp": 15,
    "tags": ["offiziell", "woche4"]
  },
  {
    "difficulty": 2,
    "type": "multiple",
    "question": "Welche Spring-Annotation markiert eine Klasse als Controller, der direkt JSON-Objekte zurückgibt?",
    "options": ["@ControllerJSON", "@JsonController", "@RestController", "@ResponseController"],
    "correct": 2,
    "explanation": "✅ Richtig: @RestController – Diese Annotation kombiniert @Controller und @ResponseBody für REST-APIs mit JSON-Rückgaben.",
    "xp": 15,
    "tags": ["offiziell", "woche4"]
  },
  {
    "difficulty": 1,
    "type": "multiple",
    "question": "Welche Schicht enthält in der Regel die Geschäftslogik?",
    "options": ["DispatcherServlet", "Model", "Templating", "View"],
    "correct": 1,
    "explanation": "✅ Richtig: Model – Die Geschäftslogik und Daten befinden sich im Model bzw. Service-Layer.",
    "xp": 10,
    "tags": ["offiziell", "woche4"]
  },
  {
    "difficulty": 2,
    "type": "multiple",
    "question": "Welcher Vorteil ergibt sich aus @ControllerAdvice und @ExceptionHandler?",
    "options": ["Performance-Optimierung", "Zentrale einheitliche Fehlerbehandlung", "Automatisches Logging deaktivieren", "Mehr Kopplung"],
    "correct": 1,
    "explanation": "✅ Richtig: Zentrale einheitliche Fehlerbehandlung – Globale Fehlerlogik statt duplizierter Exception-Handler in jedem Controller.",
    "xp": 15,
    "tags": ["offiziell", "woche4"]
  },
  {
    "difficulty": 1,
    "type": "multiple",
    "question": "Was ist der Zweck der Annotation @Service?",
    "options": ["Routing", "Static Binding", "Markiert Geschäftslogik-Komponente", "Templating"],
    "correct": 2,
    "explanation": "✅ Richtig: Markiert Geschäftslogik-Komponente – @Service kennzeichnet eine Service-Klasse mit Business-Logik.",
    "xp": 10,
    "tags": ["offiziell", "woche4"]
  },
  {
    "difficulty": 2,
    "type": "multiple",
    "question": "Wie nennt man den Mechanismus, der View-Namen in Dateien wie HTML oder JSP auflöst?",
    "options": ["TemplateScanner", "ViewEngine", "ViewResolver", "NameMapper"],
    "correct": 2,
    "explanation": "✅ Richtig: ViewResolver – Dieser Mechanismus löst View-Namen in entsprechende Template-Dateien (HTML, JSP) auf.",
    "xp": 15,
    "tags": ["offiziell", "woche4"]
  },
  {
    "difficulty": 2,
    "type": "matching",
    "question": "Ordne MVC Ablauf: Komponente → Aufgabe",
    "pairs": [
      {"left": "Controller", "right": "Nimmt HTTP-Requests entgegen"},
      {"left": "Model", "right": "Speichert Daten und Logik"},
      {"left": "View", "right": "Rendert HTML-Ausgabe"}
    ],
    "explanation": "✅ Richtige Zuordnungen: Controller = Nimmt HTTP-Requests entgegen | Model = Speichert Daten und Logik | View = Rendert HTML-Ausgabe. Dies sind die grundlegenden Verantwortlichkeiten der MVC-Schichten.",
    "xp": 15,
    "tags": ["offiziell", "woche4"]
  }
  ,
  {
    "difficulty": 1,
    "type": "multiple",
    "question": "Das Model enthält die Logik zur Anzeige der Daten.",
    "options": ["Falsch", "Wahr"],
    "correct": 0,
    "explanation": "✅ Richtig: Falsch – Die Anzeige (Rendering) ist Aufgabe der View. Das Model hält Daten und Geschäftslogik, nicht die Präsentationslogik.",
    "xp": 10,
    "tags": ["offiziell", "woche4"]
  },
  {
    "difficulty": 1,
    "type": "multiple",
    "question": "Der Hostname example.com besteht aus einer Top-Level-Domain, einer Second-Level-Domain und ggf. einer Subdomain.",
    "options": ["Falsch", "Wahr"],
    "correct": 1,
    "explanation": "✅ Richtig: Wahr – example.com besteht aus Second-Level-Domain 'example' + Top-Level-Domain '.com'; Subdomains sind optional (z.B. www.example.com).",
    "xp": 10,
    "tags": ["offiziell", "woche4"]
  },
  {
    "difficulty": 1,
    "type": "multiple",
    "question": "Welches Attribut in Thymeleaf wird verwendet, um dynamische Daten darzustellen?",
    "options": ["th:each", "th:class", "th:src", "th:text"],
    "correct": 3,
    "explanation": "✅ Richtig: th:text – Das Attribut th:text=\"${variable}\" zeigt dynamische Daten aus dem Model im HTML-Element an.",
    "xp": 10,
    "tags": ["offiziell", "woche4"]
  },
  {
    "difficulty": 1,
    "type": "multiple",
    "question": "Die Trennung von Model, View und Controller erleichtert die Wartung der Anwendung.",
    "options": ["Falsch", "Wahr"],
    "correct": 1,
    "explanation": "✅ Richtig: Wahr – Die klare Trennung der MVC-Komponenten sorgt für bessere Testbarkeit, Wiederverwendbarkeit und Wartbarkeit.",
    "xp": 10,
    "tags": ["offiziell", "woche4"]
  },
  {
    "difficulty": 1,
    "type": "multiple",
    "question": "Welche Klasse ist für die Verarbeitung von Ausnahmen in der gesamten Anwendung zuständig?",
    "options": ["FaultController", "ErrorService", "GlobalExceptionHandler", "ExceptionManager"],
    "correct": 2,
    "explanation": "✅ Richtig: GlobalExceptionHandler – Diese Klasse (typischerweise mit @ControllerAdvice annotiert) behandelt zentral alle Exceptions der Anwendung.",
    "xp": 10,
    "tags": ["offiziell", "woche4"]
  },
  {
    "difficulty": 1,
    "type": "multiple",
    "question": "HTML-Dateien für dynamische Inhalte müssen im Ordner /templates gespeichert werden.",
    "options": ["Falsch", "Wahr"],
    "correct": 1,
    "explanation": "✅ Richtig: Wahr – Thymeleaf-Templates für dynamische Views werden unter src/main/resources/templates gespeichert.",
    "xp": 10,
    "tags": ["offiziell", "woche4"]
  },
  {
    "difficulty": 1,
    "type": "multiple",
    "question": "Welche Rolle übernimmt der Controller im MVC-Entwurfsmuster?",
    "options": ["HTML rendern", "Datenbank verwalten", "Anfragen verarbeiten und Daten an die View weiterleiten", "Daten speichern"],
    "correct": 2,
    "explanation": "✅ Richtig: Anfragen verarbeiten und Daten an die View weiterleiten – Der Controller nimmt Requests entgegen, verarbeitet sie (ggf. mit Model) und leitet die Daten an die View weiter.",
    "xp": 10,
    "tags": ["offiziell", "woche4"]
  },
  {
    "difficulty": 1,
    "type": "multiple",
    "question": "Was beschreibt REST im Kern?",
    "options": [
      "Ein Protokoll zur Datenbankkommunikation",
      "Ein Architekturstil für verteilte Systeme",
      "Ein Messaging-Framework",
      "Eine serverseitige Template-Engine"
    ],
    "correct": 1,
    "explanation": "✅ Richtig: REST ist ein Architekturstil für verteilte Systeme und definiert Prinzipien wie Ressourcenorientierung, standardisierte HTTP-Methoden und Hypermedia-Navigation.",
    "xp": 12,
    "tags": ["uebung", "woche5"]
  },
  {
    "difficulty": 1,
    "type": "multiple",
    "question": "Welche Aussage beschreibt eine Ressource korrekt?",
    "options": [
      "Ressourcen bestehen immer aus JSON",
      "Alles, was eindeutig adressierbar ist, kann eine Ressource sein",
      "Ressourcen sind nur Dateien",
      "Ressourcen können keine Listen sein"
    ],
    "correct": 1,
    "explanation": "✅ Richtig: Jede eindeutig adressierbare Entität – Dokument, Sammlung, Ergebnisliste – kann eine Ressource sein, unabhängig vom Format.",
    "xp": 12,
    "tags": ["uebung", "woche5"]
  },
  {
    "difficulty": 1,
    "type": "fillblank",
    "question": "Eine REST-Ressource wird eindeutig über eine _____ adressiert.",
    "blanks": ["URI"],
    "explanation": "✅ Richtig: URIs (Uniform Resource Identifier) identifizieren Ressourcen eindeutig und stellen sicher, dass Client und Server über dieselbe Adresse sprechen.",
    "xp": 15,
    "tags": ["uebung", "woche5"]
  },
  {
    "difficulty": 2,
    "type": "sort",
    "question": "Sortiere die Bestandteile einer vollständigen URI in der Reihenfolge, wie sie in der Adresse erscheinen:",
    "items": ["query", "host", "scheme", "path", "port"],
    "correct": ["scheme", "host", "port", "path", "query"],
    "explanation": "✅ Richtig: scheme://host:port/path?query – erst das Schema, dann Host, optional der Port, anschließend der Pfad und zuletzt der Query-Teil.",
    "xp": 18,
    "tags": ["uebung", "woche5"]
  },
  {
    "difficulty": 1,
    "type": "multiple",
    "question": "Welche Eigenschaft beschreibt zustandslose Kommunikation (stateless) korrekt?",
    "options": [
      "Der Server speichert Session-Daten eines Clients",
      "Der Client übermittelt alle nötigen Informationen bei jeder Anfrage",
      "Cookies müssen immer gesetzt werden",
      "Der Server hält den Zustand der letzten zehn Requests"
    ],
    "correct": 1,
    "explanation": "✅ Richtig: Bei Statelessness enthält jede Anfrage sämtliche benötigten Kontextinformationen, sodass der Server keinen Sitzungszustand behalten muss.",
    "xp": 12,
    "tags": ["uebung", "woche5"]
  },
  {
    "difficulty": 1,
    "type": "multiple",
    "question": "Welche HTTP-Methode wird klassisch zum Erstellen einer neuen Ressource verwendet?",
    "options": ["GET", "PUT", "POST", "DELETE"],
    "correct": 2,
    "explanation": "✅ Richtig: POST erzeugt neue Ressourcen oder löst serverseitige Verarbeitung aus, bei der der Server die finale URI bestimmt.",
    "xp": 10,
    "tags": ["uebung", "woche5"]
  },
  {
    "difficulty": 1,
    "type": "multiple",
    "question": "Welche HTTP-Methode gilt im CRUD-Kontext als idempotent für Updates?",
    "options": ["POST", "PUT", "PATCH", "OPTIONS"],
    "correct": 1,
    "explanation": "✅ Richtig: PUT überschreibt eine Ressource vollständig – mehrere identische Aufrufe führen zum selben Ergebnis und sind deshalb idempotent.",
    "xp": 12,
    "tags": ["uebung", "woche5"]
  },
  {
    "difficulty": 1,
    "type": "multiple",
    "question": "Was tut die DELETE-Methode im REST-Kontext?",
    "options": [
      "Sie führt Berechnungen aus",
      "Sie löscht eine Ressource",
      "Sie listet mehrere Ressourcen auf",
      "Sie erstellt mehrere Ressourcen"
    ],
    "correct": 1,
    "explanation": "✅ Richtig: DELETE entfernt die adressierte Ressource – wiederholte Aufrufe liefern höchstens einen 404, verändern das Ergebnis aber nicht.",
    "xp": 10,
    "tags": ["uebung", "woche5"]
  },
  {
    "difficulty": 1,
    "type": "multiple",
    "question": "Welche Operation ist NICHT idempotent?",
    "options": ["GET", "PUT", "DELETE", "POST"],
    "correct": 3,
    "explanation": "✅ Richtig: POST ist nicht idempotent, weil jeder Aufruf eine neue Ressource erzeugen oder einen neuen Zustand bewirken kann.",
    "xp": 12,
    "tags": ["uebung", "woche5"]
  },
  {
    "difficulty": 2,
    "type": "checkbox",
    "question": "Welche Annotationen bildet ein klassischer CrudController ab? (Mehrfachauswahl)",
    "options": ["@GetMapping", "@PostMapping", "@PutMapping", "@DeleteMapping", "@PatchMapping"],
    "correct": [0, 1, 2, 3],
    "explanation": "✅ Richtig: CRUD deckt Lesen, Erstellen, Aktualisieren und Löschen ab – typischerweise @GetMapping, @PostMapping, @PutMapping und @DeleteMapping.",
    "xp": 18,
    "tags": ["uebung", "woche5"]
  },
  {
    "difficulty": 1,
    "type": "multiple",
    "question": "Welche Aussage über Repräsentationen ist korrekt?",
    "options": [
      "Eine Ressource kann nur in HTML ausgeliefert werden",
      "Ressourcen können verschiedene Repräsentationen haben",
      "Der Client entscheidet nicht über das Format",
      "Repräsentationen dürfen kein JSON enthalten"
    ],
    "correct": 1,
    "explanation": "✅ Richtig: Eine Ressource kann mehrere Repräsentationen (JSON, XML, HTML …) besitzen – Content-Negotiation wählt das passende Format.",
    "xp": 12,
    "tags": ["uebung", "woche5"]
  },
  {
    "difficulty": 1,
    "type": "multiple",
    "question": "Warum ist es sinnvoll, komplexe Daten im Request-Body statt in der URL zu übertragen?",
    "options": [
      "URLs unterstützen nur Zahlen",
      "URLs sind nicht verschlüsselbar",
      "URLs sind begrenzt und ungeeignet für komplexe Daten",
      "Body-Daten sind grundsätzlich schneller"
    ],
    "correct": 2,
    "explanation": "✅ Richtig: URLs haben Längenlimits und sind schlecht lesbar für komplexe Strukturen; der Body erlaubt strukturierte JSON/Payloads.",
    "xp": 12,
    "tags": ["uebung", "woche5"]
  },
  {
    "difficulty": 1,
    "type": "multiple",
    "question": "Was repräsentiert ResponseEntity?",
    "options": [
      "Nur den HTTP-Body",
      "HTTP-Status, Header und Body zusammen",
      "Nur den HTTP-Header",
      "Nur Metadaten"
    ],
    "correct": 1,
    "explanation": "✅ Richtig: ResponseEntity kapselt Statuscode, Header und Body und erlaubt so vollständige Kontrolle über die Antwort.",
    "xp": 12,
    "tags": ["uebung", "woche5"]
  },
  {
    "difficulty": 1,
    "type": "multiple",
    "question": "Welche Annotation kombiniert @Controller und @ResponseBody?",
    "options": ["@RestController", "@JSONController", "@HtmlController", "@ResponseRest"],
    "correct": 0,
    "explanation": "✅ Richtig: @RestController setzt automatisch @Controller + @ResponseBody und liefert Rückgabewerte direkt als JSON/XML.",
    "xp": 10,
    "tags": ["uebung", "woche5"]
  },
  {
    "difficulty": 1,
    "type": "multiple",
    "question": "Was bewirkt produces=MediaType.APPLICATION_JSON_VALUE?",
    "options": [
      "Der Client sendet nur XML",
      "Der Rückgabewert wird im JSON-Format geliefert",
      "Der Controller wird nicht aufgerufen",
      "HTML wird automatisch erzeugt"
    ],
    "correct": 1,
    "explanation": "✅ Richtig: Über das produces-Attribut signalisiert die Methode, dass sie eine JSON-Repräsentation liefert.",
    "xp": 10,
    "tags": ["uebung", "woche5"]
  },
  {
    "difficulty": 1,
    "type": "multiple",
    "question": "Welcher Statuscode wird gesendet, wenn eine Liste existiert und zurückgegeben wird?",
    "options": ["200 OK", "201 Created", "204 No Content", "404 Not Found"],
    "correct": 0,
    "explanation": "✅ Richtig: 200 OK signalisiert, dass eine Ressource gefunden und im Body (z.B. als Liste) übertragen wurde.",
    "xp": 10,
    "tags": ["uebung", "woche5"]
  },
  {
    "difficulty": 1,
    "type": "multiple",
    "question": "Welcher Statuscode wird für eine leere Liste zurückgegeben?",
    "options": ["200 OK", "204 No Content", "422 Unprocessable Entity", "500 Internal Server Error"],
    "correct": 1,
    "explanation": "✅ Richtig: 204 No Content signalisiert erfolgreiche Verarbeitung ohne Body – passend für leere Sammlungen.",
    "xp": 10,
    "tags": ["uebung", "woche5"]
  },
  {
    "difficulty": 1,
    "type": "multiple",
    "question": "Was bedeutet 201 Created?",
    "options": [
      "Eine Ressource wurde gefunden",
      "Eine Ressource wurde erfolgreich erstellt",
      "Der Request war unvollständig",
      "Der Client ist nicht autorisiert"
    ],
    "correct": 1,
    "explanation": "✅ Richtig: 201 Created bestätigt, dass eine neue Ressource erstellt wurde – meist mit Verweis auf deren URI.",
    "xp": 10,
    "tags": ["uebung", "woche5"]
  },
  {
    "difficulty": 1,
    "type": "multiple",
    "question": "Wann wird der Statuscode 422 Unprocessable Entity gesendet?",
    "options": [
      "Wenn ein URL-Parameter fehlt oder leer ist",
      "Wenn die Ressource nicht existiert",
      "Wenn die Anfrage syntaktisch gültig ist, aber nicht verarbeitet werden kann",
      "Wenn der Server abstürzt"
    ],
    "correct": 2,
    "explanation": "✅ Richtig: 422 signalisiert, dass der Request formal korrekt ist, aber fachlich nicht verarbeitet werden kann (z.B. Validierungsfehler).",
    "xp": 12,
    "tags": ["uebung", "woche5"]
  },
  {
    "difficulty": 1,
    "type": "multiple",
    "question": "Welcher Header wird bei 201 Created in der Regel zusätzlich gesetzt?",
    "options": ["Accept-Language", "Authorization", "Location", "Content-Encoding"],
    "correct": 2,
    "explanation": "✅ Richtig: Der Location-Header enthält die URI der neu erstellten Ressource und ermöglicht dem Client direktes Nachladen.",
    "xp": 12,
    "tags": ["uebung", "woche5"]
  },
  {
    "difficulty": 1,
    "type": "multiple",
    "question": "Wofür steht das Akronym HATEOAS?",
    "options": [
      "Hypermedia As The Engine Of Application State",
      "Hyperlinks And Testing Engine Of API Services",
      "HTML As Template Engine On API Services",
      "Hostname Allocation Through External API System"
    ],
    "correct": 0,
    "explanation": "✅ Richtig: HATEOAS bedeutet Hypermedia As The Engine Of Application State – Links in den Antworten führen den Client durch den API-Zustand.",
    "xp": 12,
    "tags": ["uebung", "woche5"]
  },
  {
    "difficulty": 1,
    "type": "multiple",
    "question": "Was enthält eine Sammelressource (Collection Resource)?",
    "options": [
      "Alle Details aller Objekte",
      "Eine Liste plus Links zu Einzelressourcen",
      "Ein einzelnes Objekt",
      "Nur Query-Parameter"
    ],
    "correct": 1,
    "explanation": "✅ Richtig: Collections bündeln mehrere Elemente und liefern Hypermedia-Links zu den jeweiligen Einzelressourcen.",
    "xp": 12,
    "tags": ["uebung", "woche5"]
  },
  {
    "difficulty": 1,
    "type": "multiple",
    "question": "Was enthält eine Einzelressource?",
    "options": [
      "Nur einen Link",
      "Alle Details zur Ressource",
      "Nur Metadaten",
      "Nur die Ressourcengröße"
    ],
    "correct": 1,
    "explanation": "✅ Richtig: Einzelressourcen liefern die vollständige Darstellung eines konkreten Objekts inklusive seiner Attribute und Links.",
    "xp": 12,
    "tags": ["uebung", "woche5"]
  },
  {
    "difficulty": 1,
    "type": "multiple",
    "question": "Welche URI entspricht einer korrekten Ressourcendefinition?",
    "options": ["/createUser", "/deleteConversation", "/conversations/{id}", "/runActionNow"],
    "correct": 2,
    "explanation": "✅ Richtig: /conversations/{id} nutzt Substantive und Platzhalter – REST-URIs benennen Ressourcen, nicht Aktionen.",
    "xp": 12,
    "tags": ["uebung", "woche5"]
  },
  {
    "difficulty": 1,
    "type": "multiple",
    "question": "Welche Regel gilt für URIs im REST-Design?",
    "options": [
      "Verben müssen verwendet werden",
      "URIs bestehen ausschließlich aus Substantiven",
      "URIs enthalten immer einen Query-String",
      "URIs müssen groß geschrieben sein"
    ],
    "correct": 1,
    "explanation": "✅ Richtig: Ressourcen werden als Substantive modelliert (z.B. /users/42) – Aktionen werden durch HTTP-Methoden beschrieben, nicht durch den Pfad.",
    "xp": 12,
    "tags": ["uebung", "woche5"]
  },
  {
    "difficulty": 1,
    "type": "multiple",
    "question": "Welche URI zeigt Paging?",
    "options": ["/conversations?page=1", "/conversations!page", "/page/conversations/1", "/conversation/page?next"],
    "correct": 0,
    "explanation": "✅ Richtig: Query-Parameter wie page=1 signalisieren Paging – die Ressource selbst bleibt /conversations.",
    "xp": 10,
    "tags": ["uebung", "woche5"]
  },
  {
    "difficulty": 1,
    "type": "multiple",
    "question": "Was beschreibt eine sekundäre Sammlung?",
    "options": [
      "Eine Ressourcenliste, die eine Untermenge einer anderen Liste ist",
      "Eine Ressource ohne ID",
      "Ein Datenbankindex",
      "Einen Fehlercode"
    ],
    "correct": 0,
    "explanation": "✅ Richtig: Sekundäre Sammlungen hängen an einer Oberressource (z.B. /conversations/42/messages) und bilden deren Teilmengen ab.",
    "xp": 12,
    "tags": ["uebung", "woche5"]
  },
  {
    "difficulty": 1,
    "type": "multiple",
    "question": "Welche Funktion erfüllt Swagger-UI?",
    "options": [
      "Es generiert automatisch HTML-Views",
      "Es dokumentiert und testet REST-APIs im Browser",
      "Es überwacht Serverlogs",
      "Es ersetzt ResponseEntity"
    ],
    "correct": 1,
    "explanation": "✅ Richtig: Swagger-UI visualisiert OpenAPI-Spezifikationen, dokumentiert Endpunkte und erlaubt interaktive Tests direkt im Browser.",
    "xp": 12,
    "tags": ["uebung", "woche5"]
  },
  {
    "difficulty": 1,
    "type": "multiple",
    "question": "Welche Aussage zu cURL ist korrekt?",
    "options": [
      "cURL kann nur GET-Requests senden",
      "cURL kann alle HTTP-Methoden senden",
      "cURL funktioniert nur mit HTML-Webseiten",
      "cURL kann keine Header anzeigen"
    ],
    "correct": 1,
    "explanation": "✅ Richtig: cURL ist ein Kommandozeilen-Client für HTTP/HTTPS und unterstützt sämtliche Methoden inklusive Header- und Body-Konfiguration.",
    "xp": 12,
    "tags": ["uebung", "woche5"]
  },
  {
    "difficulty": 1,
    "type": "multiple",
    "question": "Welche Antwort gibt GET /restful/users/25 zurück, wenn der User nicht existiert?",
    "options": ["200 OK", "204 No Content", "404 Not Found", "422 Unprocessable Entity"],
    "correct": 2,
    "explanation": "✅ Richtig: Existiert die Ressource nicht, liefert der Server 404 Not Found – der Client weiß so, dass die URI unbekannt ist.",
    "xp": 12,
    "tags": ["uebung", "woche5"]
  },
  {
    "difficulty": 1,
    "type": "multiple",
    "question": "Welche HTTP-Methode wird bei GraphQL-Requests in der Übung verwendet?",
    "options": ["GET", "PUT", "POST", "DELETE"],
    "correct": 2,
    "explanation": "✅ Richtig: GraphQL-Anfragen werden typischerweise per POST an einen einzigen Endpoint gesendet, unabhängig davon, ob es sich um Query, Mutation oder Subscription handelt.",
    "xp": 10,
    "tags": ["uebung", "woche6"]
  },
  {
    "difficulty": 1,
    "type": "multiple",
    "question": "Welches Datenformat wird für die Übertragung von GraphQL-Anfragen und -Antworten genutzt?",
    "options": ["XML", "JSON", "CSV", "YAML"],
    "correct": 1,
    "explanation": "✅ Richtig: JSON ist das Standardformat für GraphQL-Request-Payloads und -Responses und gewährleistet strukturierte Daten.",
    "xp": 10,
    "tags": ["uebung", "woche6"]
  },
  {
    "difficulty": 1,
    "type": "multiple",
    "question": "Was ist ein zentrales Merkmal von GraphQL im Vergleich zu REST?",
    "options": [
      "Jede Operation braucht einen eigenen HTTP-Endpoint",
      "Der Client kann exakt angeben, welche Felder er zurückhaben möchte",
      "Es werden ausschließlich GET-Requests verwendet",
      "GraphQL unterstützt keine Mutationen"
    ],
    "correct": 1,
    "explanation": "✅ Richtig: GraphQL erlaubt es dem Client, in der Query präzise zu spezifizieren, welche Felder er benötigt – das reduziert Over- und Underfetching.",
    "xp": 12,
    "tags": ["uebung", "woche6"]
  },
  {
    "difficulty": 1,
    "type": "multiple",
    "question": "Welche Operation aus dem Schema ist eine \"read\"-Operation (Query)?",
    "options": ["addUser", "updateUser", "deleteUser", "allUsers"],
    "correct": 3,
    "explanation": "✅ Richtig: allUsers ist eine Query zum Abrufen von Daten. Mutationen wie addUser, updateUser oder deleteUser verändern Daten.",
    "xp": 10,
    "tags": ["uebung", "woche6"]
  },
  {
    "difficulty": 1,
    "type": "fillblank",
    "question": "Der Typ _____ im GraphQL-Schema beschreibt die Struktur eines User-Objekts mit seinen Feldern.",
    "blanks": ["User"],
    "explanation": "✅ Richtig: Der User-Typ definiert die Feldstruktur (id, firstName, lastName etc.) und legt fest, welche Daten ein User-Objekt enthält.",
    "xp": 15,
    "tags": ["uebung", "woche6"]
  },
  {
    "difficulty": 1,
    "type": "multiple",
    "question": "Was bedeutet das Ausrufezeichen ! hinter einem Feldtyp im GraphQL-Schema (z. B. firstName: String!)?",
    "options": [
      "Das Feld ist veraltet",
      "Das Feld wird clientseitig berechnet",
      "Das Feld darf nicht null sein",
      "Das Feld ist optional"
    ],
    "correct": 2,
    "explanation": "✅ Richtig: Das ! markiert ein Pflichtfeld – der Server garantiert, dass dieses Feld nie null ist.",
    "xp": 12,
    "tags": ["uebung", "woche6"]
  },
  {
    "difficulty": 1,
    "type": "checkbox",
    "question": "Welche Scalar-Typen gehören zu den standardmäßig in GraphQL unterstützten Typen? (Mehrfachauswahl)",
    "options": ["Int", "Float", "String", "Boolean", "ID"],
    "correct": [0, 1, 2, 3, 4],
    "explanation": "✅ Richtig: GraphQL definiert die fünf Standard-Scalar-Typen Int, Float, String, Boolean und ID – sie bilden die Basis für alle Felder.",
    "xp": 15,
    "tags": ["uebung", "woche6"]
  },
  {
    "difficulty": 1,
    "type": "multiple",
    "question": "Welche Operationen werden in GraphQL typischerweise über Mutation abgebildet?",
    "options": [
      "Nur Lese-Operationen",
      "Änderungen, Erstellungen oder Löschungen von Daten",
      "Nur Logging-Operationen",
      "Nur Authentifizierungs-Operationen"
    ],
    "correct": 1,
    "explanation": "✅ Richtig: Mutationen dienen zum Erstellen, Ändern oder Löschen von Daten – im Gegensatz zu Queries, die nur lesen.",
    "xp": 12,
    "tags": ["uebung", "woche6"]
  },
  {
    "difficulty": 1,
    "type": "multiple",
    "question": "Welche Query im Schema unterstützt Paging-Funktionalität?",
    "options": ["allUsers", "users", "userById", "addUser"],
    "correct": 1,
    "explanation": "✅ Richtig: Die Query users(offset: Int, limit: Int) ermöglicht Paging durch optionale Parameter für Offset und Limit.",
    "xp": 12,
    "tags": ["uebung", "woche6"]
  },
  {
    "difficulty": 1,
    "type": "multiple",
    "question": "Wie werden die GraphQL-Schema-Dateien in der Beispielanwendung organisiert?",
    "options": [
      "In src/main/resources/graphql",
      "In src/main/resources/templates",
      "In src/main/java/graphql",
      "In src/test/resources/graphql"
    ],
    "correct": 0,
    "explanation": "✅ Richtig: Spring for GraphQL sucht Schema-Dateien standardmäßig unter src/main/resources/graphql und lädt sie automatisch.",
    "xp": 12,
    "tags": ["uebung", "woche6"]
  },
  {
    "difficulty": 1,
    "type": "multiple",
    "question": "Welche Annotation wird im Spring-Controller verwendet, um eine Query wie allUsers zu binden?",
    "options": ["@GetMapping", "@QueryMapping", "@GraphQLQuery", "@RestController"],
    "correct": 1,
    "explanation": "✅ Richtig: @QueryMapping verknüpft eine Controller-Methode mit einer GraphQL-Query aus dem Schema.",
    "xp": 12,
    "tags": ["uebung", "woche6"]
  },
  {
    "difficulty": 1,
    "type": "multiple",
    "question": "Welche Annotation wird verwendet, um eine Mutation wie deleteUser zu binden?",
    "options": ["@MutationMapping", "@PostMapping", "@PatchMapping", "@CommandMapping"],
    "correct": 0,
    "explanation": "✅ Richtig: @MutationMapping bindet Controller-Methoden an Mutation-Operationen im GraphQL-Schema.",
    "xp": 12,
    "tags": ["uebung", "woche6"]
  },
  {
    "difficulty": 2,
    "type": "multiple",
    "question": "Wozu dient die Annotation @SchemaMapping(typeName = \"User\") auf Klassenebene?",
    "options": [
      "Sie aktiviert die HTTP-Security für die Klasse",
      "Sie legt fest, dass alle Handler-Methoden dieser Klasse sich standardmäßig auf den Typ User im Schema beziehen",
      "Sie erzeugt automatisch das User-Repository",
      "Sie registriert den Controller als REST-Endpoint unter /user"
    ],
    "correct": 1,
    "explanation": "✅ Richtig: @SchemaMapping(typeName = \"User\") setzt den Kontext für alle Handler in der Klasse – sie beziehen sich auf den User-Typ.",
    "xp": 18,
    "tags": ["uebung", "woche6"]
  },
  {
    "difficulty": 1,
    "type": "fillblank",
    "question": "Um die GraphiQL-Oberfläche zu aktivieren, wird in application.properties die Eigenschaft _____ auf true gesetzt.",
    "blanks": ["spring.graphql.graphiql.enabled"],
    "explanation": "✅ Richtig: spring.graphql.graphiql.enabled=true aktiviert die integrierte GraphiQL-Oberfläche für interaktive Tests.",
    "xp": 15,
    "tags": ["uebung", "woche6"]
  },
  {
    "difficulty": 1,
    "type": "multiple",
    "question": "Unter welcher URI wird der GraphiQL-Editor in der Übung aufgerufen?",
    "options": [
      "http://127.0.0.1:8080/graphql-ui",
      "http://127.0.0.1:8080/graphiql?path=/graphql",
      "http://127.0.0.1:8080/api/graphiql",
      "http://127.0.0.1:8080/graphqleditor"
    ],
    "correct": 1,
    "explanation": "✅ Richtig: GraphiQL ist unter /graphiql?path=/graphql erreichbar und bietet eine grafische Oberfläche zum Testen von Queries und Mutationen.",
    "xp": 12,
    "tags": ["uebung", "woche6"]
  },
  {
    "difficulty": 1,
    "type": "multiple",
    "question": "Welche Dependency stellt in der Spring-Boot-Anwendung die GraphQL-Funktionalität bereit?",
    "options": [
      "spring-boot-starter-data-jpa",
      "spring-boot-starter-webflux",
      "spring-boot-starter-graphql",
      "spring-boot-starter-thymeleaf"
    ],
    "correct": 2,
    "explanation": "✅ Richtig: spring-boot-starter-graphql bringt die nötigen Bibliotheken für Spring for GraphQL und den GraphQL-Endpoint mit.",
    "xp": 12,
    "tags": ["uebung", "woche6"]
  },
  {
    "difficulty": 2,
    "type": "multiple",
    "question": "Was ist der Zweck der Klasse HttpSyncGraphQlClient im GraphQL-Client?",
    "options": [
      "Sie implementiert einen asynchronen Non-Blocking-Client",
      "Sie stellt eine synchrone GraphQL-Client-API auf Basis eines REST-Clients bereit",
      "Sie rendert GraphQL-Antworten als HTML",
      "Sie ersetzt den DispatcherServlet"
    ],
    "correct": 1,
    "explanation": "✅ Richtig: HttpSyncGraphQlClient ermöglicht synchrone GraphQL-Anfragen über HTTP und baut auf RestClient auf.",
    "xp": 18,
    "tags": ["uebung", "woche6"]
  },
  {
    "difficulty": 1,
    "type": "multiple",
    "question": "Wie wird in der Client-Methode getAllUsers() die GraphQL-Query repräsentiert?",
    "options": [
      "Als Java-Annotation",
      "Als XML-Datei",
      "Als String document mit der GraphQL-Syntax",
      "Als JSON-Schema"
    ],
    "correct": 2,
    "explanation": "✅ Richtig: Die Query wird als String document = \"{ allUsers { ... } }\" definiert und an den Server gesendet.",
    "xp": 12,
    "tags": ["uebung", "woche6"]
  },
  {
    "difficulty": 1,
    "type": "multiple",
    "question": "Welche Methode des GraphQL-Clients wird verwendet, um die Antwort in eine Liste von User-Objekten umzuwandeln?",
    "options": ["toList()", "toEntity(User.class)", "toEntityList(User.class)", "mapToList(User.class)"],
    "correct": 2,
    "explanation": "✅ Richtig: toEntityList(User.class) wandelt die JSON-Antwort in eine typisierte Liste von User-Objekten um.",
    "xp": 12,
    "tags": ["uebung", "woche6"]
  },
  {
    "difficulty": 1,
    "type": "multiple",
    "question": "Was passiert in der Methode deleteUser(int id) im GraphQL-Client?",
    "options": [
      "Es wird ein REST-DELETE auf /users/{id} gesendet",
      "Es wird eine GraphQL-Mutation deleteUser mit der übergebenen ID ausgeführt",
      "Es wird nur lokal aus der Liste entfernt",
      "Es wird ein WebSocket-Event gesendet"
    ],
    "correct": 1,
    "explanation": "✅ Richtig: Die Methode führt eine GraphQL-Mutation aus: mutation { deleteUser(id: ...) } – keine REST-Operationen.",
    "xp": 12,
    "tags": ["uebung", "woche6"]
  },
  {
    "difficulty": 2,
    "type": "multiple",
    "question": "Welche Aufgabe hat die Methode logExceptionalResponse(ClientGraphQlResponse response) im Client?",
    "options": [
      "Sie loggt erfolgreiche Responses",
      "Sie wandelt die Antwort in JSON um",
      "Sie protokolliert Fehler und Response-Fehlermeldungen",
      "Sie führt Retries bei Timeout durch"
    ],
    "correct": 2,
    "explanation": "✅ Richtig: logExceptionalResponse() prüft auf Fehler in der Antwort (response.getErrors()) und loggt diese für Debugging-Zwecke.",
    "xp": 18,
    "tags": ["uebung", "woche6"]
  },
  {
    "difficulty": 1,
    "type": "fillblank",
    "question": "Der GraphQL-Endpoint wird im Client als statische Variable _____ = \"http://localhost:8080/graphql\" definiert.",
    "blanks": ["baseURI"],
    "explanation": "✅ Richtig: Die Variable baseURI speichert die URL des GraphQL-Servers und wird beim Client-Aufbau verwendet.",
    "xp": 15,
    "tags": ["uebung", "woche6"]
  },
  {
    "difficulty": 1,
    "type": "multiple",
    "question": "Was ist der Zweck von GraphQL-Subscriptions?",
    "options": [
      "Einmalige Lese-Anfragen",
      "Serverseitiges Streaming von Datenänderungen an den Client",
      "Nur zum Löschen von Daten",
      "Nur für Authentifizierung"
    ],
    "correct": 1,
    "explanation": "✅ Richtig: Subscriptions ermöglichen es dem Server, Datenänderungen in Echtzeit an verbundene Clients zu streamen.",
    "xp": 12,
    "tags": ["uebung", "woche6"]
  },
  {
    "difficulty": 1,
    "type": "multiple",
    "question": "Welcher zusätzliche Datentyp wird für das Subscription-Beispiel definiert?",
    "options": ["UserEvent", "StockPrice", "SubscriptionEvent", "PriceHistory"],
    "correct": 1,
    "explanation": "✅ Richtig: Der Typ StockPrice (mit Feldern wie symbol, price, timestamp) wird im Schema definiert, um Aktienkurse zu streamen.",
    "xp": 12,
    "tags": ["uebung", "woche6"]
  },
  {
    "difficulty": 1,
    "type": "multiple",
    "question": "Welche Annotation kennzeichnet im Controller eine GraphQL-Subscription-Methode?",
    "options": ["@QueryMapping", "@MutationMapping", "@SubscriptionMapping", "@WebSocketMapping"],
    "correct": 2,
    "explanation": "✅ Richtig: @SubscriptionMapping bindet eine Controller-Methode an eine Subscription-Operation aus dem Schema.",
    "xp": 12,
    "tags": ["uebung", "woche6"]
  },
  {
    "difficulty": 2,
    "type": "multiple",
    "question": "Warum wird im Subscription-Beispiel die Klasse Flux verwendet?",
    "options": [
      "Um HTML-Templates zu parsen",
      "Um reaktive Datenströme mit regelmäßigen Intervallen zu erzeugen",
      "Um Datenbanktransaktionen zu verwalten",
      "Um REST-Endpunkte zu registrieren"
    ],
    "correct": 1,
    "explanation": "✅ Richtig: Flux (aus Project Reactor) ermöglicht reaktive, asynchrone Datenströme – ideal für kontinuierliche Subscriptions.",
    "xp": 18,
    "tags": ["uebung", "woche6"]
  },
  {
    "difficulty": 1,
    "type": "fillblank",
    "question": "Der WebSocket-Endpoint für GraphQL-Subscriptions wird in application.properties als _____ konfiguriert.",
    "blanks": ["/graphqlws"],
    "explanation": "✅ Richtig: spring.graphql.websocket.path=/graphqlws legt den WebSocket-Pfad fest, über den Subscriptions laufen.",
    "xp": 15,
    "tags": ["uebung", "woche6"]
  },
  {
    "difficulty": 1,
    "type": "multiple",
    "question": "Welche zusätzliche Spring-Boot-Dependency wird für WebSockets benötigt?",
    "options": [
      "spring-boot-starter-security",
      "spring-boot-starter-web",
      "spring-boot-starter-websocket",
      "spring-boot-starter-logging"
    ],
    "correct": 2,
    "explanation": "✅ Richtig: spring-boot-starter-websocket bringt die WebSocket-Infrastruktur mit, die für GraphQL-Subscriptions nötig ist.",
    "xp": 12,
    "tags": ["uebung", "woche6"]
  },
  {
    "difficulty": 1,
    "type": "multiple",
    "question": "Wofür wird der Parameter wsPath=/graphqlws in der GraphiQL-URL verwendet?",
    "options": [
      "Zur Angabe des REST-Endpoints",
      "Zur Konfiguration des Datenbankpfads",
      "Zur Angabe des WebSocket-Endpoints für Subscriptions",
      "Zur Auswahl des Schemanamens"
    ],
    "correct": 2,
    "explanation": "✅ Richtig: wsPath=/graphqlws teilt GraphiQL mit, wo es sich für Subscriptions per WebSocket verbinden soll.",
    "xp": 12,
    "tags": ["uebung", "woche6"]
  },
  {
    "difficulty": 2,
    "type": "multiple",
    "question": "Wie unterscheidet sich die Ausführung mehrerer Operationen (Queries/Mutations) in einer GraphQL-Request vom typischen REST-Ansatz?",
    "options": [
      "In GraphQL kann nur genau eine Operation pro Request gesendet werden",
      "In GraphQL können mehrere Operationen in einer einzigen HTTP-Request kombiniert werden",
      "REST unterstützt grundsätzlich keine POST-Requests",
      "REST sendet immer mehrere Operationen automatisch"
    ],
    "correct": 1,
    "explanation": "✅ Richtig: GraphQL erlaubt Batching mehrerer Queries/Mutations in einem Request – REST benötigt in der Regel separate Calls.",
    "xp": 18,
    "tags": ["uebung", "woche6"]
  },
  {
    "difficulty": 1,
    "type": "matching",
    "question": "Ordnen Sie die entsprechenden HTTP-Statuscodes richtig zu:",
    "pairs": [
      {
        "left": "Ressource erfolgreich erstellt",
        "right": "201 (Created)"
      },
      {
        "left": "Anfrage konnte aufgrund fehlerhafter Parameter nicht verarbeitet werden",
        "right": "422 (Unprocessable Entity)"
      },
      {
        "left": "Anfrage erfolgreich, Inhalt im Body vorhanden",
        "right": "200 (OK)"
      },
      {
        "left": "Ressource nicht gefunden",
        "right": "404 (Not Found)"
      },
      {
        "left": "Anfrage erfolgreich, aber keine Rückgabe",
        "right": "204 (No Content)"
      }
    ],
    "explanation": "✅ Richtig: 201 = Created (neue Ressource), 422 = Unprocessable Entity (fehlerhafte Parameter), 200 = OK (Erfolg mit Body), 404 = Not Found (unbekannte URI), 204 = No Content (Erfolg ohne Body).",
    "xp": 20,
    "tags": ["offiziell", "woche5"]
  },
  {
    "difficulty": 1,
    "type": "multiple",
    "question": "Welche Annotation wird verwendet, um eine Klasse als REST-Controller zu markieren?",
    "options": ["@RestController", "@Controller", "@ResponseEntity", "@Service"],
    "correct": 0,
    "explanation": "✅ Richtig: @RestController kombiniert @Controller und @ResponseBody – die Rückgabewerte werden direkt serialisiert (z. B. als JSON).",
    "xp": 10,
    "tags": ["offiziell", "woche5"]
  },
  {
    "difficulty": 1,
    "type": "multiple",
    "question": "Ressourcen-URIs im REST-Design sollen möglichst Verben enthalten, um Aktionen zu beschreiben.",
    "options": ["Wahr", "Falsch"],
    "correct": 1,
    "explanation": "✅ Richtig: URIs sollten Substantive (Ressourcen) verwenden, z. B. /users/123. Aktionen werden durch HTTP-Methoden (GET, POST, PUT, DELETE) ausgedrückt.",
    "xp": 10,
    "tags": ["offiziell", "woche5"]
  },
  {
    "difficulty": 1,
    "type": "multiple",
    "question": "REST-Kommunikation ist immer synchron.",
    "options": ["Wahr", "Falsch"],
    "correct": 1,
    "explanation": "✅ Richtig: REST ist typischerweise synchron (Request-Response), kann aber mit Callbacks, Webhooks oder asynchronen Patterns (z. B. 202 Accepted) asynchron gestaltet werden.",
    "xp": 12,
    "tags": ["offiziell", "woche5"]
  },
  {
    "difficulty": 1,
    "type": "multiple",
    "question": "GET-Anfragen können den HTTP-Body enthalten. (Im Sinne der Best Practice)",
    "options": ["Wahr", "Falsch"],
    "correct": 1,
    "explanation": "✅ Richtig: Laut HTTP-Spezifikation ist ein Body bei GET technisch erlaubt, aber Best Practice und viele Frameworks ignorieren ihn – Parameter gehören in die URL.",
    "xp": 12,
    "tags": ["offiziell", "woche5"]
  },
  {
    "difficulty": 1,
    "type": "multiple",
    "question": "Was bedeutet es, dass REST-Kommunikation zustandslos ist?",
    "options": [
      "Kommunikation erfolgt synchron",
      "Der Server speichert keine Sitzungsinformationen",
      "Der Client hält die Sitzungsinformationen",
      "Der Server speichert alle Client-Daten"
    ],
    "correct": 1,
    "explanation": "✅ Richtig: Stateless bedeutet, der Server speichert keinen Session-State – jede Anfrage enthält alle benötigten Informationen (z. B. via Token).",
    "xp": 12,
    "tags": ["offiziell", "woche5"]
  },
  {
    "difficulty": 2,
    "type": "checkbox",
    "question": "Markieren Sie alle HTTP-Methoden, die sowohl 'safe' (sicher) als auch 'idempotent' (idempotent) sind:",
    "options": ["GET", "POST", "PUT", "DELETE", "HEAD", "OPTIONS", "PATCH"],
    "correct": [0, 4, 5],
    "explanation": "✅ Richtig: GET, HEAD und OPTIONS sind safe (keine Seiteneffekte) und idempotent (wiederholbar ohne Änderung). POST und PATCH sind weder safe noch idempotent. PUT und DELETE sind idempotent, aber nicht safe.",
    "xp": 18,
    "tags": ["offiziell", "woche5"]
  },
  {
    "difficulty": 1,
    "type": "checkbox",
    "question": "Markieren Sie alle HTTP-Methoden, die idempotent sind (wiederholbare Aufrufe führen zum gleichen Zustand):",
    "options": ["GET", "POST", "PUT", "DELETE", "HEAD", "OPTIONS", "PATCH"],
    "correct": [0, 2, 3, 4, 5],
    "explanation": "✅ Richtig: GET, PUT, DELETE, HEAD und OPTIONS sind idempotent. POST ist nicht idempotent (erzeugt mehrfach Ressourcen). PATCH ist typischerweise nicht idempotent.",
    "xp": 15,
    "tags": ["offiziell", "woche5"]
  },
  {
    "difficulty": 1,
    "type": "multiple",
    "question": "Eine Ressource kann nur aus einem einzelnen Objekt bestehen, niemals aus einer Liste.",
    "options": ["Wahr", "Falsch"],
    "correct": 1,
    "explanation": "✅ Richtig: Eine Ressource kann sowohl eine einzelne Entität (/users/123) als auch eine Sammlung (/users) darstellen.",
    "xp": 10,
    "tags": ["offiziell", "woche5"]
  },
  {
    "difficulty": 1,
    "type": "multiple",
    "question": "Ein MVC-Controller ist darauf ausgelegt, View-Namen zurückzugeben und ein Modell für die Darstellung in HTML-Seiten anzureichern.",
    "options": ["Wahr", "Falsch"],
    "correct": 0,
    "explanation": "✅ Richtig: Klassische @Controller in Spring MVC geben View-Namen (z. B. \"index\") zurück und füllen das Model für Template-Engines wie Thymeleaf.",
    "xp": 10,
    "tags": ["offiziell", "woche5"]
  },
  {
    "difficulty": 1,
    "type": "multiple",
    "question": "Es ist sinnvoll, Nutzdaten bei HTTP-POST- oder PUT-Requests im URL-Parameter zu übertragen, da URLs für alle Nutzdaten optimiert sind.",
    "options": ["Wahr", "Falsch"],
    "correct": 1,
    "explanation": "✅ Richtig: Nutzdaten (z. B. JSON) gehören in den HTTP-Body, nicht in URL-Parameter – URLs sind begrenzt, unsicher für sensible Daten und schlecht lesbar bei großen Payloads.",
    "xp": 12,
    "tags": ["offiziell", "woche5"]
  },
  {
    "difficulty": 1,
    "type": "multiple",
    "question": "Primärsammlungen sind Hauptsammlungen von Ressourcen, während Sekundärsammlungen Untersammlungen innerhalb einer Primärsammlung sind.",
    "options": ["Wahr", "Falsch"],
    "correct": 0,
    "explanation": "✅ Richtig: Primärsammlung: /users (Hauptressource). Sekundärsammlung: /users/123/orders (Unterressourcen eines Users).",
    "xp": 12,
    "tags": ["offiziell", "woche5"]
  },
  {
    "difficulty": 1,
    "type": "multiple",
    "question": "Ohne HATEOAS wäre eine REST-API immer vollständig und intuitiv navigierbar.",
    "options": ["Wahr", "Falsch"],
    "correct": 1,
    "explanation": "✅ Richtig: HATEOAS (Hypermedia As The Engine Of Application State) macht APIs navigierbar, indem Responses Links zu verwandten Ressourcen enthalten – ohne HATEOAS muss der Client alle URIs kennen.",
    "xp": 12,
    "tags": ["offiziell", "woche5"]
  }
]